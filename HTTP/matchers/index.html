<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8" /> 
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover"> 
<title>WebTau: Matchers</title>
<link rel="stylesheet" type="text/css" href="/webtau/static/css/katex.min.css">
<link rel="stylesheet" type="text/css" href="/webtau/static/main.css">
<link rel="stylesheet" type="text/css" href="/webtau/logo.css">
<link rel="stylesheet" type="text/css" href="/webtau/static/css/global-overrides.css">
</head>
<link rel="shortcut icon" href="/webtau/favicon.png"type="image/ico"/>
<body class="theme-znai-dark">
<script>(function() {
    var themeNameKey = 'znaiTheme';
    var darkThemeName = 'znai-dark';
    var lightThemeName = 'default';

    var znaiTheme = {
        changeHandlers: [],
        addChangeHandler(handler) {
            this.changeHandlers.push(handler);
        },
        removeChangeHandler(handler) {
            var idx = this.changeHandlers.indexOf(handler);
            this.changeHandlers.splice(idx, 1);
        },
        set(name) {
            this.name = name;
            document.body.className = 'theme-' + name;

            var idx = 0;
            var len = this.changeHandlers.length;
            for (; idx < len; idx++) {
                this.changeHandlers[idx](name);
            }
        },
        setExplicitly(name) {
            storeThemeName(name);
            this.set(name);
        },
        setExplicitlyIfNotSetAlready(name) {
            const themeName = getStoredThemeName();
            if (themeName) {
                return
            }

            this.setExplicitly(name)
        },
        toggle() {
            this.setExplicitly(this.name === lightThemeName ? darkThemeName : lightThemeName)
        }
    };

    var mediaThemeName = setLightMatchMediaListenerAndGetThemeName()
    var themeName = getStoredThemeName() || mediaThemeName;
    znaiTheme.set(themeName);

    window.znaiTheme = znaiTheme;

    function getStoredThemeName() {
        return localStorage.getItem(themeNameKey);
    }

    function storeThemeName(name) {
        return localStorage.setItem(themeNameKey, name);
    }

    function setLightMatchMediaListenerAndGetThemeName() {
        if (!window.matchMedia) {
            return darkThemeName;
        }

        var lightQuery = window.matchMedia('(prefers-color-scheme: light)');
        lightQuery.addListener(function (e) {
            const newThemeName = e.matches ? lightThemeName : darkThemeName;
            znaiTheme.setExplicitly(newThemeName);
        });

        return lightQuery.matches ? lightThemeName : darkThemeName;
    }
})()</script>
<div id="znai"><div id="znai-initial-page-loading" style="margin: -20px 0 0 -20px; padding: 0 40px 40px 0; width: 100vw; height: 100vh; display: flex; justify-content: center; align-items: center">
    <div></div>
</div><section style="max-width: 640px; margin-left: auto; margin-right: auto;">
<article>
<header><h1>Response Mapping</h1></header>
<p>Check HTTP/import-and-dependencies Import And Dependencies for prerequisites. Identifiers inside validation closure are automatically mapped to a response body. Groovy http.get(&quot;/end-point-simple-object&quot;) { k1.should == &quot;v1&quot; } Java http.get(&quot;/end-point-simple-object&quot;, (header, body) -&gt; { body.get(&quot;k1&quot;).should(equal(&quot;v1&quot;)); }); List responses are handled by using index chain Groovy http.get(&quot;/end-point-simple-list&quot;) { body[0].k1.should == &quot;v1&quot; } Note: Groovy API implicitly assumes body , but if you need to deal with array response you need to access values using body explicitly. Java http.get(&quot;/end-point-simple-list&quot;, (header, body) -&gt; { body.get(0).get(&quot;k1&quot;).should(equal(&quot;v1&quot;)); });</p>
</article>

<article>
<header><h1>Should and Should Not</h1></header>
<p>Matchers in WebTau are triggered with should and shouldNot keywords. Additionally shouldBe and shouldNotBe alias keywords are available to make certain matcher combinations easier to read. Groovy http.get(&quot;/example&quot;) { year.shouldNot == 2000 year.should != 2000 // alternative shortcut genres.should contain(&quot;RPG&quot;) rating.shouldBe &gt; 7 } Java http.get(&quot;/example&quot;, (header, body) -&gt; { body.get(&quot;year&quot;).shouldNot(equal(2000)); body.get(&quot;genres&quot;).should(contain(&quot;RPG&quot;)); body.get(&quot;rating&quot;).shouldBe(greaterThan(7)); });</p>
</article>

<article>
<header><h1>Equality</h1></header>
<p>WebTau defines its own set of equality rules to simplify testing. Groovy http.get(&quot;/end-point&quot;) { id.should != 0 amount.should == 30 list.should == [1, 2, 3] object.k1.should == ~/v\d/ // regular expression matching object.should == [k1: &quot;v1&quot;, k3: &quot;v3&quot;] // matching only specified fields and can be nested multiple times complexList.should == [&quot;k1&quot; | &quot;k2&quot;] { // matching only specified fields, but number of entries must be exact ________________ &quot;v1&quot; | 30 &quot;v11&quot; | 40 } } Java http.get(&quot;/end-point&quot;, (header, body) -&gt; { body.get(&quot;id&quot;).shouldNot(equal(0)); body.get(&quot;amount&quot;).should(equal(30)); body.get(&quot;list&quot;).should(equal(list(1, 2, 3))); body.get(&quot;object&quot;).get(&quot;k1&quot;).should(equal( Pattern.compile(&quot;v\\d&quot;))); // regular expression matching body.get(&quot;object&quot;).should(equal(map( &quot;k1&quot;, &quot;v1&quot;, &quot;k3&quot;, &quot;v3&quot;))); // matching only specified fields and can be nested multiple times body.get(&quot;complexList&quot;).should(equal(table(&quot;k1&quot; , &quot;k2&quot;, // matching only specified fields, but number of entries must be exact ________________, &quot;v1&quot; , 30, &quot;v11&quot;, 40))); }); Groovy http.get(&quot;/end-point&quot;) { complexList.should == [ &quot;*id&quot; | &quot;k1&quot; | &quot;k2&quot;] { // order agnostic key based match ________________________ &quot;id2&quot; | &quot;v11&quot; | 40 &quot;id1&quot; | &quot;v1&quot; | 30 } } Java http.get(&quot;/end-point&quot;, (header, body) -&gt; { body.get(&quot;complexList&quot;).should(equal(table(&quot;*id&quot;, &quot;k1&quot; , &quot;k2&quot;, // order agnostic key based match ________________, &quot;id2&quot;, &quot;v11&quot;, 40, &quot;id1&quot;, &quot;v1&quot; , 30))); });</p>
</article>

<article>
<header><h1>Greater/Less/Equal</h1></header>
<p>Use greaterThan , greaterThanOrEqual , lessThan , and lessThanOrEqual to assert numeric values. Groovy http.get(&quot;/end-point-numbers&quot;) { id.shouldBe &gt; 0 price.shouldBe &gt;= 100 amount.shouldBe &lt; 150 list[1].shouldBe &lt;= 2 id.shouldNotBe &lt;= 0 price.shouldNotBe &lt; 100 amount.shouldNotBe &gt;= 150 list[1].shouldNotBe &gt; 2 } Note: Groovy can use shortcuts &gt; , &gt;= , &lt; , &lt;= . Java http.get(&quot;/end-point-numbers&quot;, (header, body) -&gt; { body.get(&quot;id&quot;).shouldBe(greaterThan(0)); body.get(&quot;price&quot;).shouldBe(greaterThanOrEqual(100)); body.get(&quot;amount&quot;).shouldBe(lessThan(150)); body.get(&quot;list&quot;).get(1).shouldBe(lessThanOrEqual(2)); body.get(&quot;id&quot;).shouldNotBe(lessThanOrEqual(0)); body.get(&quot;price&quot;).shouldNotBe(lessThan(100)); body.get(&quot;amount&quot;).shouldNotBe(greaterThanOrEqual(150)); body.get(&quot;list&quot;).get(1).shouldNotBe(greaterThan(2)); });</p>
</article>

<article>
<header><h1>Contain</h1></header>
<p>Use contain when you cannot rely on order of values in a response. Groovy http.get(&quot;/end-point-list&quot;) { body.should contain([k1: &quot;v1&quot;, k2: &quot;v2&quot;]) body[1].k2.shouldNot contain(22) } Java http.get(&quot;/end-point-list&quot;, (header, body) -&gt; { body.should(contain(map( &quot;k1&quot;, &quot;v1&quot;, &quot;k2&quot;, &quot;v2&quot;))); body.get(1).get(&quot;k2&quot;).shouldNot(contain(22)); });</p>
</article>

<article>
<header><h1>Contain Table</h1></header>
<p>Use contain and TableData to assert that a list contains multiple entries of interest Groovy http.get(&quot;/end-point-large-list&quot;) { body.should contain([&quot;id&quot; | &quot;k1&quot; | &quot;k2&quot;] { ________________________ &quot;id1&quot; | &quot;v11&quot; | &quot;v12&quot; &quot;id3&quot; | &quot;v31&quot; | &quot;v32&quot; }) } Java http.get(&quot;/end-point-large-list&quot;, (header, body) -&gt; { body.should(contain(table(&quot;id&quot;, &quot;k1&quot; , &quot;k2&quot;, ______________________, &quot;id1&quot;, &quot;v11&quot;, &quot;v12&quot;, &quot;id3&quot;, &quot;v31&quot;, &quot;v32&quot; ))); });</p>
</article>

<article>
<header><h1>Contain All</h1></header>
<p>Use containAll when you cannot rely on order of values in a response and need to check more than one value. Groovy http.get(&quot;/end-point-list&quot;) { body[1].k2.should containAll(10, 30) body[1].k2.shouldNot containAll(40, 60, 80) } Java http.get(&quot;/end-point-list&quot;, (header, body) -&gt; { body.get(1).get(&quot;k2&quot;).should(containAll(10, 30)); body.get(1).get(&quot;k2&quot;).shouldNot(containAll(40, 60, 80)); });</p>
</article>

<article>
<header><h1>Nested Contain All</h1></header>
<p>Use containingAll alias to make it easier to read containAll matcher nested inside contain . Groovy http.get(&quot;/prices&quot;) { body.prices.should contain(containingAll(10, 30)) } Java http.get(&quot;/prices&quot;, (header, body) -&gt; { body.get(&quot;prices&quot;).should(contain(containingAll(10, 30))); });</p>
</article>

<article>
<header><h1>Date and Time</h1></header>
<p>You can assert actual string against LocalDate and ZonedDateTime . String will be automatically converted using ISO formatter. Groovy http.get(&quot;/end-point-dates&quot;) { def expectedDate = LocalDate.of(2018, 6, 12) def expectedTime = ZonedDateTime.of(expectedDate, LocalTime.of(9, 0, 0), ZoneId.of(&quot;UTC&quot;)) tradeDate.should == expectedDate transactionTime.should == expectedTime transactionTime.shouldBe &gt;= expectedDate paymentSchedule.should contain(expectedDate) } Java http.get(&quot;/end-point-dates&quot;, (header, body) -&gt; { LocalDate expectedDate = LocalDate.of(2018, 6, 12); ZonedDateTime expectedTime = ZonedDateTime.of(expectedDate, LocalTime.of(9, 0, 0), ZoneId.of(&quot;UTC&quot;)); body.get(&quot;tradeDate&quot;).should(equal(expectedDate)); body.get(&quot;transactionTime&quot;).should(equal(expectedTime)); body.get(&quot;transactionTime&quot;).shouldBe(greaterThanOrEqual(expectedDate)); body.get(&quot;paymentSchedule&quot;).should(contain(expectedDate)); });</p>
</article>

<article>
<header><h1>Mixing Matchers</h1></header>
<p>You can use matchers in place of expected values to build a more complex expectation. Groovy http.get(&quot;/end-point-mixed&quot;) { list.should contain(lessThanOrEqual(2)) // lessThanOrEqual will be matched against each value object.should == [k1: &quot;v1&quot;, k3: ~/v\d/] // regular expression match against k3 complexList[0].should == [k1: &quot;v1&quot;, k2: lessThan(120)] // lessThen match against k2 complexList[1].should == [ k1: notEqual(&quot;v1&quot;), // any value but v1 k2: greaterThanOrEqual(120)] complexList.should == [&quot;k1&quot; | &quot;k2&quot;] { ___________________________ ~/v\d/ | lessThan(120) &quot;v11&quot; | greaterThan(150) } // using matchers as cell values } Java Pattern withNumber = Pattern.compile(&quot;v\\d&quot;); http.get(&quot;/end-point-mixed&quot;, (header, body) -&gt; { body.get(&quot;list&quot;).should(contain(lessThanOrEqual(2))); // lessThanOrEqual will be matched against each value body.get(&quot;object&quot;).should(equal(map( &quot;k1&quot;, &quot;v1&quot;, &quot;k3&quot;, withNumber))); // regular expression match against k3 body.get(&quot;complexList&quot;).get(0).should(equal(map( &quot;k1&quot;, &quot;v1&quot;, &quot;k2&quot;, lessThan(120)))); // lessThen match against k2 body.get(&quot;complexList&quot;).get(1).should(equal(map( &quot;k1&quot;, notEqual(&quot;v1&quot;), // any value but v1 &quot;k2&quot;, greaterThanOrEqual(120)))); TableData expected = table(&quot;k1&quot; , &quot;k2&quot;, // matching only specified fields, but number of entries must be exact ________________________________, withNumber , lessThan(120), &quot;v11&quot; , greaterThan(150)); body.get(&quot;complexList&quot;).should(equal(expected)); });</p>
</article>
</section>
</div>
<script type="text/javascript" src="/webtau/footer.js"></script>
<script type="text/javascript" src="/webtau/toc.js"></script>
<script type="text/javascript" src="/webtau/documentation-references.js"></script>
<script type="text/javascript" src="/webtau/assets.js"></script>
<script type="text/javascript" src="/webtau/static/main.js"></script>
<script type="text/javascript" src="/webtau/search-index.js"></script>
<script>
document.getElementById('znai').innerHTML = '';
/*<!--*/
ReactDOM.render(React.createElement(Documentation, {
  "docMeta" : {
    "viewOn" : {
      "link" : "https://github.com/testingisdocumenting/webtau/tree/master/webtau-docs/znai",
      "title" : "View Markdown"
    },
    "id" : "webtau",
    "title" : "WebTau",
    "type" : "Guide",
    "previewEnabled" : false,
    "support" : {
      "link" : "https://github.com/testingisdocumenting/webtau/discussions",
      "title" : "GitHub"
    }
  },
  "page" : {
    "type" : "Page",
    "content" : [ {
      "type" : "Paragraph",
      "content" : [ {
        "text" : "Check ",
        "type" : "SimpleText"
      }, {
        "url" : "/webtau/HTTP/import-and-dependencies",
        "isFile" : false,
        "type" : "Link",
        "content" : [ {
          "text" : "Import And Dependencies",
          "type" : "SimpleText"
        } ]
      }, {
        "text" : " for prerequisites.",
        "type" : "SimpleText"
      } ]
    }, {
      "id" : "response-mapping",
      "title" : "Response Mapping",
      "type" : "Section",
      "content" : [ {
        "type" : "Paragraph",
        "content" : [ {
          "text" : "Identifiers inside validation closure are automatically mapped to a response body.",
          "type" : "SimpleText"
        } ]
      }, {
        "meta" : {
          "rightSide" : true
        },
        "type" : "EmptyBlock"
      }, {
        "title" : "object response",
        "meta" : {
          "rightSide" : false
        },
        "data" : {
          "id" : "id1",
          "k1" : "v1",
          "k2" : "v2"
        },
        "paths" : [ ],
        "anchorId" : "response-mapping-object-response",
        "type" : "Json"
      }, {
        "meta" : {
          "rightSide" : true
        },
        "tabsContent" : [ {
          "name" : "Groovy",
          "content" : [ {
            "lang" : "groovy",
            "snippet" : "http.get(\"/end-point-simple-object\") {\n    k1.should == \"v1\"\n}",
            "entry" : "simple object mapping example",
            "bodyOnly" : true,
            "type" : "Snippet"
          } ]
        }, {
          "name" : "Java",
          "content" : [ {
            "lang" : "java",
            "snippet" : "http.get(\"/end-point-simple-object\", (header, body) -> {\n    body.get(\"k1\").should(equal(\"v1\"));\n});",
            "entry" : "simpleObjectMappingExample",
            "bodyOnly" : true,
            "type" : "Snippet"
          } ]
        } ],
        "type" : "Tabs"
      }, {
        "type" : "Paragraph",
        "content" : [ {
          "text" : "List responses are handled by using index chain",
          "type" : "SimpleText"
        } ]
      }, {
        "meta" : {
          "rightSide" : true
        },
        "type" : "EmptyBlock"
      }, {
        "title" : "list response",
        "data" : [ {
          "id" : "id1",
          "k1" : "v1",
          "k2" : "v2"
        } ],
        "paths" : [ ],
        "anchorId" : "response-mapping-list-response",
        "type" : "Json"
      }, {
        "meta" : {
          "rightSide" : true
        },
        "tabsContent" : [ {
          "name" : "Groovy",
          "content" : [ {
            "lang" : "groovy",
            "snippet" : "http.get(\"/end-point-simple-list\") {\n    body[0].k1.should == \"v1\"\n}",
            "entry" : "simple list mapping example",
            "bodyOnly" : true,
            "type" : "Snippet"
          }, {
            "type" : "Paragraph",
            "content" : [ {
              "text" : "Note: Groovy API implicitly assumes ",
              "type" : "SimpleText"
            }, {
              "code" : "body",
              "type" : "InlinedCode"
            }, {
              "text" : ", but if you need to deal with array response you need to access values using ",
              "type" : "SimpleText"
            }, {
              "code" : "body",
              "type" : "InlinedCode"
            }, {
              "text" : " explicitly.",
              "type" : "SimpleText"
            } ]
          } ]
        }, {
          "name" : "Java",
          "content" : [ {
            "lang" : "java",
            "snippet" : "http.get(\"/end-point-simple-list\", (header, body) -> {\n    body.get(0).get(\"k1\").should(equal(\"v1\"));\n});",
            "entry" : "simpleListMappingExample",
            "bodyOnly" : true,
            "type" : "Snippet"
          } ]
        } ],
        "type" : "Tabs"
      } ]
    }, {
      "id" : "should-and-should-not",
      "title" : "Should and Should Not",
      "type" : "Section",
      "content" : [ {
        "type" : "Paragraph",
        "content" : [ {
          "text" : "Matchers in WebTau are triggered with ",
          "type" : "SimpleText"
        }, {
          "code" : "should",
          "type" : "InlinedCode"
        }, {
          "text" : " and ",
          "type" : "SimpleText"
        }, {
          "code" : "shouldNot",
          "type" : "InlinedCode"
        }, {
          "text" : " keywords.",
          "type" : "SimpleText"
        }, {
          "type" : "SoftLineBreak"
        }, {
          "text" : "Additionally ",
          "type" : "SimpleText"
        }, {
          "code" : "shouldBe",
          "type" : "InlinedCode"
        }, {
          "text" : " and ",
          "type" : "SimpleText"
        }, {
          "code" : "shouldNotBe",
          "type" : "InlinedCode"
        }, {
          "text" : " alias keywords are available to make certain matcher combinations easier to read.",
          "type" : "SimpleText"
        } ]
      }, {
        "meta" : {
          "rightSide" : true
        },
        "tabsContent" : [ {
          "name" : "Groovy",
          "content" : [ {
            "lang" : "groovy",
            "snippet" : "http.get(\"/example\") {\n    year.shouldNot == 2000\n    year.should != 2000  // alternative shortcut\n    genres.should contain(\"RPG\")\n    rating.shouldBe > 7\n}",
            "entry" : "matchers basic example",
            "bodyOnly" : true,
            "type" : "Snippet"
          } ]
        }, {
          "name" : "Java",
          "content" : [ {
            "lang" : "java",
            "snippet" : "http.get(\"/example\", (header, body) -> {\n    body.get(\"year\").shouldNot(equal(2000));\n    body.get(\"genres\").should(contain(\"RPG\"));\n    body.get(\"rating\").shouldBe(greaterThan(7));\n});",
            "entry" : "matchersBasicExample",
            "bodyOnly" : true,
            "type" : "Snippet"
          } ]
        } ],
        "type" : "Tabs"
      } ]
    }, {
      "id" : "equality",
      "title" : "Equality",
      "type" : "Section",
      "content" : [ {
        "type" : "Paragraph",
        "content" : [ {
          "text" : "WebTau defines its own set of equality rules to simplify testing.",
          "type" : "SimpleText"
        } ]
      }, {
        "meta" : {
          "rightSide" : true
        },
        "type" : "EmptyBlock"
      }, {
        "title" : "response",
        "pathsFile" : "doc-artifacts/end-point-object-equality-matchers/paths.json",
        "data" : {
          "id" : 10,
          "price" : 100,
          "amount" : 30,
          "list" : [ 1, 2, 3 ],
          "object" : {
            "k1" : "v1",
            "k2" : "v2",
            "k3" : "v3"
          },
          "complexList" : [ {
            "id" : "id1",
            "k1" : "v1",
            "k2" : 30
          }, {
            "id" : "id2",
            "k1" : "v11",
            "k2" : 40
          } ]
        },
        "paths" : [ "root.amount", "root.complexList[0].k1", "root.complexList[0].k2", "root.complexList[1].k1", "root.complexList[1].k2", "root.id", "root.list[0]", "root.list[1]", "root.list[2]", "root.object.k1", "root.object.k3" ],
        "anchorId" : "equality-response",
        "type" : "Json"
      }, {
        "meta" : {
          "rightSide" : true
        },
        "tabsContent" : [ {
          "name" : "Groovy",
          "content" : [ {
            "lang" : "groovy",
            "snippet" : "http.get(\"/end-point\") {\n    id.should != 0\n    amount.should == 30\n\n    list.should == [1, 2, 3]\n\n    object.k1.should == ~/v\\d/ // regular expression matching\n\n    object.should == [k1: \"v1\", k3: \"v3\"] // matching only specified fields and can be nested multiple times\n\n    complexList.should == [\"k1\"   | \"k2\"] { // matching only specified fields, but number of entries must be exact\n                           ________________\n                            \"v1\"  | 30\n                            \"v11\" | 40 }\n}",
            "entry" : "equality matcher",
            "bodyOnly" : true,
            "commentsType" : "inline",
            "excludeRegexp" : "doc.capture",
            "type" : "Snippet"
          } ]
        }, {
          "name" : "Java",
          "content" : [ {
            "lang" : "java",
            "snippet" : "http.get(\"/end-point\", (header, body) -> {\n    body.get(\"id\").shouldNot(equal(0));\n    body.get(\"amount\").should(equal(30));\n\n    body.get(\"list\").should(equal(list(1, 2, 3)));\n\n    body.get(\"object\").get(\"k1\").should(equal(\n            Pattern.compile(\"v\\\\d\"))); // regular expression matching\n\n    body.get(\"object\").should(equal(map(\n            \"k1\", \"v1\",\n            \"k3\", \"v3\"))); // matching only specified fields and can be nested multiple times\n\n    body.get(\"complexList\").should(equal(table(\"k1\" , \"k2\", // matching only specified fields, but number of entries must be exact\n                                              ________________,\n                                               \"v1\" ,  30,\n                                               \"v11\",  40)));\n});",
            "entry" : "equalityMatcher",
            "bodyOnly" : true,
            "commentsType" : "inline",
            "excludeRegexp" : "doc.capture",
            "type" : "Snippet"
          } ]
        } ],
        "type" : "Tabs"
      }, {
        "meta" : {
          "rightSide" : true
        },
        "tabsContent" : [ {
          "name" : "Groovy",
          "content" : [ {
            "lang" : "groovy",
            "snippet" : "http.get(\"/end-point\") {\n    complexList.should == [ \"*id\" | \"k1\"  | \"k2\"] { // order agnostic key based match\n                           ________________________\n                            \"id2\" | \"v11\" | 40\n                            \"id1\" | \"v1\"  | 30 }\n}",
            "entry" : "equality matcher table keys",
            "bodyOnly" : true,
            "commentsType" : "inline",
            "type" : "Snippet"
          } ]
        }, {
          "name" : "Java",
          "content" : [ {
            "lang" : "java",
            "snippet" : "http.get(\"/end-point\", (header, body) -> {\n    body.get(\"complexList\").should(equal(table(\"*id\", \"k1\" , \"k2\", // order agnostic key based match\n                                               ________________,\n                                               \"id2\", \"v11\", 40,\n                                               \"id1\", \"v1\" , 30)));\n});",
            "entry" : "equalityMatcherTableKey",
            "bodyOnly" : true,
            "commentsType" : "inline",
            "type" : "Snippet"
          } ]
        } ],
        "type" : "Tabs"
      } ]
    }, {
      "id" : "greater-less-equal",
      "title" : "Greater/Less/Equal",
      "type" : "Section",
      "content" : [ {
        "type" : "Paragraph",
        "content" : [ {
          "text" : "Use ",
          "type" : "SimpleText"
        }, {
          "code" : "greaterThan",
          "type" : "InlinedCode"
        }, {
          "text" : ", ",
          "type" : "SimpleText"
        }, {
          "code" : "greaterThanOrEqual",
          "type" : "InlinedCode"
        }, {
          "text" : ", ",
          "type" : "SimpleText"
        }, {
          "code" : "lessThan",
          "type" : "InlinedCode"
        }, {
          "text" : ", and ",
          "type" : "SimpleText"
        }, {
          "code" : "lessThanOrEqual",
          "type" : "InlinedCode"
        }, {
          "text" : " to assert numeric values.",
          "type" : "SimpleText"
        } ]
      }, {
        "meta" : {
          "rightSide" : true
        },
        "type" : "EmptyBlock"
      }, {
        "title" : "response",
        "pathsFile" : "doc-artifacts/end-point-numbers-matchers/paths.json",
        "data" : {
          "id" : 10,
          "price" : 100,
          "amount" : 30,
          "list" : [ 1, 2, 3 ]
        },
        "paths" : [ "root.amount", "root.id", "root.list[1]", "root.price" ],
        "anchorId" : "greater-less-equal-response",
        "type" : "Json"
      }, {
        "meta" : {
          "rightSide" : true
        },
        "tabsContent" : [ {
          "name" : "Groovy",
          "content" : [ {
            "lang" : "groovy",
            "snippet" : "http.get(\"/end-point-numbers\") {\n    id.shouldBe > 0\n    price.shouldBe >= 100\n    amount.shouldBe < 150\n    list[1].shouldBe <= 2\n\n    id.shouldNotBe <= 0\n    price.shouldNotBe < 100\n    amount.shouldNotBe >= 150\n    list[1].shouldNotBe > 2\n}",
            "entry" : "compare numbers with greater less matchers",
            "bodyOnly" : true,
            "excludeRegexp" : "doc.capture",
            "type" : "Snippet"
          }, {
            "type" : "Paragraph",
            "content" : [ {
              "text" : "Note: ",
              "type" : "SimpleText"
            }, {
              "code" : "Groovy",
              "type" : "InlinedCode"
            }, {
              "text" : " can use shortcuts ",
              "type" : "SimpleText"
            }, {
              "code" : ">",
              "type" : "InlinedCode"
            }, {
              "text" : ", ",
              "type" : "SimpleText"
            }, {
              "code" : ">=",
              "type" : "InlinedCode"
            }, {
              "text" : ", ",
              "type" : "SimpleText"
            }, {
              "code" : "<",
              "type" : "InlinedCode"
            }, {
              "text" : ", ",
              "type" : "SimpleText"
            }, {
              "code" : "<=",
              "type" : "InlinedCode"
            }, {
              "text" : ".",
              "type" : "SimpleText"
            } ]
          } ]
        }, {
          "name" : "Java",
          "content" : [ {
            "lang" : "java",
            "snippet" : "http.get(\"/end-point-numbers\", (header, body) -> {\n    body.get(\"id\").shouldBe(greaterThan(0));\n    body.get(\"price\").shouldBe(greaterThanOrEqual(100));\n    body.get(\"amount\").shouldBe(lessThan(150));\n    body.get(\"list\").get(1).shouldBe(lessThanOrEqual(2));\n\n    body.get(\"id\").shouldNotBe(lessThanOrEqual(0));\n    body.get(\"price\").shouldNotBe(lessThan(100));\n    body.get(\"amount\").shouldNotBe(greaterThanOrEqual(150));\n    body.get(\"list\").get(1).shouldNotBe(greaterThan(2));\n});",
            "entry" : "compareNumbersWithGreaterLessMatchers",
            "bodyOnly" : true,
            "excludeRegexp" : "doc.capture",
            "type" : "Snippet"
          } ]
        } ],
        "type" : "Tabs"
      } ]
    }, {
      "id" : "contain",
      "title" : "Contain",
      "type" : "Section",
      "content" : [ {
        "type" : "Paragraph",
        "content" : [ {
          "text" : "Use ",
          "type" : "SimpleText"
        }, {
          "code" : "contain",
          "type" : "InlinedCode"
        }, {
          "text" : " when you cannot rely on order of values in a response.",
          "type" : "SimpleText"
        } ]
      }, {
        "meta" : {
          "rightSide" : true
        },
        "type" : "EmptyBlock"
      }, {
        "title" : "response",
        "pathsFile" : "doc-artifacts/end-point-list-contain-matchers/paths.json",
        "data" : [ {
          "id" : "id1",
          "k1" : "v1",
          "k2" : "v2"
        }, {
          "id" : "id2",
          "k1" : "v11",
          "k2" : [ 10, 20, 30 ]
        } ],
        "paths" : [ "root[0].k1", "root[0].k2", "root[1].k2[0]", "root[1].k2[1]", "root[1].k2[2]" ],
        "anchorId" : "contain-response",
        "type" : "Json"
      }, {
        "meta" : {
          "rightSide" : true
        },
        "tabsContent" : [ {
          "name" : "Groovy",
          "content" : [ {
            "lang" : "groovy",
            "snippet" : "http.get(\"/end-point-list\") {\n    body.should contain([k1: \"v1\", k2: \"v2\"])\n    body[1].k2.shouldNot contain(22)\n}",
            "entry" : "contain matcher",
            "bodyOnly" : true,
            "excludeRegexp" : "doc.capture",
            "type" : "Snippet"
          } ]
        }, {
          "name" : "Java",
          "content" : [ {
            "lang" : "java",
            "snippet" : "http.get(\"/end-point-list\", (header, body) -> {\n    body.should(contain(map(\n            \"k1\", \"v1\",\n            \"k2\", \"v2\")));\n    body.get(1).get(\"k2\").shouldNot(contain(22));\n});",
            "entry" : "containMatcher",
            "bodyOnly" : true,
            "excludeRegexp" : "doc.capture",
            "type" : "Snippet"
          } ]
        } ],
        "type" : "Tabs"
      } ]
    }, {
      "id" : "contain-table",
      "title" : "Contain Table",
      "type" : "Section",
      "content" : [ {
        "type" : "Paragraph",
        "content" : [ {
          "text" : "Use ",
          "type" : "SimpleText"
        }, {
          "code" : "contain",
          "type" : "InlinedCode"
        }, {
          "text" : " and ",
          "type" : "SimpleText"
        }, {
          "code" : "TableData",
          "type" : "InlinedCode"
        }, {
          "text" : " to assert that a list contains multiple entries of interest",
          "type" : "SimpleText"
        } ]
      }, {
        "meta" : {
          "rightSide" : true
        },
        "type" : "EmptyBlock"
      }, {
        "title" : "response",
        "pathsFile" : "doc-artifacts/end-point-object-contain-all-table-matchers/paths.json",
        "data" : [ {
          "id" : "id1",
          "k1" : "v11",
          "k2" : "v12"
        }, {
          "id" : "id2",
          "k1" : "v21",
          "k2" : "v22"
        }, {
          "id" : "id3",
          "k1" : "v31",
          "k2" : "v32"
        }, {
          "id" : "id4",
          "k1" : "v41",
          "k2" : "v42"
        } ],
        "paths" : [ "root[0].id", "root[0].k1", "root[0].k2", "root[2].id", "root[2].k1", "root[2].k2" ],
        "anchorId" : "contain-table-response",
        "type" : "Json"
      }, {
        "meta" : {
          "rightSide" : true
        },
        "tabsContent" : [ {
          "name" : "Groovy",
          "content" : [ {
            "lang" : "groovy",
            "snippet" : "http.get(\"/end-point-large-list\") {\n    body.should contain([\"id\" | \"k1\"  | \"k2\"] {\n                        ________________________\n                         \"id1\" | \"v11\" | \"v12\"\n                         \"id3\" | \"v31\" | \"v32\" })\n}",
            "entry" : "contain table matcher",
            "bodyOnly" : true,
            "type" : "Snippet"
          } ]
        }, {
          "name" : "Java",
          "content" : [ {
            "lang" : "java",
            "snippet" : "http.get(\"/end-point-large-list\", (header, body) -> {\n    body.should(contain(table(\"id\", \"k1\" , \"k2\",\n                              ______________________,\n                              \"id1\", \"v11\", \"v12\",\n                              \"id3\", \"v31\", \"v32\" )));\n});",
            "entry" : "containTableMatcher",
            "bodyOnly" : true,
            "excludeRegexp" : "doc.capture",
            "type" : "Snippet"
          } ]
        } ],
        "type" : "Tabs"
      } ]
    }, {
      "id" : "contain-all",
      "title" : "Contain All",
      "type" : "Section",
      "content" : [ {
        "type" : "Paragraph",
        "content" : [ {
          "text" : "Use ",
          "type" : "SimpleText"
        }, {
          "code" : "containAll",
          "type" : "InlinedCode"
        }, {
          "text" : " when you cannot rely on order of values in a response and need to check more than one value.",
          "type" : "SimpleText"
        } ]
      }, {
        "meta" : {
          "rightSide" : true
        },
        "type" : "EmptyBlock"
      }, {
        "title" : "response",
        "pathsFile" : "doc-artifacts/end-point-list-contain-all-matchers/paths.json",
        "data" : [ {
          "id" : "id1",
          "k1" : "v1",
          "k2" : "v2"
        }, {
          "id" : "id2",
          "k1" : "v11",
          "k2" : [ 10, 20, 30 ]
        } ],
        "paths" : [ "root[1].k2[0]", "root[1].k2[1]", "root[1].k2[2]" ],
        "anchorId" : "contain-all-response",
        "type" : "Json"
      }, {
        "meta" : {
          "rightSide" : true
        },
        "tabsContent" : [ {
          "name" : "Groovy",
          "content" : [ {
            "lang" : "groovy",
            "snippet" : "http.get(\"/end-point-list\") {\n    body[1].k2.should containAll(10, 30)\n    body[1].k2.shouldNot containAll(40, 60, 80)\n}",
            "entry" : "contain all matcher",
            "bodyOnly" : true,
            "excludeRegexp" : "doc.capture",
            "type" : "Snippet"
          } ]
        }, {
          "name" : "Java",
          "content" : [ {
            "lang" : "java",
            "snippet" : "http.get(\"/end-point-list\", (header, body) -> {\n    body.get(1).get(\"k2\").should(containAll(10, 30));\n    body.get(1).get(\"k2\").shouldNot(containAll(40, 60, 80));\n});",
            "entry" : "containAllMatcher",
            "bodyOnly" : true,
            "excludeRegexp" : "doc.capture",
            "type" : "Snippet"
          } ]
        } ],
        "type" : "Tabs"
      } ]
    }, {
      "id" : "nested-contain-all",
      "title" : "Nested Contain All",
      "type" : "Section",
      "content" : [ {
        "type" : "Paragraph",
        "content" : [ {
          "text" : "Use ",
          "type" : "SimpleText"
        }, {
          "code" : "containingAll",
          "type" : "InlinedCode"
        }, {
          "text" : " alias to make it easier to read ",
          "type" : "SimpleText"
        }, {
          "code" : "containAll",
          "type" : "InlinedCode"
        }, {
          "text" : " matcher nested inside ",
          "type" : "SimpleText"
        }, {
          "code" : "contain",
          "type" : "InlinedCode"
        }, {
          "text" : ".",
          "type" : "SimpleText"
        } ]
      }, {
        "meta" : {
          "rightSide" : true
        },
        "type" : "EmptyBlock"
      }, {
        "title" : "response",
        "pathsFile" : "doc-artifacts/prices-contain-containing-all/paths.json",
        "data" : [ {
          "id" : "game1",
          "prices" : [ 15, 30, 40, 60 ]
        }, {
          "id" : "game2",
          "prices" : [ 10, 30 ]
        } ],
        "paths" : [ ],
        "anchorId" : "nested-contain-all-response",
        "type" : "Json"
      }, {
        "meta" : {
          "rightSide" : true
        },
        "tabsContent" : [ {
          "name" : "Groovy",
          "content" : [ {
            "lang" : "groovy",
            "snippet" : "http.get(\"/prices\") {\n    body.prices.should contain(containingAll(10, 30))\n}",
            "entry" : "contain containing all matcher",
            "bodyOnly" : true,
            "excludeRegexp" : "doc.capture",
            "type" : "Snippet"
          } ]
        }, {
          "name" : "Java",
          "content" : [ {
            "lang" : "java",
            "snippet" : "http.get(\"/prices\", (header, body) -> {\n    body.get(\"prices\").should(contain(containingAll(10, 30)));\n});",
            "entry" : "containContainingAllMatcher",
            "bodyOnly" : true,
            "excludeRegexp" : "doc.capture",
            "type" : "Snippet"
          } ]
        } ],
        "type" : "Tabs"
      } ]
    }, {
      "id" : "date-and-time",
      "title" : "Date and Time",
      "type" : "Section",
      "content" : [ {
        "type" : "Paragraph",
        "content" : [ {
          "text" : "You can assert ",
          "type" : "SimpleText"
        }, {
          "code" : "actual",
          "type" : "InlinedCode"
        }, {
          "text" : " string against ",
          "type" : "SimpleText"
        }, {
          "code" : "LocalDate",
          "type" : "InlinedCode"
        }, {
          "text" : " and ",
          "type" : "SimpleText"
        }, {
          "code" : "ZonedDateTime",
          "type" : "InlinedCode"
        }, {
          "text" : ". String will be automatically converted",
          "type" : "SimpleText"
        }, {
          "type" : "SoftLineBreak"
        }, {
          "text" : "using ISO formatter.",
          "type" : "SimpleText"
        } ]
      }, {
        "meta" : {
          "rightSide" : true
        },
        "type" : "EmptyBlock"
      }, {
        "title" : "response",
        "pathsFile" : "doc-artifacts/end-point-dates-matchers/paths.json",
        "data" : {
          "id" : 54,
          "tradeDate" : "2018-06-12",
          "transactionTime" : "2018-06-12T10:00:00+01:00:00",
          "paymentSchedule" : [ "2018-06-12", "2018-07-10", "2018-08-09", "2018-09-12" ]
        },
        "paths" : [ "root.paymentSchedule[0]", "root.tradeDate", "root.transactionTime" ],
        "anchorId" : "date-and-time-response",
        "type" : "Json"
      }, {
        "meta" : {
          "rightSide" : true
        },
        "tabsContent" : [ {
          "name" : "Groovy",
          "content" : [ {
            "lang" : "groovy",
            "snippet" : "http.get(\"/end-point-dates\") {\n    def expectedDate = LocalDate.of(2018, 6, 12)\n    def expectedTime = ZonedDateTime.of(expectedDate,\n        LocalTime.of(9, 0, 0),\n        ZoneId.of(\"UTC\"))\n\n    tradeDate.should == expectedDate\n    transactionTime.should == expectedTime\n    transactionTime.shouldBe >= expectedDate\n\n    paymentSchedule.should contain(expectedDate)\n}",
            "entry" : "working with dates",
            "bodyOnly" : true,
            "excludeRegexp" : "doc.capture",
            "type" : "Snippet"
          } ]
        }, {
          "name" : "Java",
          "content" : [ {
            "lang" : "java",
            "snippet" : "http.get(\"/end-point-dates\", (header, body) -> {\n    LocalDate expectedDate = LocalDate.of(2018, 6, 12);\n    ZonedDateTime expectedTime = ZonedDateTime.of(expectedDate,\n            LocalTime.of(9, 0, 0),\n            ZoneId.of(\"UTC\"));\n\n    body.get(\"tradeDate\").should(equal(expectedDate));\n    body.get(\"transactionTime\").should(equal(expectedTime));\n    body.get(\"transactionTime\").shouldBe(greaterThanOrEqual(expectedDate));\n\n    body.get(\"paymentSchedule\").should(contain(expectedDate));\n});",
            "entry" : "workingWithDates",
            "bodyOnly" : true,
            "excludeRegexp" : "doc.capture",
            "type" : "Snippet"
          } ]
        } ],
        "type" : "Tabs"
      } ]
    }, {
      "id" : "mixing-matchers",
      "title" : "Mixing Matchers",
      "type" : "Section",
      "content" : [ {
        "type" : "Paragraph",
        "content" : [ {
          "text" : "You can use matchers in place of expected values to build a more complex expectation.",
          "type" : "SimpleText"
        } ]
      }, {
        "meta" : {
          "rightSide" : true
        },
        "type" : "EmptyBlock"
      }, {
        "title" : "response",
        "pathsFile" : "doc-artifacts/end-point-mixing-matchers/paths.json",
        "data" : {
          "list" : [ 1, 2, 3 ],
          "object" : {
            "k1" : "v1",
            "k2" : "v2",
            "k3" : "v3"
          },
          "complexList" : [ {
            "id" : "id1",
            "k1" : "v1",
            "k2" : 100
          }, {
            "id" : "id2",
            "k1" : "v11",
            "k2" : 200
          } ]
        },
        "paths" : [ "root.complexList[0].k1", "root.complexList[0].k2", "root.complexList[1].k1", "root.complexList[1].k2", "root.list[0]", "root.list[1]", "root.object.k1", "root.object.k3" ],
        "anchorId" : "mixing-matchers-response",
        "type" : "Json"
      }, {
        "meta" : {
          "rightSide" : true
        },
        "tabsContent" : [ {
          "name" : "Groovy",
          "content" : [ {
            "lang" : "groovy",
            "snippet" : "http.get(\"/end-point-mixed\") {\n    list.should contain(lessThanOrEqual(2)) // lessThanOrEqual will be matched against each value\n\n    object.should == [k1: \"v1\", k3: ~/v\\d/] // regular expression match against k3\n\n    complexList[0].should == [k1: \"v1\", k2: lessThan(120)] // lessThen match against k2\n\n    complexList[1].should == [\n        k1: notEqual(\"v1\"), // any value but v1\n        k2: greaterThanOrEqual(120)]\n\n    complexList.should == [\"k1\"   | \"k2\"] {\n                          ___________________________\n                           ~/v\\d/ | lessThan(120)\n                            \"v11\" | greaterThan(150) } // using matchers as cell values\n}",
            "entry" : "matchers combo",
            "bodyOnly" : true,
            "commentsType" : "inline",
            "excludeRegexp" : "doc.capture",
            "type" : "Snippet"
          } ]
        }, {
          "name" : "Java",
          "content" : [ {
            "lang" : "java",
            "snippet" : "Pattern withNumber = Pattern.compile(\"v\\\\d\");\n\nhttp.get(\"/end-point-mixed\", (header, body) -> {\n    body.get(\"list\").should(contain(lessThanOrEqual(2))); // lessThanOrEqual will be matched against each value\n\n    body.get(\"object\").should(equal(map(\n            \"k1\", \"v1\",\n            \"k3\", withNumber))); // regular expression match against k3\n\n    body.get(\"complexList\").get(0).should(equal(map(\n            \"k1\", \"v1\",\n            \"k2\", lessThan(120)))); // lessThen match against k2\n\n    body.get(\"complexList\").get(1).should(equal(map(\n            \"k1\", notEqual(\"v1\"), // any value but v1\n            \"k2\", greaterThanOrEqual(120))));\n\n    TableData expected = table(\"k1\"        , \"k2\", // matching only specified fields, but number of entries must be exact\n                               ________________________________,\n                                withNumber , lessThan(120),\n                                \"v11\"      , greaterThan(150));\n\n    body.get(\"complexList\").should(equal(expected));\n});",
            "entry" : "matchersCombo",
            "bodyOnly" : true,
            "commentsType" : "inline",
            "excludeRegexp" : "doc.capture",
            "type" : "Snippet"
          } ]
        } ],
        "type" : "Tabs"
      } ]
    } ],
    "lastModifiedTime" : 1692271721150,
    "tocItem" : {
      "chapterTitle" : "HTTP",
      "pageTitle" : "Matchers",
      "pageMeta" : {
        "type" : [ "two-sides" ]
      },
      "dirName" : "HTTP",
      "fileName" : "matchers",
      "viewOnRelativePath" : null,
      "pageSectionIdTitles" : [ {
        "title" : "Response Mapping",
        "id" : "response-mapping"
      }, {
        "title" : "Should and Should Not",
        "id" : "should-and-should-not"
      }, {
        "title" : "Equality",
        "id" : "equality"
      }, {
        "title" : "Greater/Less/Equal",
        "id" : "greater-less-equal"
      }, {
        "title" : "Contain",
        "id" : "contain"
      }, {
        "title" : "Contain Table",
        "id" : "contain-table"
      }, {
        "title" : "Contain All",
        "id" : "contain-all"
      }, {
        "title" : "Nested Contain All",
        "id" : "nested-contain-all"
      }, {
        "title" : "Date and Time",
        "id" : "date-and-time"
      }, {
        "title" : "Mixing Matchers",
        "id" : "mixing-matchers"
      } ]
    }
  }
}), document.getElementById("znai"));
/*-->*/

</script>

</body>
</html>
