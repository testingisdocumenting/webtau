<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8" /> 
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover"> 
<title>WebTau: Headers</title>
<link rel="stylesheet" type="text/css" href="/webtau/static/css/katex.min.css">
<link rel="stylesheet" type="text/css" href="/webtau/static/main.css">
<link rel="stylesheet" type="text/css" href="/webtau/logo.css">
<link rel="stylesheet" type="text/css" href="/webtau/static/css/global-overrides.css">
</head>
<link rel="shortcut icon" href="/webtau/favicon.png"type="image/ico"/>
<body class="theme-znai-dark">
<script>(function() {
    var themeNameKey = 'znaiTheme';
    var darkThemeName = 'znai-dark';
    var lightThemeName = 'default';

    var znaiTheme = {
        changeHandlers: [],
        addChangeHandler(handler) {
            this.changeHandlers.push(handler);
        },
        removeChangeHandler(handler) {
            var idx = this.changeHandlers.indexOf(handler);
            this.changeHandlers.splice(idx, 1);
        },
        set(name) {
            this.name = name;
            document.body.className = 'theme-' + name;

            var idx = 0;
            var len = this.changeHandlers.length;
            for (; idx < len; idx++) {
                this.changeHandlers[idx](name);
            }
        },
        setExplicitly(name) {
            storeThemeName(name);
            this.set(name);
        },
        setExplicitlyIfNotSetAlready(name) {
            const themeName = getStoredThemeName();
            if (themeName) {
                return
            }

            this.setExplicitly(name)
        },
        toggle() {
            this.setExplicitly(this.name === lightThemeName ? darkThemeName : lightThemeName)
        }
    };

    var mediaThemeName = setLightMatchMediaListenerAndGetThemeName()
    var themeName = getStoredThemeName() || mediaThemeName;
    znaiTheme.set(themeName);

    window.znaiTheme = znaiTheme;

    function getStoredThemeName() {
        return localStorage.getItem(themeNameKey);
    }

    function storeThemeName(name) {
        return localStorage.setItem(themeNameKey, name);
    }

    function setLightMatchMediaListenerAndGetThemeName() {
        if (!window.matchMedia) {
            return darkThemeName;
        }

        var lightQuery = window.matchMedia('(prefers-color-scheme: light)');
        lightQuery.addListener(function (e) {
            const newThemeName = e.matches ? lightThemeName : darkThemeName;
            znaiTheme.setExplicitly(newThemeName);
        });

        return lightQuery.matches ? lightThemeName : darkThemeName;
    }
})()</script>
<div id="znai"><div id="znai-initial-page-loading" style="margin: -20px 0 0 -20px; padding: 0 40px 40px 0; width: 100vw; height: 100vh; display: flex; justify-content: center; align-items: center">
    <div></div>
</div><section style="max-width: 640px; margin-left: auto; margin-right: auto;">
<article>
<header><h1>Standard Header</h1></header>
<p>Standard headers like Content-Type and Accept are set on your behalf. When payload content is present then values are based on the content type you are sending. When no payload is present, it defaults to application/json .</p>
</article>

<article>
<header><h1>Implicit Header</h1></header>
<p>If each http request requires the same header you can specify that header using httpHeaderProvider . Common example is specifying authentication header. package scenarios.rest.headers import scenarios.rest.headers.auth.Auth url = &quot;http://localhost:8080&quot; httpHeaderProvider = Auth.&amp;authHeader Where Auth.&amp;authHeader is implemented as follows: package scenarios.rest.headers.auth import org.testingisdocumenting.webtau.http.HttpHeader class Auth { static HttpHeader authHeader(String fullUrl, String url, HttpHeader original) { def token = step(&quot;generate auth token&quot;) { return &quot;jwt-token&quot; } return original.merge([Authorization: &quot;Bearer $token&quot;]) } } Implicit headers help to clean up tests from implementation details</p>
</article>

<article>
<header><h1>Explicit Header</h1></header>
<p>To explicitly set header pass http.header(values) as an additional parameter. http.get(&quot;/end-point&quot;, http.header('Accept', 'application/octet-stream')) { // assertions go here } http.get(&quot;/end-point&quot;, [queryParam1: 'queryParamValue1'], http.header('Accept', 'application/octet-stream')) { // assertions go here } http.patch(&quot;/end-point&quot;, http.header('Accept', 'application/octet-stream'), [fileId: 'myFile']) { // assertions go here } http.post(&quot;/end-point&quot;, http.header('Accept', 'application/octet-stream'), [fileId: 'myFile']) { // assertions go here } http.put(&quot;/end-point&quot;, http.header('Accept', 'application/octet-stream'), [fileId: 'myFile', file: sampleFile]) { // assertions go here } http.delete(&quot;/end-point&quot;, http.header('Custom-Header', 'special-value')) Additionally http.header accepts values as a map. def varArgHeader = http.header( 'My-Header1', 'Value1', 'My-Header2', 'Value2') def mapBasedHeader = http.header([ 'My-Header1': 'Value1', 'My-Header2': 'Value2']) assert varArgHeader == mapBasedHeader</p>
</article>

<article>
<header><h1>Mime Type Combined With Payload</h1></header>
<p>Use http.body to combine Content-Type and payload. def content = binaryFile('path') http.post(&quot;/end-point&quot;, http.body(&quot;application/octet-stream&quot;, content)) { // assertions go here } If you need a standard type consider using def content = binaryFile('path') http.post(&quot;/end-point&quot;, http.application.octetStream(content)) { // assertions go here } def content = 'text content' http.post(&quot;/end-point&quot;, http.text.plain(content)) { // assertions go here }</p>
</article>

<article>
<header><h1>Response Header</h1></header>
<p>To validate values from response header use header object. http.post(&quot;/end-point&quot;) { header.location.should == 'http://www.example.org/url/23' header['Location'].should == 'http://www.example.org/url/23' header.contentLocation.should == '/url/23' header['Content-Location'].should == '/url/23' header.contentLength.shouldBe &gt; 300 header['Content-Length'].shouldBe &gt; 300 } At the moment only location , contentLocation , contentLength have camelCase shortcuts. All the other header values you need to use ['Header-Name'] syntax.</p>
</article>
</section>
</div>
<script type="text/javascript" src="/webtau/footer.js"></script>
<script type="text/javascript" src="/webtau/toc.js"></script>
<script type="text/javascript" src="/webtau/global-anchors.js"></script>
<script type="text/javascript" src="/webtau/documentation-references.js"></script>
<script type="text/javascript" src="/webtau/assets.js"></script>
<script type="text/javascript" src="/webtau/static/main.js"></script>
<script type="text/javascript" src="/webtau/search-index.js"></script>
<script>
document.getElementById('znai').innerHTML = '';
/*<!--*/
ReactDOM.render(React.createElement(Documentation, {
  "docMeta" : {
    "viewOn" : {
      "link" : "https://github.com/testingisdocumenting/webtau/tree/master/webtau-docs/znai",
      "title" : "View On GitHub"
    },
    "id" : "webtau",
    "title" : "WebTau",
    "type" : "Guide",
    "previewEnabled" : false,
    "allowedGroups" : [ "admin" ]
  },
  "page" : {
    "type" : "Page",
    "content" : [ {
      "id" : "standard-header",
      "type" : "Section",
      "title" : "Standard Header",
      "content" : [ {
        "type" : "Paragraph",
        "content" : [ {
          "text" : "Standard headers like ",
          "type" : "SimpleText"
        }, {
          "code" : "Content-Type",
          "type" : "InlinedCode"
        }, {
          "text" : " and ",
          "type" : "SimpleText"
        }, {
          "code" : "Accept",
          "type" : "InlinedCode"
        }, {
          "text" : " are set on your behalf.",
          "type" : "SimpleText"
        }, {
          "type" : "SoftLineBreak"
        }, {
          "text" : "When payload content is present then values are based on the content type you are sending.",
          "type" : "SimpleText"
        }, {
          "type" : "SoftLineBreak"
        }, {
          "text" : "When no payload is present, it defaults to ",
          "type" : "SimpleText"
        }, {
          "code" : "application/json",
          "type" : "InlinedCode"
        }, {
          "text" : ".",
          "type" : "SimpleText"
        } ]
      } ]
    }, {
      "id" : "implicit-header",
      "type" : "Section",
      "title" : "Implicit Header",
      "content" : [ {
        "type" : "Paragraph",
        "content" : [ {
          "text" : "If each http request requires the same header you can specify that header using ",
          "type" : "SimpleText"
        }, {
          "code" : "httpHeaderProvider",
          "type" : "InlinedCode"
        }, {
          "text" : ".",
          "type" : "SimpleText"
        }, {
          "type" : "SoftLineBreak"
        }, {
          "text" : "Common example is specifying authentication header.",
          "type" : "SimpleText"
        } ]
      }, {
        "snippet" : "package scenarios.rest.headers\n\nimport scenarios.rest.headers.auth.Auth\n\nurl = \"http://localhost:8080\"\n\nhttpHeaderProvider = Auth.&authHeader",
        "type" : "Snippet",
        "title" : "webtau.cfg.groovy",
        "lang" : "groovy"
      }, {
        "type" : "Paragraph",
        "content" : [ {
          "text" : "Where ",
          "type" : "SimpleText"
        }, {
          "code" : "Auth.&authHeader",
          "type" : "InlinedCode"
        }, {
          "text" : " is implemented as follows:",
          "type" : "SimpleText"
        } ]
      }, {
        "snippet" : "package scenarios.rest.headers.auth\n\nimport org.testingisdocumenting.webtau.http.HttpHeader\n\nclass Auth {\n    static HttpHeader authHeader(String fullUrl, String url, HttpHeader original) {\n        def token = step(\"generate auth token\") {\n            return \"jwt-token\"\n        }\n\n        return original.merge([Authorization: \"Bearer $token\"])\n    }\n}",
        "type" : "Snippet",
        "title" : "scenarios/rest/headers/auth/Auth.groovy",
        "lang" : "groovy"
      }, {
        "type" : "Paragraph",
        "content" : [ {
          "text" : "Implicit headers help to clean up tests from implementation details",
          "type" : "SimpleText"
        } ]
      } ]
    }, {
      "id" : "explicit-header",
      "type" : "Section",
      "title" : "Explicit Header",
      "content" : [ {
        "type" : "Paragraph",
        "content" : [ {
          "text" : "To explicitly set header pass ",
          "type" : "SimpleText"
        }, {
          "code" : "http.header(values)",
          "type" : "InlinedCode"
        }, {
          "text" : " as an additional parameter.",
          "type" : "SimpleText"
        } ]
      }, {
        "snippet" : "http.get(\"/end-point\", http.header('Accept', 'application/octet-stream')) {\n    // assertions go here\n}\n\nhttp.get(\"/end-point\", [queryParam1: 'queryParamValue1'],\n        http.header('Accept', 'application/octet-stream')) {\n    // assertions go here\n}\n\nhttp.patch(\"/end-point\", http.header('Accept', 'application/octet-stream'),\n        [fileId: 'myFile']) {\n    // assertions go here\n}\n\nhttp.post(\"/end-point\", http.header('Accept', 'application/octet-stream'),\n        [fileId: 'myFile']) {\n    // assertions go here\n}\n\nhttp.put(\"/end-point\", http.header('Accept', 'application/octet-stream'),\n        [fileId: 'myFile', file: sampleFile]) {\n    // assertions go here\n}\n\nhttp.delete(\"/end-point\", http.header('Custom-Header', 'special-value'))",
        "entry" : "explicit header passing example",
        "bodyOnly" : true,
        "type" : "Snippet",
        "lang" : "groovy"
      }, {
        "type" : "Paragraph",
        "content" : [ {
          "text" : "Additionally ",
          "type" : "SimpleText"
        }, {
          "code" : "http.header",
          "type" : "InlinedCode"
        }, {
          "text" : " accepts values as a map.",
          "type" : "SimpleText"
        } ]
      }, {
        "snippet" : "def varArgHeader = http.header(\n        'My-Header1', 'Value1',\n        'My-Header2', 'Value2')\n\ndef mapBasedHeader = http.header([\n        'My-Header1': 'Value1',\n        'My-Header2': 'Value2'])\n\nassert varArgHeader == mapBasedHeader",
        "entry" : "header creation",
        "bodyOnly" : true,
        "type" : "Snippet",
        "lang" : "groovy"
      } ]
    }, {
      "id" : "mime-type-combined-with-payload",
      "type" : "Section",
      "title" : "Mime Type Combined With Payload",
      "content" : [ {
        "type" : "Paragraph",
        "content" : [ {
          "text" : "Use ",
          "type" : "SimpleText"
        }, {
          "code" : "http.body",
          "type" : "InlinedCode"
        }, {
          "text" : " to combine ",
          "type" : "SimpleText"
        }, {
          "code" : "Content-Type",
          "type" : "InlinedCode"
        }, {
          "text" : " and payload.",
          "type" : "SimpleText"
        } ]
      }, {
        "snippet" : "def content = binaryFile('path')\nhttp.post(\"/end-point\", http.body(\"application/octet-stream\", content)) {\n    // assertions go here\n}",
        "entry" : "explicit binary mime types combined with request body",
        "bodyOnly" : true,
        "type" : "Snippet",
        "title" : "Combined type and payload",
        "lang" : "groovy"
      }, {
        "type" : "Paragraph",
        "content" : [ {
          "text" : "If you need a standard type consider using",
          "type" : "SimpleText"
        } ]
      }, {
        "snippet" : "def content = binaryFile('path')\nhttp.post(\"/end-point\", http.application.octetStream(content)) {\n    // assertions go here\n}",
        "entry" : "post implicit binary mime types combined with request body",
        "bodyOnly" : true,
        "type" : "Snippet",
        "title" : "Binary content shortuct",
        "lang" : "groovy"
      }, {
        "snippet" : "def content = 'text content'\nhttp.post(\"/end-point\", http.text.plain(content)) {\n    // assertions go here\n}",
        "entry" : "implicit text mime types combined with request body",
        "bodyOnly" : true,
        "type" : "Snippet",
        "title" : "Text content shortcut",
        "lang" : "groovy"
      } ]
    }, {
      "id" : "response-header",
      "type" : "Section",
      "title" : "Response Header",
      "content" : [ {
        "type" : "Paragraph",
        "content" : [ {
          "text" : "To validate values from response header use ",
          "type" : "SimpleText"
        }, {
          "code" : "header",
          "type" : "InlinedCode"
        }, {
          "text" : " object.",
          "type" : "SimpleText"
        } ]
      }, {
        "snippet" : "http.post(\"/end-point\") {\n    header.location.should == 'http://www.example.org/url/23'\n    header['Location'].should == 'http://www.example.org/url/23'\n\n    header.contentLocation.should == '/url/23'\n    header['Content-Location'].should == '/url/23'\n\n    header.contentLength.shouldBe > 300\n    header['Content-Length'].shouldBe > 300\n}",
        "entry" : "header assertion with shortcut",
        "bodyOnly" : true,
        "type" : "Snippet",
        "lang" : "groovy"
      }, {
        "type" : "Paragraph",
        "content" : [ {
          "text" : "At the moment only ",
          "type" : "SimpleText"
        }, {
          "code" : "location",
          "type" : "InlinedCode"
        }, {
          "text" : ", ",
          "type" : "SimpleText"
        }, {
          "code" : "contentLocation",
          "type" : "InlinedCode"
        }, {
          "text" : ", ",
          "type" : "SimpleText"
        }, {
          "code" : "contentLength",
          "type" : "InlinedCode"
        }, {
          "text" : " have camelCase shortcuts.",
          "type" : "SimpleText"
        }, {
          "type" : "SoftLineBreak"
        }, {
          "text" : "All the other header values you need to use ",
          "type" : "SimpleText"
        }, {
          "code" : "['Header-Name']",
          "type" : "InlinedCode"
        }, {
          "text" : " syntax.",
          "type" : "SimpleText"
        } ]
      } ]
    } ],
    "lastModifiedTime" : 1640975823034,
    "tocItem" : {
      "sectionTitle" : "HTTP",
      "pageTitle" : "Headers",
      "pageMeta" : { },
      "dirName" : "HTTP",
      "fileName" : "headers",
      "viewOnRelativePath" : null,
      "pageSectionIdTitles" : [ {
        "title" : "Standard Header",
        "id" : "standard-header"
      }, {
        "title" : "Implicit Header",
        "id" : "implicit-header"
      }, {
        "title" : "Explicit Header",
        "id" : "explicit-header"
      }, {
        "title" : "Mime Type Combined With Payload",
        "id" : "mime-type-combined-with-payload"
      }, {
        "title" : "Response Header",
        "id" : "response-header"
      } ]
    }
  }
}), document.getElementById("znai"));
/*-->*/

</script>

</body>
</html>
