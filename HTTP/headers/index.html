<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8" /> 
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover"> 
<title>WebTau: Headers</title>
<link rel="stylesheet" type="text/css" href="/webtau/static/css/katex.min.css">
<link rel="stylesheet" type="text/css" href="/webtau/static/main.css">
<link rel="stylesheet" type="text/css" href="/webtau/logo.css">
<link rel="stylesheet" type="text/css" href="/webtau/static/css/global-overrides.css">
</head>
<link rel="shortcut icon" href="/webtau/favicon.png"type="image/ico"/>
<body class="theme-znai-dark">
<script>(function() {
    var themeNameKey = 'znaiTheme';
    var darkThemeName = 'znai-dark';
    var lightThemeName = 'default';

    var znaiTheme = {
        changeHandlers: [],
        addChangeHandler(handler) {
            this.changeHandlers.push(handler);
        },
        removeChangeHandler(handler) {
            var idx = this.changeHandlers.indexOf(handler);
            this.changeHandlers.splice(idx, 1);
        },
        set(name) {
            this.name = name;
            document.body.className = 'theme-' + name;

            var idx = 0;
            var len = this.changeHandlers.length;
            for (; idx < len; idx++) {
                this.changeHandlers[idx](name);
            }
        },
        setExplicitly(name) {
            storeThemeName(name);
            this.set(name);
        },
        setExplicitlyIfNotSetAlready(name) {
            const themeName = getStoredThemeName();
            if (themeName) {
                return
            }

            this.setExplicitly(name)
        },
        toggle() {
            this.setExplicitly(this.name === lightThemeName ? darkThemeName : lightThemeName)
        }
    };

    var mediaThemeName = setLightMatchMediaListenerAndGetThemeName()
    var themeName = getStoredThemeName() || mediaThemeName;
    znaiTheme.set(themeName);

    window.znaiTheme = znaiTheme;

    function getStoredThemeName() {
        return localStorage.getItem(themeNameKey);
    }

    function storeThemeName(name) {
        return localStorage.setItem(themeNameKey, name);
    }

    function setLightMatchMediaListenerAndGetThemeName() {
        if (!window.matchMedia) {
            return darkThemeName;
        }

        var lightQuery = window.matchMedia('(prefers-color-scheme: light)');
        lightQuery.addListener(function (e) {
            const newThemeName = e.matches ? lightThemeName : darkThemeName;
            znaiTheme.setExplicitly(newThemeName);
        });

        return lightQuery.matches ? lightThemeName : darkThemeName;
    }
})()</script>
<div id="znai"><div id="znai-initial-page-loading" style="margin: -20px 0 0 -20px; padding: 0 40px 40px 0; width: 100vw; height: 100vh; display: flex; justify-content: center; align-items: center">
    <div></div>
</div><section style="max-width: 640px; margin-left: auto; margin-right: auto;">
<article>
<header><h1>Standard Header</h1></header>
<p>Standard headers like Content-Type and Accept are set on your behalf. When payload content is present then values are based on the content type you are sending. When no payload is present, it defaults to application/json .</p>
</article>

<article>
<header><h1>Implicit Header</h1></header>
<p>Webtau has a way to provide headers for each call implicitly. Use it to provide things like authentication, version, etc. header values.Implicit headers goal is to reduce expose to implementation details and make tests more robust. Groovy package scenarios.rest.headers import scenarios.rest.headers.auth.Auth url = &quot;http://localhost:8080&quot; httpHeaderProvider = Auth.&amp;authHeader Where Auth.&amp;authHeader is implemented as follows: package scenarios.rest.headers.auth import org.testingisdocumenting.webtau.http.HttpHeader class Auth { static HttpHeader authHeader(String fullUrl, String url, HttpHeader original) { def token = generateToken() return original.merge([Authorization: &quot;Bearer $token&quot;]) } private static String generateToken() { return &quot;jwt-token&quot; } } Java In case of JUnit like runners, webtau uses https://docs.oracle.com/javase/8/docs/api/java/util/ServiceLoader.html Service Loaders to locate header providers com.example.tests.junit5.config.HttpAuthHeaderProvider package com.example.tests.junit5.config; import org.testingisdocumenting.webtau.http.HttpHeader; import org.testingisdocumenting.webtau.http.config.WebTauHttpConfiguration; import static org.testingisdocumenting.webtau.WebTauDsl.*; public class HttpAuthHeaderProvider implements WebTauHttpConfiguration { @Override public HttpHeader fullHeader(String fullUrl, String passedUrl, HttpHeader given) { String token = generateToken(); return given.with(&quot;Authorization&quot;, &quot;Bearer &quot; + token); } private String generateToken() { return &quot;jwt-token&quot;; } } Note: Read persona/HTTP-persona Persona Auth to learn about ways to streamline authentication</p>
</article>

<article>
<header><h1>Explicit Header</h1></header>
<p>To explicitly set header pass http.header(values) as an additional parameter. Groovy http.get(&quot;/end-point&quot;, http.header(&quot;Accept&quot;, &quot;application/octet-stream&quot;)) { // assertions go here } http.get(&quot;/end-point&quot;, [queryParam1: &quot;queryParamValue1&quot;], http.header(&quot;Accept&quot;, &quot;application/octet-stream&quot;)) { // assertions go here } http.patch(&quot;/end-point&quot;, http.header(&quot;Accept&quot;, &quot;application/octet-stream&quot;), [fileId: &quot;myFile&quot;]) { // assertions go here } http.post(&quot;/end-point&quot;, http.header(&quot;Accept&quot;, &quot;application/octet-stream&quot;), [fileId: &quot;myFile&quot;]) { // assertions go here } http.put(&quot;/end-point&quot;, http.header(&quot;Accept&quot;, &quot;application/octet-stream&quot;), [fileId: &quot;myFile&quot;, file: sampleFile]) { // assertions go here } http.delete(&quot;/end-point&quot;, http.header(&quot;Custom-Header&quot;, &quot;special-value&quot;)) Java http.get(&quot;/end-point&quot;, http.header(&quot;Accept&quot;, &quot;application/octet-stream&quot;), (header, body) -&gt; { // assertions go here }); http.get(&quot;/end-point&quot;, http.query(&quot;queryParam1&quot;, &quot;queryParamValue1&quot;), http.header(&quot;Accept&quot;, &quot;application/octet-stream&quot;), (header, body) -&gt; { // assertions go here }); http.patch(&quot;/end-point&quot;, http.header(&quot;Accept&quot;, &quot;application/octet-stream&quot;), aMapOf(&quot;fileId&quot;, &quot;myFile&quot;), (header, body) -&gt; { // assertions go here }); http.post(&quot;/end-point&quot;, http.header(&quot;Accept&quot;, &quot;application/octet-stream&quot;), aMapOf(&quot;fileId&quot;, &quot;myFile&quot;), (header, body) -&gt; { // assertions go here }); http.put(&quot;/end-point&quot;, http.header(&quot;Accept&quot;, &quot;application/octet-stream&quot;), aMapOf(&quot;fileId&quot;, &quot;myFile&quot;, &quot;file&quot;, sampleFile), (header, body) -&gt; { // assertions go here }); http.delete(&quot;/end-point&quot;, http.header(&quot;Custom-Header&quot;, &quot;special-value&quot;)); Additionally http.header accepts values as a map. Groovy def varArgHeader = http.header( &quot;My-Header1&quot;, &quot;Value1&quot;, &quot;My-Header2&quot;, &quot;Value2&quot;) def mapBasedHeader = http.header([ &quot;My-Header1&quot;: &quot;Value1&quot;, &quot;My-Header2&quot;: &quot;Value2&quot;]) Java HttpHeader varArgHeader = http.header( &quot;My-Header1&quot;, &quot;Value1&quot;, &quot;My-Header2&quot;, &quot;Value2&quot;); Map&lt;CharSequence, CharSequence&gt; headerValues = new HashMap&lt;&gt;(); headerValues.put(&quot;My-Header1&quot;, &quot;Value1&quot;); headerValues.put(&quot;My-Header2&quot;, &quot;Value2&quot;); HttpHeader mapBasedHeader = http.header(headerValues); Use .with to create a new instance of a header based on the existing one plus additional values Groovy def newHeaderVarArg = header.with( &quot;Additional-1&quot;, &quot;AdditionalValue1&quot;, &quot;Additional-2&quot;, &quot;AdditionalValue2&quot;) def newHeaderMap = header.with([ &quot;Additional-1&quot;: &quot;AdditionalValue1&quot;, &quot;Additional-2&quot;: &quot;AdditionalValue2&quot;]) Java HttpHeader newHeaderVarArg = header.with( &quot;Additional-1&quot;, &quot;AdditionalValue1&quot;, &quot;Additional-2&quot;, &quot;AdditionalValue2&quot;); Map&lt;CharSequence, CharSequence&gt; additionalValues = new HashMap&lt;&gt;(); additionalValues.put(&quot;Additional-1&quot;, &quot;AdditionalValue1&quot;); additionalValues.put(&quot;Additional-2&quot;, &quot;AdditionalValue2&quot;); HttpHeader newHeaderMap = header.with(additionalValues);</p>
</article>

<article>
<header><h1>Mime Type Combined With Payload</h1></header>
<p>Use http.body to combine Content-Type and payload. def content = binaryFile('path') http.post(&quot;/end-point&quot;, http.body(&quot;application/octet-stream&quot;, content)) { // assertions go here } If you need a standard type consider using def content = binaryFile('path') http.post(&quot;/end-point&quot;, http.application.octetStream(content)) { // assertions go here } def content = 'text content' http.post(&quot;/end-point&quot;, http.text.plain(content)) { // assertions go here }</p>
</article>

<article>
<header><h1>Response Header</h1></header>
<p>To validate values from response header use header object. http.post(&quot;/end-point&quot;) { header.location.should == 'http://www.example.org/url/23' header['Location'].should == 'http://www.example.org/url/23' header.contentLocation.should == '/url/23' header['Content-Location'].should == '/url/23' header.contentLength.shouldBe &gt; 300 header['Content-Length'].shouldBe &gt; 300 } At the moment only location , contentLocation , contentLength have camelCase shortcuts. All the other header values you need to use ['Header-Name'] syntax.</p>
</article>
</section>
</div>
<script type="text/javascript" src="/webtau/footer.js"></script>
<script type="text/javascript" src="/webtau/toc.js"></script>
<script type="text/javascript" src="/webtau/global-anchors.js"></script>
<script type="text/javascript" src="/webtau/documentation-references.js"></script>
<script type="text/javascript" src="/webtau/assets.js"></script>
<script type="text/javascript" src="/webtau/static/main.js"></script>
<script type="text/javascript" src="/webtau/search-index.js"></script>
<script>
document.getElementById('znai').innerHTML = '';
/*<!--*/
ReactDOM.render(React.createElement(Documentation, {
  "docMeta" : {
    "viewOn" : {
      "link" : "https://github.com/testingisdocumenting/webtau/tree/master/webtau-docs/znai",
      "title" : "View On GitHub"
    },
    "id" : "webtau",
    "title" : "WebTau",
    "type" : "Guide",
    "previewEnabled" : false,
    "allowedGroups" : [ "admin" ]
  },
  "page" : {
    "type" : "Page",
    "content" : [ {
      "id" : "standard-header",
      "type" : "Section",
      "title" : "Standard Header",
      "content" : [ {
        "type" : "Paragraph",
        "content" : [ {
          "text" : "Standard headers like ",
          "type" : "SimpleText"
        }, {
          "code" : "Content-Type",
          "type" : "InlinedCode"
        }, {
          "text" : " and ",
          "type" : "SimpleText"
        }, {
          "code" : "Accept",
          "type" : "InlinedCode"
        }, {
          "text" : " are set on your behalf.",
          "type" : "SimpleText"
        }, {
          "type" : "SoftLineBreak"
        }, {
          "text" : "When payload content is present then values are based on the content type you are sending.",
          "type" : "SimpleText"
        }, {
          "type" : "SoftLineBreak"
        }, {
          "text" : "When no payload is present, it defaults to ",
          "type" : "SimpleText"
        }, {
          "code" : "application/json",
          "type" : "InlinedCode"
        }, {
          "text" : ".",
          "type" : "SimpleText"
        } ]
      } ]
    }, {
      "id" : "implicit-header",
      "type" : "Section",
      "title" : "Implicit Header",
      "content" : [ {
        "type" : "Paragraph",
        "content" : [ {
          "text" : "Webtau has a way to provide headers for each call implicitly.",
          "type" : "SimpleText"
        }, {
          "type" : "SoftLineBreak"
        }, {
          "text" : "Use it to provide things like authentication, version, etc. header values.",
          "type" : "SimpleText"
        } ]
      }, {
        "type" : "Paragraph",
        "content" : [ {
          "text" : "Implicit headers goal is to reduce expose to implementation details and make tests more robust.",
          "type" : "SimpleText"
        } ]
      }, {
        "tabsContent" : [ {
          "name" : "Groovy",
          "content" : [ {
            "snippet" : "package scenarios.rest.headers\n\nimport scenarios.rest.headers.auth.Auth\n\nurl = \"http://localhost:8080\"\n\nhttpHeaderProvider = Auth.&authHeader",
            "highlight" : [ 6 ],
            "type" : "Snippet",
            "title" : "webtau.cfg.groovy",
            "lang" : "groovy"
          }, {
            "type" : "Paragraph",
            "content" : [ {
              "text" : "Where ",
              "type" : "SimpleText"
            }, {
              "code" : "Auth.&authHeader",
              "type" : "InlinedCode"
            }, {
              "text" : " is implemented as follows:",
              "type" : "SimpleText"
            } ]
          }, {
            "snippet" : "package scenarios.rest.headers.auth\n\nimport org.testingisdocumenting.webtau.http.HttpHeader\n\nclass Auth {\n    static HttpHeader authHeader(String fullUrl, String url, HttpHeader original) {\n        def token = generateToken()\n        return original.merge([Authorization: \"Bearer $token\"])\n    }\n\n    private static String generateToken() {\n        return \"jwt-token\"\n    }\n}",
            "type" : "Snippet",
            "title" : "scenarios/rest/headers/auth/Auth.groovy",
            "lang" : "groovy"
          } ]
        }, {
          "name" : "Java",
          "content" : [ {
            "type" : "Paragraph",
            "content" : [ {
              "text" : "In case of JUnit like runners, webtau uses ",
              "type" : "SimpleText"
            }, {
              "isFile" : false,
              "type" : "Link",
              "content" : [ {
                "text" : "Service Loaders",
                "type" : "SimpleText"
              } ],
              "url" : "https://docs.oracle.com/javase/8/docs/api/java/util/ServiceLoader.html"
            }, {
              "text" : "",
              "type" : "SimpleText"
            }, {
              "type" : "SoftLineBreak"
            }, {
              "text" : "to locate header providers",
              "type" : "SimpleText"
            } ]
          }, {
            "snippet" : "com.example.tests.junit5.config.HttpAuthHeaderProvider",
            "type" : "Snippet",
            "title" : "src/test/resources/META-INF/services/org.testingisdocumenting.webtau.http.config.WebTauHttpConfiguration",
            "autoTitle" : true,
            "lang" : "WebTauHttpConfiguration"
          }, {
            "snippet" : "package com.example.tests.junit5.config;\n\nimport org.testingisdocumenting.webtau.http.HttpHeader;\nimport org.testingisdocumenting.webtau.http.config.WebTauHttpConfiguration;\n\nimport static org.testingisdocumenting.webtau.WebTauDsl.*;\n\npublic class HttpAuthHeaderProvider implements WebTauHttpConfiguration {\n    @Override\n    public HttpHeader fullHeader(String fullUrl, String passedUrl, HttpHeader given) {\n        String token = generateToken();\n        return given.with(\"Authorization\", \"Bearer \" + token);\n    }\n\n    private String generateToken() {\n        return \"jwt-token\";\n    }\n}",
            "type" : "Snippet",
            "title" : "src/test/java/com/example/tests/junit5/config/HttpAuthHeaderProvider.java",
            "autoTitle" : true,
            "lang" : "java"
          } ]
        } ],
        "type" : "Tabs"
      }, {
        "type" : "Paragraph",
        "content" : [ {
          "text" : "Note: Read ",
          "type" : "SimpleText"
        }, {
          "isFile" : false,
          "type" : "Link",
          "content" : [ {
            "text" : "Persona Auth",
            "type" : "SimpleText"
          } ],
          "url" : "/webtau/persona/HTTP-persona"
        }, {
          "text" : " to learn about ways to streamline authentication",
          "type" : "SimpleText"
        } ]
      } ]
    }, {
      "id" : "explicit-header",
      "type" : "Section",
      "title" : "Explicit Header",
      "content" : [ {
        "type" : "Paragraph",
        "content" : [ {
          "text" : "To explicitly set header pass ",
          "type" : "SimpleText"
        }, {
          "code" : "http.header(values)",
          "type" : "InlinedCode"
        }, {
          "text" : " as an additional parameter.",
          "type" : "SimpleText"
        } ]
      }, {
        "tabsContent" : [ {
          "name" : "Groovy",
          "content" : [ {
            "snippet" : "http.get(\"/end-point\", http.header(\"Accept\", \"application/octet-stream\")) {\n    // assertions go here\n}\n\nhttp.get(\"/end-point\", [queryParam1: \"queryParamValue1\"],\n        http.header(\"Accept\", \"application/octet-stream\")) {\n    // assertions go here\n}\n\nhttp.patch(\"/end-point\", http.header(\"Accept\", \"application/octet-stream\"),\n        [fileId: \"myFile\"]) {\n    // assertions go here\n}\n\nhttp.post(\"/end-point\", http.header(\"Accept\", \"application/octet-stream\"),\n        [fileId: \"myFile\"]) {\n    // assertions go here\n}\n\nhttp.put(\"/end-point\", http.header(\"Accept\", \"application/octet-stream\"),\n        [fileId: \"myFile\", file: sampleFile]) {\n    // assertions go here\n}\n\nhttp.delete(\"/end-point\", http.header(\"Custom-Header\", \"special-value\"))",
            "entry" : "explicit header passing example",
            "bodyOnly" : true,
            "type" : "Snippet",
            "lang" : "groovy"
          } ]
        }, {
          "name" : "Java",
          "content" : [ {
            "snippet" : "http.get(\"/end-point\", http.header(\"Accept\", \"application/octet-stream\"), (header, body) -> {\n    // assertions go here\n});\n\nhttp.get(\"/end-point\", http.query(\"queryParam1\", \"queryParamValue1\"),\n    http.header(\"Accept\", \"application/octet-stream\"), (header, body) -> {\n    // assertions go here\n});\n\nhttp.patch(\"/end-point\", http.header(\"Accept\", \"application/octet-stream\"),\n        aMapOf(\"fileId\", \"myFile\"), (header, body) -> {\n    // assertions go here\n});\n\nhttp.post(\"/end-point\", http.header(\"Accept\", \"application/octet-stream\"),\n        aMapOf(\"fileId\", \"myFile\"), (header, body) -> {\n    // assertions go here\n});\n\nhttp.put(\"/end-point\", http.header(\"Accept\", \"application/octet-stream\"),\n        aMapOf(\"fileId\", \"myFile\", \"file\", sampleFile), (header, body) -> {\n    // assertions go here\n});\n\nhttp.delete(\"/end-point\", http.header(\"Custom-Header\", \"special-value\"));",
            "entry" : "explicitHeaderPassingExample",
            "bodyOnly" : true,
            "type" : "Snippet",
            "lang" : "java"
          } ]
        } ],
        "type" : "Tabs"
      }, {
        "type" : "Paragraph",
        "content" : [ {
          "text" : "Additionally ",
          "type" : "SimpleText"
        }, {
          "code" : "http.header",
          "type" : "InlinedCode"
        }, {
          "text" : " accepts values as a map.",
          "type" : "SimpleText"
        } ]
      }, {
        "tabsContent" : [ {
          "name" : "Groovy",
          "content" : [ {
            "snippet" : "def varArgHeader = http.header(\n        \"My-Header1\", \"Value1\",\n        \"My-Header2\", \"Value2\")\n\ndef mapBasedHeader = http.header([\n        \"My-Header1\": \"Value1\",\n        \"My-Header2\": \"Value2\"])",
            "excludeRegexp" : "doc-exclude",
            "entry" : "header creation",
            "bodyOnly" : true,
            "type" : "Snippet",
            "lang" : "groovy"
          } ]
        }, {
          "name" : "Java",
          "content" : [ {
            "snippet" : "HttpHeader varArgHeader = http.header(\n        \"My-Header1\", \"Value1\",\n        \"My-Header2\", \"Value2\");\n\nMap<CharSequence, CharSequence> headerValues = new HashMap<>();\nheaderValues.put(\"My-Header1\", \"Value1\");\nheaderValues.put(\"My-Header2\", \"Value2\");\nHttpHeader mapBasedHeader = http.header(headerValues);",
            "excludeRegexp" : "doc-exclude",
            "entry" : "headerCreation",
            "bodyOnly" : true,
            "type" : "Snippet",
            "lang" : "java"
          } ]
        } ],
        "type" : "Tabs"
      }, {
        "type" : "Paragraph",
        "content" : [ {
          "text" : "Use ",
          "type" : "SimpleText"
        }, {
          "code" : ".with",
          "type" : "InlinedCode"
        }, {
          "text" : " to create a new instance of a header based on the existing one plus additional values",
          "type" : "SimpleText"
        } ]
      }, {
        "tabsContent" : [ {
          "name" : "Groovy",
          "content" : [ {
            "snippet" : "def newHeaderVarArg = header.with(\n        \"Additional-1\", \"AdditionalValue1\",\n        \"Additional-2\", \"AdditionalValue2\")\n\ndef newHeaderMap = header.with([\n        \"Additional-1\": \"AdditionalValue1\",\n        \"Additional-2\": \"AdditionalValue2\"])",
            "entry" : "header with",
            "bodyOnly" : true,
            "surroundedBy" : "// example",
            "type" : "Snippet",
            "lang" : "groovy"
          } ]
        }, {
          "name" : "Java",
          "content" : [ {
            "snippet" : "HttpHeader newHeaderVarArg = header.with(\n        \"Additional-1\", \"AdditionalValue1\",\n        \"Additional-2\", \"AdditionalValue2\");\n\nMap<CharSequence, CharSequence> additionalValues = new HashMap<>();\nadditionalValues.put(\"Additional-1\", \"AdditionalValue1\");\nadditionalValues.put(\"Additional-2\", \"AdditionalValue2\");\nHttpHeader newHeaderMap = header.with(additionalValues);",
            "entry" : "headerWith",
            "bodyOnly" : true,
            "surroundedBy" : "// example",
            "type" : "Snippet",
            "lang" : "java"
          } ]
        } ],
        "type" : "Tabs"
      } ]
    }, {
      "id" : "mime-type-combined-with-payload",
      "type" : "Section",
      "title" : "Mime Type Combined With Payload",
      "content" : [ {
        "type" : "Paragraph",
        "content" : [ {
          "text" : "Use ",
          "type" : "SimpleText"
        }, {
          "code" : "http.body",
          "type" : "InlinedCode"
        }, {
          "text" : " to combine ",
          "type" : "SimpleText"
        }, {
          "code" : "Content-Type",
          "type" : "InlinedCode"
        }, {
          "text" : " and payload.",
          "type" : "SimpleText"
        } ]
      }, {
        "snippet" : "def content = binaryFile('path')\nhttp.post(\"/end-point\", http.body(\"application/octet-stream\", content)) {\n    // assertions go here\n}",
        "entry" : "explicit binary mime types combined with request body",
        "bodyOnly" : true,
        "type" : "Snippet",
        "title" : "Combined type and payload",
        "lang" : "groovy"
      }, {
        "type" : "Paragraph",
        "content" : [ {
          "text" : "If you need a standard type consider using",
          "type" : "SimpleText"
        } ]
      }, {
        "snippet" : "def content = binaryFile('path')\nhttp.post(\"/end-point\", http.application.octetStream(content)) {\n    // assertions go here\n}",
        "entry" : "post implicit binary mime types combined with request body",
        "bodyOnly" : true,
        "type" : "Snippet",
        "title" : "Binary content shortuct",
        "lang" : "groovy"
      }, {
        "snippet" : "def content = 'text content'\nhttp.post(\"/end-point\", http.text.plain(content)) {\n    // assertions go here\n}",
        "entry" : "implicit text mime types combined with request body",
        "bodyOnly" : true,
        "type" : "Snippet",
        "title" : "Text content shortcut",
        "lang" : "groovy"
      } ]
    }, {
      "id" : "response-header",
      "type" : "Section",
      "title" : "Response Header",
      "content" : [ {
        "type" : "Paragraph",
        "content" : [ {
          "text" : "To validate values from response header use ",
          "type" : "SimpleText"
        }, {
          "code" : "header",
          "type" : "InlinedCode"
        }, {
          "text" : " object.",
          "type" : "SimpleText"
        } ]
      }, {
        "snippet" : "http.post(\"/end-point\") {\n    header.location.should == 'http://www.example.org/url/23'\n    header['Location'].should == 'http://www.example.org/url/23'\n\n    header.contentLocation.should == '/url/23'\n    header['Content-Location'].should == '/url/23'\n\n    header.contentLength.shouldBe > 300\n    header['Content-Length'].shouldBe > 300\n}",
        "entry" : "header assertion with shortcut",
        "bodyOnly" : true,
        "type" : "Snippet",
        "lang" : "groovy"
      }, {
        "type" : "Paragraph",
        "content" : [ {
          "text" : "At the moment only ",
          "type" : "SimpleText"
        }, {
          "code" : "location",
          "type" : "InlinedCode"
        }, {
          "text" : ", ",
          "type" : "SimpleText"
        }, {
          "code" : "contentLocation",
          "type" : "InlinedCode"
        }, {
          "text" : ", ",
          "type" : "SimpleText"
        }, {
          "code" : "contentLength",
          "type" : "InlinedCode"
        }, {
          "text" : " have camelCase shortcuts.",
          "type" : "SimpleText"
        }, {
          "type" : "SoftLineBreak"
        }, {
          "text" : "All the other header values you need to use ",
          "type" : "SimpleText"
        }, {
          "code" : "['Header-Name']",
          "type" : "InlinedCode"
        }, {
          "text" : " syntax.",
          "type" : "SimpleText"
        } ]
      } ]
    } ],
    "lastModifiedTime" : 1653577025318,
    "tocItem" : {
      "sectionTitle" : "HTTP",
      "pageTitle" : "Headers",
      "pageMeta" : { },
      "dirName" : "HTTP",
      "fileName" : "headers",
      "viewOnRelativePath" : null,
      "pageSectionIdTitles" : [ {
        "title" : "Standard Header",
        "id" : "standard-header"
      }, {
        "title" : "Implicit Header",
        "id" : "implicit-header"
      }, {
        "title" : "Explicit Header",
        "id" : "explicit-header"
      }, {
        "title" : "Mime Type Combined With Payload",
        "id" : "mime-type-combined-with-payload"
      }, {
        "title" : "Response Header",
        "id" : "response-header"
      } ]
    }
  }
}), document.getElementById("znai"));
/*-->*/

</script>

</body>
</html>
