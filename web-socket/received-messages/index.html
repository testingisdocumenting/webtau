<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8" /> 
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover"> 
<title>WebTau: Received Messages</title>
<link rel="stylesheet" type="text/css" href="/webtau/static/css/katex.min.css">
<link rel="stylesheet" type="text/css" href="/webtau/static/main.css">
<link rel="stylesheet" type="text/css" href="/webtau/logo.css">
<link rel="stylesheet" type="text/css" href="/webtau/static/css/global-overrides.css">
</head>
<link rel="shortcut icon" href="/webtau/favicon.png"type="image/ico"/>
<body class="theme-znai-dark">
<script>(function() {
    var themeNameKey = 'znaiTheme';
    var darkThemeName = 'znai-dark';
    var lightThemeName = 'default';

    var znaiTheme = {
        changeHandlers: [],
        addChangeHandler(handler) {
            this.changeHandlers.push(handler);
        },
        removeChangeHandler(handler) {
            var idx = this.changeHandlers.indexOf(handler);
            this.changeHandlers.splice(idx, 1);
        },
        set(name) {
            this.name = name;
            document.body.className = 'theme-' + name;

            var idx = 0;
            var len = this.changeHandlers.length;
            for (; idx < len; idx++) {
                this.changeHandlers[idx](name);
            }
        },
        setExplicitly(name) {
            storeThemeName(name);
            this.set(name);
        },
        setExplicitlyIfNotSetAlready(name) {
            const themeName = getStoredThemeName();
            if (themeName) {
                return
            }

            this.setExplicitly(name)
        },
        toggle() {
            this.setExplicitly(this.name === lightThemeName ? darkThemeName : lightThemeName)
        }
    };

    var mediaThemeName = setLightMatchMediaListenerAndGetThemeName()
    var themeName = getStoredThemeName() || mediaThemeName;
    znaiTheme.set(themeName);

    window.znaiTheme = znaiTheme;

    function getStoredThemeName() {
        return localStorage.getItem(themeNameKey);
    }

    function storeThemeName(name) {
        return localStorage.setItem(themeNameKey, name);
    }

    function setLightMatchMediaListenerAndGetThemeName() {
        if (!window.matchMedia) {
            return darkThemeName;
        }

        var lightQuery = window.matchMedia('(prefers-color-scheme: light)');
        lightQuery.addListener(function (e) {
            const newThemeName = e.matches ? lightThemeName : darkThemeName;
            znaiTheme.setExplicitly(newThemeName);
        });

        return lightQuery.matches ? lightThemeName : darkThemeName;
    }
})()</script>
<div id="znai"><div id="znai-initial-page-loading" style="margin: -20px 0 0 -20px; padding: 0 40px 40px 0; width: 100vw; height: 100vh; display: flex; justify-content: center; align-items: center">
    <div></div>
</div><section style="max-width: 640px; margin-left: auto; margin-right: auto;">
<article>
<header><h1>Asynchronous To Synchronous</h1></header>
<p>WebSocket messages are asynchronous in nature. To make writing tests easier, WebTau receives and stores all messages behind the scene. Messages are exposed via session.received special value. You can validate, wait on or poll from in a synchronous manner.</p>
</article>

<article>
<header><h1>Wait For A Specific Message</h1></header>
<p>Use and waitTo to make sure a specific message was received. WebTau will comb through and discard all the received messages that do not match a criteria. Messages are processed in receive order. Groovy def wsSession = websocket.connect(&quot;/prices&quot;) wsSession.received.waitTo == [ price: greaterThan(100), symbol: &quot;IBM&quot;] Check web-socket/import-and-dependencies Import And Dependencies for prerequisites. Java var wsSession = websocket.connect(&quot;/prices&quot;); wsSession.received.waitTo(equal(map( &quot;price&quot;, greaterThan(100), &quot;symbol&quot;, &quot;IBM&quot;))); Check web-socket/import-and-dependencies Import And Dependencies for prerequisites. &gt; waiting for received from ws://localhost:45923/prices to equal {&quot;price&quot;: &lt;greater than 100&gt;, &quot;symbol&quot;: &quot;IBM&quot;} &gt; [1/25] polling websocket message {&quot;symbol&quot;: &quot;IBM&quot;, &quot;price&quot;: 77} . [1/25] polled new message (96ms) &gt; [25/25] polling websocket message {&quot;symbol&quot;: &quot;IBM&quot;, &quot;price&quot;: 101} . [25/25] polled new message (0ms) . received from ws://localhost:45923/prices equals {&quot;price&quot;: &lt;greater than 100&gt;, &quot;symbol&quot;: &quot;IBM&quot;} (1s 107ms)</p>
</article>

<article>
<header><h1>Wait For A Specific Message Using Value Path</h1></header>
<p>Use get(path) to narrow to a specific response value Groovy wsSession.received.price.waitToBe &gt; 100 Note: Groovy dynamic nature allows you bypass explicit get Java wsSession.received.get(&quot;price&quot;).waitToBe(greaterThan(100)); &gt; waiting for received.price from ws://localhost:45923/prices to be greater than 100 &gt; [1/25] polling websocket message {&quot;symbol&quot;: &quot;IBM&quot;, &quot;price&quot;: 77} . [1/25] polled new message (3ms) &gt; [25/25] polling websocket message {&quot;symbol&quot;: &quot;IBM&quot;, &quot;price&quot;: 101} . [25/25] polled new message (0ms) . received.price from ws://localhost:45923/prices greater than 100 (1s 7ms) Use [idx] To deal with a list response: Groovy wsSession.received[2].price.waitToBe &gt; 30 Java wsSession.received.get(&quot;[2].price&quot;).waitToBe(greaterThan(30)); &gt; waiting for received[2].price from ws://localhost:45923/prices to be greater than 30 &gt; polling websocket message [{&quot;symbol&quot;: &quot;IBM&quot;, &quot;price&quot;: 20}, {&quot;symbol&quot;: &quot;IBM&quot;, &quot;price&quot;: 30}, {&quot;symbol&quot;: &quot;IBM&quot;, &quot;price&quot;: 33}] . polled new message (2ms) . received[2].price from ws://localhost:45923/prices greater than 30 (2ms)</p>
</article>

<article>
<header><h1>Poll Message As Text</h1></header>
<p>WebTau receives and stores asynchronous messages behind the scene. Use pollAsText to access messages in a synchronous manner. If message is not yet received, pollAsText will wait for a configured ( webSocketPollTimeout ) milliseconds (default 5 seconds). In example above, we wait until the price becomes greater than 100. All the messages including the matched one are discarded after waitTo . returns next received message or wait for the message to come: Groovy def nextMessage = wsSession.received.pollAsText() nextMessage.should == &quot;{\&quot;symbol\&quot;:\&quot;IBM\&quot;,\&quot;price\&quot;:102}&quot; def nextNextMessage = wsSession.received.pollAsText(100) // explicit timeout in milliseconds for new message to arrive nextNextMessage.should == &quot;{\&quot;symbol\&quot;:\&quot;IBM\&quot;,\&quot;price\&quot;:103}&quot; Java String nextMessage = wsSession.received.pollAsText(); actual(nextMessage).should(equal(&quot;{\&quot;symbol\&quot;:\&quot;IBM\&quot;,\&quot;price\&quot;:102}&quot;)); String nextNextMessage = wsSession.received.pollAsText(100); // explicit timeout in milliseconds for new message to arrive actual(nextNextMessage).should(equal(&quot;{\&quot;symbol\&quot;:\&quot;IBM\&quot;,\&quot;price\&quot;:103}&quot;)); Note: if there are no already received messages, and no new message arrives within a wait time, null will be returned.</p>
</article>

<article>
<header><h1>Poll Message As Object</h1></header>
<p>Use to convert JSON message to a list or a map. Groovy def message = wsSession.received.poll() message.symbol.should == &quot;IBM&quot; Java Map&lt;String, ?&gt; message = wsSession.received.poll(); actual(message.get(&quot;symbol&quot;)).should(equal(&quot;IBM&quot;));</p>
</article>

<article>
<header><h1>Max Number Of Messages</h1></header>
<p>By default, WebTau keeps only 1000 messages. If new messages arrive, the old ones get discarded. Use config value to change number of messages to keep.</p>
</article>

<article>
<header><h1>Number Of Received Messages</h1></header>
<p>Use to wait for a certain number of messages: Groovy wsSession.received.count.waitTo == 53 Java wsSession.received.count.waitTo(equal(53)); &gt; waiting for count of messages received from ws://localhost:33409/prices to equal 53 . count of messages received from ws://localhost:33409/prices equals 53 (138ms)</p>
</article>

<article>
<header><h1>Discard Messages</h1></header>
<p>Use to remove all already received messages. Next will wait for a new message to arrive as all the received messages will be discarded. Groovy wsSession.received.discard() def nextMessage = wsSession.received.pollAsText(1) nextMessage.should == null Java wsSession.received.discard(); String nextMessage = wsSession.received.pollAsText(1); actual(nextMessage).should(equal(null)); . discarded all messages received from ws://localhost:33409/prices (0ms) &gt; polling websocket message . no new message is polled (1ms)</p>
</article>
</section>
</div>
<script type="text/javascript" src="/webtau/footer.js"></script>
<script type="text/javascript" src="/webtau/toc.js"></script>
<script type="text/javascript" src="/webtau/documentation-references.js"></script>
<script type="text/javascript" src="/webtau/assets.js"></script>
<script type="text/javascript" src="/webtau/static/main.js"></script>
<script type="text/javascript" src="/webtau/search-index.js"></script>
<script>
document.getElementById('znai').innerHTML = '';
/*<!--*/
ReactDOM.render(React.createElement(Documentation, {
  "docMeta" : {
    "viewOn" : {
      "link" : "https://github.com/testingisdocumenting/webtau/tree/master/webtau-docs/znai",
      "title" : "View Markdown"
    },
    "id" : "webtau",
    "title" : "WebTau",
    "type" : "Guide",
    "previewEnabled" : false,
    "support" : {
      "link" : "https://github.com/testingisdocumenting/webtau/discussions",
      "title" : "GitHub"
    }
  },
  "page" : {
    "type" : "Page",
    "content" : [ {
      "id" : "asynchronous-to-synchronous",
      "title" : "Asynchronous To Synchronous",
      "type" : "Section",
      "content" : [ {
        "type" : "Paragraph",
        "content" : [ {
          "text" : "WebSocket messages are asynchronous in nature. To make writing tests easier, WebTau receives and stores all messages behind the scene. Messages are exposed via ",
          "type" : "SimpleText"
        }, {
          "code" : "session.received",
          "type" : "InlinedCode"
        }, {
          "text" : " special value. You can validate, wait on or poll from in a synchronous manner.",
          "type" : "SimpleText"
        } ]
      } ]
    }, {
      "id" : "wait-for-a-specific-message",
      "title" : "Wait For A Specific Message",
      "type" : "Section",
      "content" : [ {
        "type" : "Paragraph",
        "content" : [ {
          "text" : "Use ",
          "type" : "SimpleText"
        }, {
          "code" : "wsSession.received",
          "type" : "InlinedCode"
        }, {
          "text" : " and ",
          "type" : "SimpleText"
        }, {
          "code" : "waitTo",
          "type" : "InlinedCode"
        }, {
          "text" : " to make sure a specific message was received. WebTau will comb through and discard all the received messages that do not match a criteria.",
          "type" : "SimpleText"
        }, {
          "type" : "SoftLineBreak"
        }, {
          "text" : "Messages are processed in receive order.",
          "type" : "SimpleText"
        } ]
      }, {
        "tabsContent" : [ {
          "name" : "Groovy",
          "content" : [ {
            "lang" : "groovy",
            "snippet" : "def wsSession = websocket.connect(\"/prices\")\n\nwsSession.received.waitTo == [\n        price: greaterThan(100),\n        symbol: \"IBM\"]",
            "title" : "connect, send and wait example",
            "surroundedBy" : "connect-send-wait",
            "exclude" : [ ".send", ".close" ],
            "anchorId" : "wait-for-a-specific-message-connect-send-and-wait-example",
            "type" : "Snippet"
          }, {
            "type" : "Paragraph",
            "content" : [ {
              "text" : "Check ",
              "type" : "SimpleText"
            }, {
              "url" : "/webtau/web-socket/import-and-dependencies",
              "isFile" : false,
              "type" : "Link",
              "content" : [ {
                "text" : "Import And Dependencies",
                "type" : "SimpleText"
              } ]
            }, {
              "text" : " for prerequisites.",
              "type" : "SimpleText"
            } ]
          } ]
        }, {
          "name" : "Java",
          "content" : [ {
            "lang" : "java",
            "snippet" : "var wsSession = websocket.connect(\"/prices\");\n\nwsSession.received.waitTo(equal(map(\n        \"price\", greaterThan(100),\n        \"symbol\", \"IBM\")));",
            "title" : "connect, send and wait example",
            "surroundedBy" : "connect-send-wait",
            "exclude" : [ ".send", ".close" ],
            "anchorId" : "wait-for-a-specific-message-connect-send-and-wait-example-2",
            "type" : "Snippet"
          }, {
            "type" : "Paragraph",
            "content" : [ {
              "text" : "Check ",
              "type" : "SimpleText"
            }, {
              "url" : "/webtau/web-socket/import-and-dependencies",
              "isFile" : false,
              "type" : "Link",
              "content" : [ {
                "text" : "Import And Dependencies",
                "type" : "SimpleText"
              } ]
            }, {
              "text" : " for prerequisites.",
              "type" : "SimpleText"
            } ]
          } ]
        } ],
        "type" : "Tabs"
      }, {
        "title" : "console output",
        "surroundedBy" : "wait until receive message",
        "startLine" : "waiting",
        "endLine" : "received",
        "lines" : [ "\u001B[33m> \u001B[34mwaiting \u001B[33mfor \u001B[0m\u001B[1mreceived \u001B[0m\u001B[33mfrom \u001B[35mws://localhost:45923/prices \u001B[0m\u001B[34mto equal \u001B[33m{\u001B[35m\"price\"\u001B[33m: \u001B[33m<\u001B[36mgreater than \u001B[34m100\u001B[33m>\u001B[33m, \u001B[35m\"symbol\"\u001B[33m: \u001B[32m\"IBM\"\u001B[33m}\u001B[0m", "  \u001B[33m> \u001B[36m[1/25] \u001B[34mpolling \u001B[36mwebsocket message\u001B[0m", "    \u001B[33m{\u001B[35m\"symbol\"\u001B[33m: \u001B[32m\"IBM\"\u001B[33m, \u001B[35m\"price\"\u001B[33m: \u001B[34m77\u001B[33m}\u001B[0m", "  \u001B[32m. \u001B[36m[1/25] \u001B[34mpolled new message\u001B[33m (\u001B[32m96ms\u001B[33m)\u001B[0m", "  \u001B[33m> \u001B[36m[25/25] \u001B[34mpolling \u001B[36mwebsocket message\u001B[0m", "    \u001B[33m{\u001B[35m\"symbol\"\u001B[33m: \u001B[32m\"IBM\"\u001B[33m, \u001B[35m\"price\"\u001B[33m: \u001B[34m101\u001B[33m}\u001B[0m", "  \u001B[32m. \u001B[36m[25/25] \u001B[34mpolled new message\u001B[33m (\u001B[32m0ms\u001B[33m)\u001B[0m", "\u001B[32m. \u001B[0m\u001B[1mreceived \u001B[0m\u001B[33mfrom \u001B[35mws://localhost:45923/prices \u001B[0m\u001B[34mequals \u001B[33m{\u001B[35m\"price\"\u001B[33m: \u001B[33m<\u001B[36mgreater than \u001B[34m100\u001B[33m>\u001B[33m, \u001B[35m\"symbol\"\u001B[33m: \u001B[32m\"IBM\"\u001B[33m}\u001B[33m (\u001B[32m1s 107ms\u001B[33m)\u001B[0m" ],
        "anchorId" : "wait-for-a-specific-message-console-output",
        "type" : "CliOutput"
      } ]
    }, {
      "id" : "wait-for-a-specific-message-using-value-path",
      "title" : "Wait For A Specific Message Using Value Path",
      "type" : "Section",
      "content" : [ {
        "type" : "Paragraph",
        "content" : [ {
          "text" : "Use ",
          "type" : "SimpleText"
        }, {
          "code" : "get(path)",
          "type" : "InlinedCode"
        }, {
          "text" : " to narrow to a specific response value",
          "type" : "SimpleText"
        } ]
      }, {
        "tabsContent" : [ {
          "name" : "Groovy",
          "content" : [ {
            "lang" : "groovy",
            "snippet" : "wsSession.received.price.waitToBe > 100",
            "title" : "wait on specific response value",
            "surroundedBy" : "received-get",
            "anchorId" : "wait-for-a-specific-message-using-value-path-wait-on-specific-response-value",
            "type" : "Snippet"
          }, {
            "type" : "Paragraph",
            "content" : [ {
              "text" : "Note: Groovy dynamic nature allows you bypass explicit ",
              "type" : "SimpleText"
            }, {
              "code" : "get",
              "type" : "InlinedCode"
            } ]
          } ]
        }, {
          "name" : "Java",
          "content" : [ {
            "lang" : "java",
            "snippet" : "wsSession.received.get(\"price\").waitToBe(greaterThan(100));",
            "title" : "wait on specific response value",
            "surroundedBy" : "received-get",
            "anchorId" : "wait-for-a-specific-message-using-value-path-wait-on-specific-response-value-2",
            "type" : "Snippet"
          } ]
        } ],
        "type" : "Tabs"
      }, {
        "title" : "console output",
        "surroundedBy" : "wait until receive message using path",
        "startLine" : "waiting",
        "endLine" : "received",
        "lines" : [ "\u001B[33m> \u001B[34mwaiting \u001B[33mfor \u001B[0m\u001B[1mreceived.price \u001B[0m\u001B[33mfrom \u001B[35mws://localhost:45923/prices \u001B[0m\u001B[34mto be greater than \u001B[34m100\u001B[0m", "  \u001B[33m> \u001B[36m[1/25] \u001B[34mpolling \u001B[36mwebsocket message\u001B[0m", "    \u001B[33m{\u001B[35m\"symbol\"\u001B[33m: \u001B[32m\"IBM\"\u001B[33m, \u001B[35m\"price\"\u001B[33m: \u001B[34m77\u001B[33m}\u001B[0m", "  \u001B[32m. \u001B[36m[1/25] \u001B[34mpolled new message\u001B[33m (\u001B[32m3ms\u001B[33m)\u001B[0m", "  \u001B[33m> \u001B[36m[25/25] \u001B[34mpolling \u001B[36mwebsocket message\u001B[0m", "    \u001B[33m{\u001B[35m\"symbol\"\u001B[33m: \u001B[32m\"IBM\"\u001B[33m, \u001B[35m\"price\"\u001B[33m: \u001B[34m101\u001B[33m}\u001B[0m", "  \u001B[32m. \u001B[36m[25/25] \u001B[34mpolled new message\u001B[33m (\u001B[32m0ms\u001B[33m)\u001B[0m", "\u001B[32m. \u001B[0m\u001B[1mreceived.price \u001B[0m\u001B[33mfrom \u001B[35mws://localhost:45923/prices \u001B[0m\u001B[34mgreater than \u001B[34m100\u001B[33m (\u001B[32m1s 7ms\u001B[33m)\u001B[0m" ],
        "anchorId" : "wait-for-a-specific-message-using-value-path-console-output",
        "type" : "CliOutput"
      }, {
        "type" : "Paragraph",
        "content" : [ {
          "text" : "Use ",
          "type" : "SimpleText"
        }, {
          "code" : "[idx]",
          "type" : "InlinedCode"
        }, {
          "text" : " To deal with a list response:",
          "type" : "SimpleText"
        } ]
      }, {
        "tabsContent" : [ {
          "name" : "Groovy",
          "content" : [ {
            "lang" : "groovy",
            "snippet" : "wsSession.received[2].price.waitToBe > 30",
            "title" : "wait on specific response value within list",
            "surroundedBy" : "received-list",
            "anchorId" : "wait-for-a-specific-message-using-value-path-wait-on-specific-response-value-within-list",
            "type" : "Snippet"
          } ]
        }, {
          "name" : "Java",
          "content" : [ {
            "lang" : "java",
            "snippet" : "wsSession.received.get(\"[2].price\").waitToBe(greaterThan(30));",
            "title" : "wait on specific response value within list",
            "surroundedBy" : "received-list",
            "anchorId" : "wait-for-a-specific-message-using-value-path-wait-on-specific-response-value-within-list-2",
            "type" : "Snippet"
          } ]
        } ],
        "type" : "Tabs"
      }, {
        "title" : "console output",
        "surroundedBy" : "wait until receive message using path list",
        "startLine" : "waiting",
        "endLine" : "received",
        "lines" : [ "\u001B[33m> \u001B[34mwaiting \u001B[33mfor \u001B[0m\u001B[1mreceived[2].price \u001B[0m\u001B[33mfrom \u001B[35mws://localhost:45923/prices \u001B[0m\u001B[34mto be greater than \u001B[34m30\u001B[0m", "  \u001B[33m> \u001B[34mpolling \u001B[36mwebsocket message\u001B[0m", "    \u001B[33m[\u001B[33m{\u001B[35m\"symbol\"\u001B[33m: \u001B[32m\"IBM\"\u001B[33m, \u001B[35m\"price\"\u001B[33m: \u001B[34m20\u001B[33m}\u001B[33m, \u001B[33m{\u001B[35m\"symbol\"\u001B[33m: \u001B[32m\"IBM\"\u001B[33m, \u001B[35m\"price\"\u001B[33m: \u001B[34m30\u001B[33m}\u001B[33m, \u001B[33m{\u001B[35m\"symbol\"\u001B[33m: \u001B[32m\"IBM\"\u001B[33m, \u001B[35m\"price\"\u001B[33m: \u001B[34m33\u001B[33m}\u001B[33m]\u001B[0m", "  \u001B[32m. \u001B[34mpolled new message\u001B[33m (\u001B[32m2ms\u001B[33m)\u001B[0m", "\u001B[32m. \u001B[0m\u001B[1mreceived[2].price \u001B[0m\u001B[33mfrom \u001B[35mws://localhost:45923/prices \u001B[0m\u001B[34mgreater than \u001B[34m30\u001B[33m (\u001B[32m2ms\u001B[33m)\u001B[0m" ],
        "anchorId" : "wait-for-a-specific-message-using-value-path-console-output-2",
        "type" : "CliOutput"
      } ]
    }, {
      "id" : "poll-message-as-text",
      "title" : "Poll Message As Text",
      "type" : "Section",
      "content" : [ {
        "type" : "Paragraph",
        "content" : [ {
          "text" : "WebTau receives and stores asynchronous messages behind the scene. ",
          "type" : "SimpleText"
        } ]
      }, {
        "type" : "Paragraph",
        "content" : [ {
          "text" : " Use ",
          "type" : "SimpleText"
        }, {
          "code" : "pollAsText",
          "type" : "InlinedCode"
        }, {
          "text" : " to access messages in a synchronous manner. If message is not yet received, ",
          "type" : "SimpleText"
        }, {
          "code" : "pollAsText",
          "type" : "InlinedCode"
        }, {
          "text" : " will wait for a configured (",
          "type" : "SimpleText"
        }, {
          "code" : "webSocketPollTimeout",
          "type" : "InlinedCode"
        }, {
          "text" : ") milliseconds (default 5 seconds).",
          "type" : "SimpleText"
        } ]
      }, {
        "type" : "Paragraph",
        "content" : [ {
          "text" : "In example above, we wait until the price becomes greater than 100. All the messages including the matched one are discarded after ",
          "type" : "SimpleText"
        }, {
          "code" : "waitTo",
          "type" : "InlinedCode"
        }, {
          "text" : ".",
          "type" : "SimpleText"
        } ]
      }, {
        "type" : "Paragraph",
        "content" : [ {
          "code" : "received.pollAsText",
          "type" : "InlinedCode"
        }, {
          "text" : " returns next received message or wait for the message to come:",
          "type" : "SimpleText"
        } ]
      }, {
        "tabsContent" : [ {
          "name" : "Groovy",
          "content" : [ {
            "lang" : "groovy",
            "snippet" : "def nextMessage = wsSession.received.pollAsText()\nnextMessage.should == \"{\\\"symbol\\\":\\\"IBM\\\",\\\"price\\\":102}\"\n\ndef nextNextMessage = wsSession.received.pollAsText(100) // explicit timeout in milliseconds for new message to arrive\nnextNextMessage.should == \"{\\\"symbol\\\":\\\"IBM\\\",\\\"price\\\":103}\"",
            "title" : "poll message",
            "surroundedBy" : "poll-after-wait",
            "commentsType" : "inline",
            "anchorId" : "poll-message-as-text-poll-message",
            "type" : "Snippet"
          } ]
        }, {
          "name" : "Java",
          "content" : [ {
            "lang" : "java",
            "snippet" : "String nextMessage = wsSession.received.pollAsText();\nactual(nextMessage).should(equal(\"{\\\"symbol\\\":\\\"IBM\\\",\\\"price\\\":102}\"));\n\nString nextNextMessage = wsSession.received.pollAsText(100); // explicit timeout in milliseconds for new message to arrive\nactual(nextNextMessage).should(equal(\"{\\\"symbol\\\":\\\"IBM\\\",\\\"price\\\":103}\"));",
            "title" : "poll message",
            "surroundedBy" : "poll-after-wait",
            "commentsType" : "inline",
            "anchorId" : "poll-message-as-text-poll-message-2",
            "type" : "Snippet"
          } ]
        } ],
        "type" : "Tabs"
      }, {
        "type" : "Paragraph",
        "content" : [ {
          "text" : "Note: if there are no already received messages, and no new message arrives within a wait time, ",
          "type" : "SimpleText"
        }, {
          "code" : "null",
          "type" : "InlinedCode"
        }, {
          "text" : " will be returned.",
          "type" : "SimpleText"
        } ]
      } ]
    }, {
      "id" : "poll-message-as-object",
      "title" : "Poll Message As Object",
      "type" : "Section",
      "content" : [ {
        "type" : "Paragraph",
        "content" : [ {
          "text" : "Use ",
          "type" : "SimpleText"
        }, {
          "code" : "received.poll",
          "type" : "InlinedCode"
        }, {
          "text" : " to convert JSON message to a list or a map.",
          "type" : "SimpleText"
        } ]
      }, {
        "tabsContent" : [ {
          "name" : "Groovy",
          "content" : [ {
            "lang" : "groovy",
            "snippet" : "def message = wsSession.received.poll()\nmessage.symbol.should == \"IBM\"",
            "title" : "poll message as map",
            "surroundedBy" : "poll-as-map",
            "anchorId" : "poll-message-as-object-poll-message-as-map",
            "type" : "Snippet"
          } ]
        }, {
          "name" : "Java",
          "content" : [ {
            "lang" : "java",
            "snippet" : "Map<String, ?> message = wsSession.received.poll();\nactual(message.get(\"symbol\")).should(equal(\"IBM\"));",
            "title" : "poll message as map",
            "surroundedBy" : "poll-as-map",
            "anchorId" : "poll-message-as-object-poll-message-as-map-2",
            "type" : "Snippet"
          } ]
        } ],
        "type" : "Tabs"
      } ]
    }, {
      "id" : "max-number-of-messages",
      "title" : "Max Number Of Messages",
      "type" : "Section",
      "content" : [ {
        "type" : "Paragraph",
        "content" : [ {
          "text" : "By default, WebTau keeps only 1000 messages. If new messages arrive, the old ones get discarded.",
          "type" : "SimpleText"
        }, {
          "type" : "SoftLineBreak"
        }, {
          "text" : "Use ",
          "type" : "SimpleText"
        }, {
          "code" : "webSocketMaxMessages",
          "type" : "InlinedCode"
        }, {
          "text" : " config value to change number of messages to keep.",
          "type" : "SimpleText"
        } ]
      } ]
    }, {
      "id" : "number-of-received-messages",
      "title" : "Number Of Received Messages",
      "type" : "Section",
      "content" : [ {
        "type" : "Paragraph",
        "content" : [ {
          "text" : "Use ",
          "type" : "SimpleText"
        }, {
          "code" : "received.count",
          "type" : "InlinedCode"
        }, {
          "text" : " to wait for a certain number of messages:",
          "type" : "SimpleText"
        } ]
      }, {
        "tabsContent" : [ {
          "name" : "Groovy",
          "content" : [ {
            "lang" : "groovy",
            "snippet" : "wsSession.received.count.waitTo == 53",
            "title" : "poll message",
            "include" : "received.count",
            "anchorId" : "number-of-received-messages-poll-message",
            "type" : "Snippet"
          } ]
        }, {
          "name" : "Java",
          "content" : [ {
            "lang" : "java",
            "snippet" : "wsSession.received.count.waitTo(equal(53));",
            "title" : "poll message",
            "include" : "received.count",
            "anchorId" : "number-of-received-messages-poll-message-2",
            "type" : "Snippet"
          } ]
        } ],
        "type" : "Tabs"
      }, {
        "title" : "console output",
        "startLine" : "count",
        "endLine" : "count",
        "lines" : [ "\u001B[33m> \u001B[34mwaiting \u001B[33mfor \u001B[36mcount \u001B[33mof \u001B[36mmessages \u001B[0m\u001B[1mreceived \u001B[0m\u001B[33mfrom \u001B[35mws://localhost:33409/prices \u001B[0m\u001B[34mto equal \u001B[34m53\u001B[0m", "\u001B[32m. \u001B[36mcount \u001B[33mof \u001B[36mmessages \u001B[0m\u001B[1mreceived \u001B[0m\u001B[33mfrom \u001B[35mws://localhost:33409/prices \u001B[0m\u001B[34mequals \u001B[34m53\u001B[33m (\u001B[32m138ms\u001B[33m)\u001B[0m" ],
        "anchorId" : "number-of-received-messages-console-output",
        "type" : "CliOutput"
      } ]
    }, {
      "id" : "discard-messages",
      "title" : "Discard Messages",
      "type" : "Section",
      "content" : [ {
        "type" : "Paragraph",
        "content" : [ {
          "text" : "Use ",
          "type" : "SimpleText"
        }, {
          "code" : "received.discard",
          "type" : "InlinedCode"
        }, {
          "text" : " to remove all already received messages.",
          "type" : "SimpleText"
        }, {
          "type" : "SoftLineBreak"
        }, {
          "text" : "Next ",
          "type" : "SimpleText"
        }, {
          "code" : "received.pollAsText",
          "type" : "InlinedCode"
        }, {
          "text" : " will wait for a new message to arrive as all the received messages will be discarded.",
          "type" : "SimpleText"
        } ]
      }, {
        "tabsContent" : [ {
          "name" : "Groovy",
          "content" : [ {
            "lang" : "groovy",
            "snippet" : "wsSession.received.discard()\n\ndef nextMessage = wsSession.received.pollAsText(1)\nnextMessage.should == null",
            "title" : "discard messages",
            "surroundedBy" : "discard-poll",
            "anchorId" : "discard-messages-discard-messages",
            "type" : "Snippet"
          } ]
        }, {
          "name" : "Java",
          "content" : [ {
            "lang" : "java",
            "snippet" : "wsSession.received.discard();\n\nString nextMessage = wsSession.received.pollAsText(1);\nactual(nextMessage).should(equal(null));",
            "title" : "discard messages",
            "surroundedBy" : "discard-poll",
            "anchorId" : "discard-messages-discard-messages-2",
            "type" : "Snippet"
          } ]
        } ],
        "type" : "Tabs"
      }, {
        "title" : "console output",
        "startLine" : "discarded",
        "endLine" : "no new message is polled",
        "lines" : [ "\u001B[32m. \u001B[34mdiscarded all \u001B[36mmessages \u001B[0m\u001B[1mreceived \u001B[0m\u001B[33mfrom \u001B[35mws://localhost:33409/prices\u001B[33m (\u001B[32m0ms\u001B[33m)\u001B[0m", "\u001B[33m> \u001B[34mpolling \u001B[36mwebsocket message\u001B[0m", "\u001B[32m. \u001B[34mno new message is polled\u001B[33m (\u001B[32m1ms\u001B[33m)\u001B[0m" ],
        "anchorId" : "discard-messages-console-output",
        "type" : "CliOutput"
      } ]
    } ],
    "lastModifiedTime" : 1694377652681,
    "tocItem" : {
      "chapterTitle" : "Web Socket",
      "pageTitle" : "Received Messages",
      "pageMeta" : {
        "identifier" : [ "{validationPath: [\"com/example/tests/junit5/WebSocketSpringBootTest.java\", \"org/testingisdocumenting/webtau/websocket/WebSocketConfig.java\"]}" ]
      },
      "dirName" : "web-socket",
      "fileName" : "received-messages",
      "viewOnRelativePath" : null,
      "pageSectionIdTitles" : [ {
        "title" : "Asynchronous To Synchronous",
        "id" : "asynchronous-to-synchronous"
      }, {
        "title" : "Wait For A Specific Message",
        "id" : "wait-for-a-specific-message"
      }, {
        "title" : "Wait For A Specific Message Using Value Path",
        "id" : "wait-for-a-specific-message-using-value-path"
      }, {
        "title" : "Poll Message As Text",
        "id" : "poll-message-as-text"
      }, {
        "title" : "Poll Message As Object",
        "id" : "poll-message-as-object"
      }, {
        "title" : "Max Number Of Messages",
        "id" : "max-number-of-messages"
      }, {
        "title" : "Number Of Received Messages",
        "id" : "number-of-received-messages"
      }, {
        "title" : "Discard Messages",
        "id" : "discard-messages"
      } ]
    }
  }
}), document.getElementById("znai"));
/*-->*/

</script>

</body>
</html>
