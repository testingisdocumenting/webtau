<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8" /> 
<title>WebTau: Matchers</title>
<link rel="stylesheet" type="text/css" href="/webtau/static/css/katex.min.css">
<link rel="stylesheet" type="text/css" href="/webtau/static/main.css">
<link rel="stylesheet" type="text/css" href="/webtau/logo.css">
<link rel="stylesheet" type="text/css" href="/webtau/static/css/global-overrides.css">
</head>
<link rel="shortcut icon" href="/webtau/favicon.png"type="image/ico"/>
<body class="theme-znai-dark">
<script>(function() {
    var themeNameKey = 'znaiTheme';
    var darkThemeName = 'znai-dark';
    var lightThemeName = 'default';

    var znaiTheme = {
        changeHandlers: [],
        addChangeHandler(handler) {
            this.changeHandlers.push(handler);
        },
        removeChangeHandler(handler) {
            var idx = this.changeHandlers.indexOf(handler);
            this.changeHandlers.splice(idx, 1);
        },
        set(name) {
            this.name = name;
            document.body.className = 'theme-' + name;

            var idx = 0;
            var len = this.changeHandlers.length;
            for (; idx < len; idx++) {
                this.changeHandlers[idx](name);
            }
        },
        setExplicitly(name) {
            storeThemeName(name);
            this.set(name);
        },
        setExplicitlyIfNotSetAlready(name) {
            const themeName = getStoredThemeName();
            if (themeName) {
                return
            }

            this.setExplicitly(name)
        },
        toggle() {
            this.setExplicitly(this.name === lightThemeName ? darkThemeName : lightThemeName)
        }
    };

    var mediaThemeName = setLightMatchMediaListenerAndGetThemeName()
    var themeName = getStoredThemeName() || mediaThemeName;
    znaiTheme.set(themeName);

    window.znaiTheme = znaiTheme;

    function getStoredThemeName() {
        return localStorage.getItem(themeNameKey);
    }

    function storeThemeName(name) {
        return localStorage.setItem(themeNameKey, name);
    }

    function setLightMatchMediaListenerAndGetThemeName() {
        if (!window.matchMedia) {
            return darkThemeName;
        }

        var lightQuery = window.matchMedia('(prefers-color-scheme: light)');
        lightQuery.addEventListener("change", function (e) {
            const newThemeName = e.matches ? lightThemeName : darkThemeName;
            znaiTheme.setExplicitly(newThemeName);
        });

        return lightQuery.matches ? lightThemeName : darkThemeName;
    }
})()</script>
<div id="znai"><div id="znai-initial-page-loading" style="margin: -20px 0 0 -20px; padding: 0 40px 40px 0; width: 100vw; height: 100vh; display: flex; justify-content: center; align-items: center">
    <div></div>
</div><section style="max-width: 640px; margin-left: auto; margin-right: auto;">
<article>
<header><h1>Imports to use</h1></header>
<p>import static org.testingisdocumenting.webtau.WebTauGroovyDsl.*</p>
</article>

<article>
<header><h1>Response Mapping</h1></header>
<p>Identifiers inside validation closure are automatically mapped to a response body. Groovy Java http.get(&quot;/end-point-simple-object&quot;, (header, body) -&gt; { body.get(&quot;k1&quot;).should(equal(&quot;v1&quot;)); }); List responses are handled by using index chain Groovy Note: Groovy API implicitly assumes body , but if you need to deal with array response you need to access values using body explicitly. Java http.get(&quot;/end-point-simple-list&quot;, (header, body) -&gt; { body.get(0).get(&quot;k1&quot;).should(equal(&quot;v1&quot;)); });</p>
</article>

<article>
<header><h1>Should and Should Not</h1></header>
<p>Matchers in webtau are triggered with should and shouldNot keywords. Additionally shouldBe and shouldNotBe alias keywords are available to make certain matcher combinations easier to read. Groovy Java http.get(&quot;/example&quot;, (header, body) -&gt; { body.get(&quot;year&quot;).shouldNot(equal(2000)); body.get(&quot;genres&quot;).should(contain(&quot;RPG&quot;)); body.get(&quot;rating&quot;).shouldBe(greaterThan(7)); });</p>
</article>

<article>
<header><h1>Equality</h1></header>
<p>Webtau defines its own set of equality rules to simplify testing. Groovy Java http.get(&quot;/end-point&quot;, (header, body) -&gt; { body.get(&quot;id&quot;).shouldNot(equal(0)); body.get(&quot;amount&quot;).should(equal(30)); body.get(&quot;list&quot;).should(equal(Arrays.asList(1, 2, 3))); body.get(&quot;object&quot;).get(&quot;k1&quot;).should(equal( Pattern.compile(&quot;v\\d&quot;))); // regular expression matching body.get(&quot;object&quot;).should(equal(aMapOf( &quot;k1&quot;, &quot;v1&quot;, &quot;k3&quot;, &quot;v3&quot;))); // matching only specified fields and can be nested multiple times body.get(&quot;complexList&quot;).should(equal(table(&quot;k1&quot; , &quot;k2&quot;, // matching only specified fields, but number of entries must be exact ________________, &quot;v1&quot; , 30, &quot;v11&quot;, 40))); }); http.doc.capture(&quot;end-point-object-equality-matchers&quot;); Groovy Java http.get(&quot;/end-point&quot;, (header, body) -&gt; { body.get(&quot;complexList&quot;).should(equal(table(&quot;*id&quot;, &quot;k1&quot; , &quot;k2&quot;, // order agnostic key based match ________________, &quot;id2&quot;, &quot;v11&quot;, 40, &quot;id1&quot;, &quot;v1&quot; , 30))); });</p>
</article>

<article>
<header><h1>Greater/Less/Equal</h1></header>
<p>Use greaterThan , greaterThanOrEqual , lessThan , and lessThanOrEqual to assert numeric values. Groovy Note: Groovy can use shortcuts &gt; , &gt;= , &lt; , &lt;= . Java http.get(&quot;/end-point-numbers&quot;, (header, body) -&gt; { body.get(&quot;id&quot;).shouldBe(greaterThan(0)); body.get(&quot;price&quot;).shouldBe(greaterThanOrEqual(100)); body.get(&quot;amount&quot;).shouldBe(lessThan(150)); body.get(&quot;list&quot;).get(1).shouldBe(lessThanOrEqual(2)); body.get(&quot;id&quot;).shouldNotBe(lessThanOrEqual(0)); body.get(&quot;price&quot;).shouldNotBe(lessThan(100)); body.get(&quot;amount&quot;).shouldNotBe(greaterThanOrEqual(150)); body.get(&quot;list&quot;).get(1).shouldNotBe(greaterThan(2)); }); http.doc.capture(&quot;end-point-numbers-matchers&quot;);</p>
</article>

<article>
<header><h1>Contain</h1></header>
<p>Use contain when you cannot rely on order of values in a response. Groovy Java http.get(&quot;/end-point-list&quot;, (header, body) -&gt; { body.should(contain(aMapOf( &quot;k1&quot;, &quot;v1&quot;, &quot;k2&quot;, &quot;v2&quot;))); body.get(1).get(&quot;k2&quot;).shouldNot(contain(22)); }); http.doc.capture(&quot;end-point-list-contain-matchers&quot;);</p>
</article>

<article>
<header><h1>Date and Time</h1></header>
<p>You can assert actual string against LocalDate and ZonedDateTime . String will be automatically converted using ISO formatter. Groovy Java http.get(&quot;/end-point-dates&quot;, (header, body) -&gt; { LocalDate expectedDate = LocalDate.of(2018, 6, 12); ZonedDateTime expectedTime = ZonedDateTime.of(expectedDate, LocalTime.of(9, 0, 0), ZoneId.of(&quot;UTC&quot;)); body.get(&quot;tradeDate&quot;).should(equal(expectedDate)); body.get(&quot;transactionTime&quot;).should(equal(expectedTime)); body.get(&quot;transactionTime&quot;).shouldBe(greaterThanOrEqual(expectedDate)); body.get(&quot;paymentSchedule&quot;).should(contain(expectedDate)); }); http.doc.capture(&quot;end-point-dates-matchers&quot;);</p>
</article>

<article>
<header><h1>Mixing Matchers</h1></header>
<p>You can use matchers in place of expected values to build a more complex expectation. Groovy Java Pattern withNumber = Pattern.compile(&quot;v\\d&quot;); http.get(&quot;/end-point-mixed&quot;, (header, body) -&gt; { body.get(&quot;list&quot;).should(contain(lessThanOrEqual(2))); // lessThanOrEqual will be matched against each value body.get(&quot;object&quot;).should(equal(aMapOf( &quot;k1&quot;, &quot;v1&quot;, &quot;k3&quot;, withNumber))); // regular expression match against k3 body.get(&quot;complexList&quot;).get(0).should(equal(aMapOf( &quot;k1&quot;, &quot;v1&quot;, &quot;k2&quot;, lessThan(120)))); // lessThen match against k2 body.get(&quot;complexList&quot;).get(1).should(equal(aMapOf( &quot;k1&quot;, notEqual(&quot;v1&quot;), // any value but v1 &quot;k2&quot;, greaterThanOrEqual(120)))); TableData expected = table(&quot;k1&quot; , &quot;k2&quot;, // matching only specified fields, but number of entries must be exact ________________________________, withNumber , lessThan(120), &quot;v11&quot; , greaterThan(150)); body.get(&quot;complexList&quot;).should(equal(expected)); }); http.doc.capture(&quot;end-point-mixing-matchers&quot;);</p>
</article>
</section>
</div>
<script type="text/javascript" src="/webtau/toc.js"></script>
<script type="text/javascript" src="/webtau/assets.js"></script>
<script type="text/javascript" src="/webtau/static/main.js"></script>
<script type="text/javascript" src="/webtau/search-index.js"></script>
<script>
document.getElementById('znai').innerHTML = '';
ReactDOM.render(React.createElement(Documentation, {
  "docMeta" : {
    "viewOn" : {
      "link" : "https://github.com/testingisdocumenting/webtau/tree/master/webtau-docs/webtau",
      "title" : "View On GitHub"
    },
    "id" : "webtau",
    "title" : "WebTau",
    "type" : "Guide",
    "previewEnabled" : false
  },
  "page" : {
    "type" : "Page",
    "content" : [ {
      "title" : "Imports to use",
      "id" : "imports-to-use",
      "type" : "Section",
      "content" : [ {
        "lang" : "groovy",
        "snippet" : "import static org.testingisdocumenting.webtau.WebTauGroovyDsl.*",
        "includeRegexp" : "import.*Dsl",
        "title" : "Single import to use",
        "type" : "Snippet"
      } ]
    }, {
      "title" : "Response Mapping",
      "id" : "response-mapping",
      "type" : "Section",
      "content" : [ {
        "type" : "Paragraph",
        "content" : [ {
          "text" : "Identifiers inside validation closure are automatically mapped to a response body.",
          "type" : "SimpleText"
        } ]
      }, {
        "meta" : {
          "rightSide" : true
        },
        "type" : "EmptyBlock"
      }, {
        "title" : "object response",
        "meta" : {
          "rightSide" : false
        },
        "data" : {
          "id" : "id1",
          "k1" : "v1",
          "k2" : "v2"
        },
        "paths" : [ ],
        "type" : "Json"
      }, {
        "meta" : {
          "rightSide" : true
        },
        "tabsContent" : [ {
          "name" : "Groovy",
          "content" : [ {
            "lang" : "groovy",
            "snippet" : "http.get(\"/end-point-simple-object\") {\n    k1.should == 'v1'\n}",
            "entry" : "simple object mapping example",
            "bodyOnly" : true,
            "type" : "Snippet"
          } ]
        }, {
          "name" : "Java",
          "content" : [ {
            "lang" : "java",
            "snippet" : "http.get(\"/end-point-simple-object\", (header, body) -> {\n    body.get(\"k1\").should(equal(\"v1\"));\n});",
            "entry" : "simpleObjectMappingExample",
            "bodyOnly" : true,
            "type" : "Snippet"
          } ]
        } ],
        "type" : "Tabs"
      }, {
        "type" : "Paragraph",
        "content" : [ {
          "text" : "List responses are handled by using index chain",
          "type" : "SimpleText"
        } ]
      }, {
        "meta" : {
          "rightSide" : true
        },
        "type" : "EmptyBlock"
      }, {
        "title" : "list response",
        "data" : [ {
          "id" : "id1",
          "k1" : "v1",
          "k2" : "v2"
        } ],
        "paths" : [ ],
        "type" : "Json"
      }, {
        "meta" : {
          "rightSide" : true
        },
        "tabsContent" : [ {
          "name" : "Groovy",
          "content" : [ {
            "lang" : "groovy",
            "snippet" : "http.get(\"/end-point-simple-list\") {\n    body[0].k1.should == 'v1'\n}",
            "entry" : "simple list mapping example",
            "bodyOnly" : true,
            "type" : "Snippet"
          }, {
            "type" : "Paragraph",
            "content" : [ {
              "text" : "Note: Groovy API implicitly assumes ",
              "type" : "SimpleText"
            }, {
              "code" : "body",
              "type" : "InlinedCode"
            }, {
              "text" : ", but if you need to deal with array response you need to access values using ",
              "type" : "SimpleText"
            }, {
              "code" : "body",
              "type" : "InlinedCode"
            }, {
              "text" : " explicitly.",
              "type" : "SimpleText"
            } ]
          } ]
        }, {
          "name" : "Java",
          "content" : [ {
            "lang" : "java",
            "snippet" : "http.get(\"/end-point-simple-list\", (header, body) -> {\n    body.get(0).get(\"k1\").should(equal(\"v1\"));\n});",
            "entry" : "simpleListMappingExample",
            "bodyOnly" : true,
            "type" : "Snippet"
          } ]
        } ],
        "type" : "Tabs"
      } ]
    }, {
      "title" : "Should and Should Not",
      "id" : "should-and-should-not",
      "type" : "Section",
      "content" : [ {
        "type" : "Paragraph",
        "content" : [ {
          "text" : "Matchers in webtau are triggered with ",
          "type" : "SimpleText"
        }, {
          "code" : "should",
          "type" : "InlinedCode"
        }, {
          "text" : " and ",
          "type" : "SimpleText"
        }, {
          "code" : "shouldNot",
          "type" : "InlinedCode"
        }, {
          "text" : " keywords.",
          "type" : "SimpleText"
        }, {
          "type" : "SoftLineBreak"
        }, {
          "text" : "Additionally ",
          "type" : "SimpleText"
        }, {
          "code" : "shouldBe",
          "type" : "InlinedCode"
        }, {
          "text" : " and ",
          "type" : "SimpleText"
        }, {
          "code" : "shouldNotBe",
          "type" : "InlinedCode"
        }, {
          "text" : " alias keywords are available to make certain matcher combinations easier to read.",
          "type" : "SimpleText"
        } ]
      }, {
        "meta" : {
          "rightSide" : true
        },
        "tabsContent" : [ {
          "name" : "Groovy",
          "content" : [ {
            "lang" : "groovy",
            "snippet" : "http.get(\"/example\") {\n    year.shouldNot == 2000\n    year.should != 2000  // alternative shortcut\n    genres.should contain('RPG')\n    rating.shouldBe > 7\n}",
            "entry" : "matchers basic example",
            "bodyOnly" : true,
            "type" : "Snippet"
          } ]
        }, {
          "name" : "Java",
          "content" : [ {
            "lang" : "java",
            "snippet" : "http.get(\"/example\", (header, body) -> {\n    body.get(\"year\").shouldNot(equal(2000));\n    body.get(\"genres\").should(contain(\"RPG\"));\n    body.get(\"rating\").shouldBe(greaterThan(7));\n});",
            "entry" : "matchersBasicExample",
            "bodyOnly" : true,
            "type" : "Snippet"
          } ]
        } ],
        "type" : "Tabs"
      } ]
    }, {
      "title" : "Equality",
      "id" : "equality",
      "type" : "Section",
      "content" : [ {
        "type" : "Paragraph",
        "content" : [ {
          "text" : "Webtau defines its own set of equality rules to simplify testing.",
          "type" : "SimpleText"
        } ]
      }, {
        "meta" : {
          "rightSide" : true
        },
        "type" : "EmptyBlock"
      }, {
        "title" : "response",
        "pathsFile" : "doc-artifacts/end-point-object-equality-matchers/paths.json",
        "data" : {
          "id" : 10,
          "price" : 100,
          "amount" : 30,
          "list" : [ 1, 2, 3 ],
          "object" : {
            "k1" : "v1",
            "k2" : "v2",
            "k3" : "v3"
          },
          "complexList" : [ {
            "id" : "id1",
            "k1" : "v1",
            "k2" : 30
          }, {
            "id" : "id2",
            "k1" : "v11",
            "k2" : 40
          } ]
        },
        "paths" : [ "root.id", "root.amount", "root.list[0]", "root.list[1]", "root.list[2]", "root.object.k1", "root.object.k3", "root.complexList[0].k1", "root.complexList[0].k2", "root.complexList[1].k1", "root.complexList[1].k2" ],
        "type" : "Json"
      }, {
        "meta" : {
          "rightSide" : true
        },
        "tabsContent" : [ {
          "name" : "Groovy",
          "content" : [ {
            "lang" : "groovy",
            "snippet" : "http.get(\"/end-point\") {\n    id.should != 0\n    amount.should == 30\n\n    list.should == [1, 2, 3]\n\n    object.k1.should == ~/v\\d/ // regular expression matching\n\n    object.should == [k1: 'v1', k3: 'v3'] // matching only specified fields and can be nested multiple times\n\n    complexList.should == [\"k1\"   | \"k2\"] { // matching only specified fields, but number of entries must be exact\n                           ________________\n                            \"v1\"  | 30\n                            \"v11\" | 40 }\n}\n\nhttp.doc.capture(\"end-point-object-equality-matchers\")",
            "entry" : "equality matcher",
            "bodyOnly" : true,
            "commentsType" : "inline",
            "type" : "Snippet"
          } ]
        }, {
          "name" : "Java",
          "content" : [ {
            "lang" : "java",
            "snippet" : "http.get(\"/end-point\", (header, body) -> {\n    body.get(\"id\").shouldNot(equal(0));\n    body.get(\"amount\").should(equal(30));\n\n    body.get(\"list\").should(equal(Arrays.asList(1, 2, 3)));\n\n    body.get(\"object\").get(\"k1\").should(equal(\n            Pattern.compile(\"v\\\\d\"))); // regular expression matching\n\n    body.get(\"object\").should(equal(aMapOf(\n            \"k1\", \"v1\",\n            \"k3\", \"v3\"))); // matching only specified fields and can be nested multiple times\n\n    body.get(\"complexList\").should(equal(table(\"k1\" , \"k2\", // matching only specified fields, but number of entries must be exact\n                                              ________________,\n                                               \"v1\" ,  30,\n                                               \"v11\",  40)));\n});\n\nhttp.doc.capture(\"end-point-object-equality-matchers\");",
            "entry" : "equalityMatcher",
            "bodyOnly" : true,
            "commentsType" : "inline",
            "type" : "Snippet"
          } ]
        } ],
        "type" : "Tabs"
      }, {
        "meta" : {
          "rightSide" : true
        },
        "tabsContent" : [ {
          "name" : "Groovy",
          "content" : [ {
            "lang" : "groovy",
            "snippet" : "http.get(\"/end-point\") {\n    complexList.should == [ \"*id\" | \"k1\"  | \"k2\"] { // order agnostic key based match\n                           ________________________\n                            \"id2\" | \"v11\" | 40\n                            \"id1\" | \"v1\"  | 30 }\n}",
            "entry" : "equality matcher table keys",
            "bodyOnly" : true,
            "commentsType" : "inline",
            "type" : "Snippet"
          } ]
        }, {
          "name" : "Java",
          "content" : [ {
            "lang" : "java",
            "snippet" : "http.get(\"/end-point\", (header, body) -> {\n    body.get(\"complexList\").should(equal(table(\"*id\", \"k1\" , \"k2\", // order agnostic key based match\n                                               ________________,\n                                               \"id2\", \"v11\", 40,\n                                               \"id1\", \"v1\" , 30)));\n});",
            "entry" : "equalityMatcherTableKey",
            "bodyOnly" : true,
            "commentsType" : "inline",
            "type" : "Snippet"
          } ]
        } ],
        "type" : "Tabs"
      } ]
    }, {
      "title" : "Greater/Less/Equal",
      "id" : "greaterlessequal",
      "type" : "Section",
      "content" : [ {
        "type" : "Paragraph",
        "content" : [ {
          "text" : "Use ",
          "type" : "SimpleText"
        }, {
          "code" : "greaterThan",
          "type" : "InlinedCode"
        }, {
          "text" : ", ",
          "type" : "SimpleText"
        }, {
          "code" : "greaterThanOrEqual",
          "type" : "InlinedCode"
        }, {
          "text" : ", ",
          "type" : "SimpleText"
        }, {
          "code" : "lessThan",
          "type" : "InlinedCode"
        }, {
          "text" : ", and ",
          "type" : "SimpleText"
        }, {
          "code" : "lessThanOrEqual",
          "type" : "InlinedCode"
        }, {
          "text" : " to assert numeric values.",
          "type" : "SimpleText"
        } ]
      }, {
        "meta" : {
          "rightSide" : true
        },
        "type" : "EmptyBlock"
      }, {
        "title" : "response",
        "pathsFile" : "doc-artifacts/end-point-numbers-matchers/paths.json",
        "data" : {
          "id" : 10,
          "price" : 100,
          "amount" : 30,
          "list" : [ 1, 2, 3 ]
        },
        "paths" : [ "root.id", "root.price", "root.amount", "root.list[1]" ],
        "type" : "Json"
      }, {
        "meta" : {
          "rightSide" : true
        },
        "tabsContent" : [ {
          "name" : "Groovy",
          "content" : [ {
            "lang" : "groovy",
            "snippet" : "http.get(\"/end-point-numbers\") {\n    id.shouldBe > 0\n    price.shouldBe >= 100\n    amount.shouldBe < 150\n    list[1].shouldBe <= 2\n\n    id.shouldNotBe <= 0\n    price.shouldNotBe < 100\n    amount.shouldNotBe >= 150\n    list[1].shouldNotBe > 2\n}\n\nhttp.doc.capture(\"end-point-numbers-matchers\")",
            "entry" : "compare numbers with greater less matchers",
            "bodyOnly" : true,
            "type" : "Snippet"
          }, {
            "type" : "Paragraph",
            "content" : [ {
              "text" : "Note: ",
              "type" : "SimpleText"
            }, {
              "code" : "Groovy",
              "type" : "InlinedCode"
            }, {
              "text" : " can use shortcuts ",
              "type" : "SimpleText"
            }, {
              "code" : ">",
              "type" : "InlinedCode"
            }, {
              "text" : ", ",
              "type" : "SimpleText"
            }, {
              "code" : ">=",
              "type" : "InlinedCode"
            }, {
              "text" : ", ",
              "type" : "SimpleText"
            }, {
              "code" : "<",
              "type" : "InlinedCode"
            }, {
              "text" : ", ",
              "type" : "SimpleText"
            }, {
              "code" : "<=",
              "type" : "InlinedCode"
            }, {
              "text" : ".",
              "type" : "SimpleText"
            } ]
          } ]
        }, {
          "name" : "Java",
          "content" : [ {
            "lang" : "java",
            "snippet" : "http.get(\"/end-point-numbers\", (header, body) -> {\n    body.get(\"id\").shouldBe(greaterThan(0));\n    body.get(\"price\").shouldBe(greaterThanOrEqual(100));\n    body.get(\"amount\").shouldBe(lessThan(150));\n    body.get(\"list\").get(1).shouldBe(lessThanOrEqual(2));\n\n    body.get(\"id\").shouldNotBe(lessThanOrEqual(0));\n    body.get(\"price\").shouldNotBe(lessThan(100));\n    body.get(\"amount\").shouldNotBe(greaterThanOrEqual(150));\n    body.get(\"list\").get(1).shouldNotBe(greaterThan(2));\n});\n\nhttp.doc.capture(\"end-point-numbers-matchers\");",
            "entry" : "compareNumbersWithGreaterLessMatchers",
            "bodyOnly" : true,
            "type" : "Snippet"
          } ]
        } ],
        "type" : "Tabs"
      } ]
    }, {
      "title" : "Contain",
      "id" : "contain",
      "type" : "Section",
      "content" : [ {
        "type" : "Paragraph",
        "content" : [ {
          "text" : "Use ",
          "type" : "SimpleText"
        }, {
          "code" : "contain",
          "type" : "InlinedCode"
        }, {
          "text" : " when you cannot rely on order of values in a response.",
          "type" : "SimpleText"
        } ]
      }, {
        "meta" : {
          "rightSide" : true
        },
        "type" : "EmptyBlock"
      }, {
        "title" : "response",
        "pathsFile" : "doc-artifacts/end-point-list-contain-matchers/paths.json",
        "data" : [ {
          "id" : "id1",
          "k1" : "v1",
          "k2" : "v2"
        }, {
          "id" : "id2",
          "k1" : "v11",
          "k2" : [ 10, 20, 30 ]
        } ],
        "paths" : [ "root[0].k1", "root[0].k2", "root[1].k2[0]", "root[1].k2[1]", "root[1].k2[2]" ],
        "type" : "Json"
      }, {
        "meta" : {
          "rightSide" : true
        },
        "tabsContent" : [ {
          "name" : "Groovy",
          "content" : [ {
            "lang" : "groovy",
            "snippet" : "http.get(\"/end-point-list\") {\n    body.should contain([k1: 'v1', k2: 'v2'])\n    body[1].k2.shouldNot contain(22)\n}\n\nhttp.doc.capture(\"end-point-list-contain-matchers\")",
            "entry" : "contain matcher",
            "bodyOnly" : true,
            "type" : "Snippet"
          } ]
        }, {
          "name" : "Java",
          "content" : [ {
            "lang" : "java",
            "snippet" : "http.get(\"/end-point-list\", (header, body) -> {\n    body.should(contain(aMapOf(\n            \"k1\", \"v1\",\n            \"k2\", \"v2\")));\n    body.get(1).get(\"k2\").shouldNot(contain(22));\n});\n\nhttp.doc.capture(\"end-point-list-contain-matchers\");",
            "entry" : "containMatcher",
            "bodyOnly" : true,
            "type" : "Snippet"
          } ]
        } ],
        "type" : "Tabs"
      } ]
    }, {
      "title" : "Date and Time",
      "id" : "date-and-time",
      "type" : "Section",
      "content" : [ {
        "type" : "Paragraph",
        "content" : [ {
          "text" : "You can assert ",
          "type" : "SimpleText"
        }, {
          "code" : "actual",
          "type" : "InlinedCode"
        }, {
          "text" : " string against ",
          "type" : "SimpleText"
        }, {
          "code" : "LocalDate",
          "type" : "InlinedCode"
        }, {
          "text" : " and ",
          "type" : "SimpleText"
        }, {
          "code" : "ZonedDateTime",
          "type" : "InlinedCode"
        }, {
          "text" : ". String will be automatically converted",
          "type" : "SimpleText"
        }, {
          "type" : "SoftLineBreak"
        }, {
          "text" : "using ISO formatter.",
          "type" : "SimpleText"
        } ]
      }, {
        "meta" : {
          "rightSide" : true
        },
        "type" : "EmptyBlock"
      }, {
        "title" : "response",
        "pathsFile" : "doc-artifacts/end-point-dates-matchers/paths.json",
        "data" : {
          "id" : 54,
          "tradeDate" : "2018-06-12",
          "transactionTime" : "2018-06-12T10:00:00+01:00:00",
          "paymentSchedule" : [ "2018-06-12", "2018-07-10", "2018-08-09", "2018-09-12" ]
        },
        "paths" : [ "root.tradeDate", "root.transactionTime", "root.paymentSchedule[0]" ],
        "type" : "Json"
      }, {
        "meta" : {
          "rightSide" : true
        },
        "tabsContent" : [ {
          "name" : "Groovy",
          "content" : [ {
            "lang" : "groovy",
            "snippet" : "http.get(\"/end-point-dates\") {\n    def expectedDate = LocalDate.of(2018, 6, 12)\n    def expectedTime = ZonedDateTime.of(expectedDate,\n        LocalTime.of(9, 0, 0),\n        ZoneId.of(\"UTC\"))\n\n    tradeDate.should == expectedDate\n    transactionTime.should == expectedTime\n    transactionTime.shouldBe >= expectedDate\n\n    paymentSchedule.should contain(expectedDate)\n}\n\nhttp.doc.capture(\"end-point-dates-matchers\")",
            "entry" : "working with dates",
            "bodyOnly" : true,
            "type" : "Snippet"
          } ]
        }, {
          "name" : "Java",
          "content" : [ {
            "lang" : "java",
            "snippet" : "http.get(\"/end-point-dates\", (header, body) -> {\n    LocalDate expectedDate = LocalDate.of(2018, 6, 12);\n    ZonedDateTime expectedTime = ZonedDateTime.of(expectedDate,\n            LocalTime.of(9, 0, 0),\n            ZoneId.of(\"UTC\"));\n\n    body.get(\"tradeDate\").should(equal(expectedDate));\n    body.get(\"transactionTime\").should(equal(expectedTime));\n    body.get(\"transactionTime\").shouldBe(greaterThanOrEqual(expectedDate));\n\n    body.get(\"paymentSchedule\").should(contain(expectedDate));\n});\n\nhttp.doc.capture(\"end-point-dates-matchers\");",
            "entry" : "workingWithDates",
            "bodyOnly" : true,
            "type" : "Snippet"
          } ]
        } ],
        "type" : "Tabs"
      } ]
    }, {
      "title" : "Mixing Matchers",
      "id" : "mixing-matchers",
      "type" : "Section",
      "content" : [ {
        "type" : "Paragraph",
        "content" : [ {
          "text" : "You can use matchers in place of expected values to build a more complex expectation.",
          "type" : "SimpleText"
        } ]
      }, {
        "meta" : {
          "rightSide" : true
        },
        "type" : "EmptyBlock"
      }, {
        "title" : "response",
        "pathsFile" : "doc-artifacts/end-point-mixing-matchers/paths.json",
        "data" : {
          "list" : [ 1, 2, 3 ],
          "object" : {
            "k1" : "v1",
            "k2" : "v2",
            "k3" : "v3"
          },
          "complexList" : [ {
            "id" : "id1",
            "k1" : "v1",
            "k2" : 100
          }, {
            "id" : "id2",
            "k1" : "v11",
            "k2" : 200
          } ]
        },
        "paths" : [ "root.list[0]", "root.list[1]", "root.object.k1", "root.object.k3", "root.complexList[0].k1", "root.complexList[0].k2", "root.complexList[1].k1", "root.complexList[1].k2" ],
        "type" : "Json"
      }, {
        "meta" : {
          "rightSide" : true
        },
        "tabsContent" : [ {
          "name" : "Groovy",
          "content" : [ {
            "lang" : "groovy",
            "snippet" : "http.get(\"/end-point-mixed\") {\n    list.should contain(lessThanOrEqual(2)) // lessThanOrEqual will be matched against each value\n\n    object.should == [k1: 'v1', k3: ~/v\\d/] // regular expression match against k3\n\n    complexList[0].should == [k1: 'v1', k2: lessThan(120)] // lessThen match against k2\n\n    complexList[1].should == [\n        k1: notEqual('v1'), // any value but v1\n        k2: greaterThanOrEqual(120)]\n\n    complexList.should == [\"k1\"   | \"k2\"] {\n                          ___________________________\n                           ~/v\\d/ | lessThan(120)\n                            \"v11\" | greaterThan(150) } // using matchers as cell values\n}\n\nhttp.doc.capture(\"end-point-mixing-matchers\")",
            "entry" : "matchers combo",
            "bodyOnly" : true,
            "commentsType" : "inline",
            "type" : "Snippet"
          } ]
        }, {
          "name" : "Java",
          "content" : [ {
            "lang" : "java",
            "snippet" : "Pattern withNumber = Pattern.compile(\"v\\\\d\");\n\nhttp.get(\"/end-point-mixed\", (header, body) -> {\n    body.get(\"list\").should(contain(lessThanOrEqual(2))); // lessThanOrEqual will be matched against each value\n\n    body.get(\"object\").should(equal(aMapOf(\n            \"k1\", \"v1\",\n            \"k3\", withNumber))); // regular expression match against k3\n\n    body.get(\"complexList\").get(0).should(equal(aMapOf(\n            \"k1\", \"v1\",\n            \"k2\", lessThan(120)))); // lessThen match against k2\n\n    body.get(\"complexList\").get(1).should(equal(aMapOf(\n            \"k1\", notEqual(\"v1\"), // any value but v1\n            \"k2\", greaterThanOrEqual(120))));\n\n    TableData expected = table(\"k1\"        , \"k2\", // matching only specified fields, but number of entries must be exact\n                               ________________________________,\n                                withNumber , lessThan(120),\n                                \"v11\"      , greaterThan(150));\n\n    body.get(\"complexList\").should(equal(expected));\n});\n\nhttp.doc.capture(\"end-point-mixing-matchers\");",
            "entry" : "matchersCombo",
            "bodyOnly" : true,
            "commentsType" : "inline",
            "type" : "Snippet"
          } ]
        } ],
        "type" : "Tabs"
      } ]
    } ],
    "lastModifiedTime" : 1589298402068,
    "tocItem" : {
      "sectionTitle" : "REST",
      "pageTitle" : "Matchers",
      "pageMeta" : {
        "type" : [ "two-sides" ]
      },
      "dirName" : "REST",
      "fileName" : "matchers",
      "viewOnRelativePath" : null,
      "pageSectionIdTitles" : [ {
        "title" : "Imports to use",
        "id" : "imports-to-use"
      }, {
        "title" : "Response Mapping",
        "id" : "response-mapping"
      }, {
        "title" : "Should and Should Not",
        "id" : "should-and-should-not"
      }, {
        "title" : "Equality",
        "id" : "equality"
      }, {
        "title" : "Greater/Less/Equal",
        "id" : "greaterlessequal"
      }, {
        "title" : "Contain",
        "id" : "contain"
      }, {
        "title" : "Date and Time",
        "id" : "date-and-time"
      }, {
        "title" : "Mixing Matchers",
        "id" : "mixing-matchers"
      } ]
    }
  },
  "footer" : { }
}), document.getElementById("znai"));
</script>

</body>
</html>
