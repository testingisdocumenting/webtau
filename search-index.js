znaiSearchData = [["getting-started@@what-is-this@@webtau","Getting Started","What Is This","Webtau","Webtau (Web Test automation) - concise and expressive way to write end-to-end and unit tests.Test your application across multiple layers:REST API GraphQL API Browser CLI Database Business Logic (JVM only) Use one layer to re-enforce tests on another. E.g. REST API layer to set up data for Browser test, or database layer to validate GraphQL API.Use powerful REPL/experiments REPL mode to significantly speed up end-to-end tests development. webtau:000> $(\"p\") element is found: by css p getText(): hello web page Capture test artifacts like API Responses, screenshots, command line output to automate your user facing documentation.Leverage out of the box rich reportingTests can be written in any JVM language. Language specific syntactic sugar is available for Groovy . #rest-api-example REST API example #graphql-api-example GraphQL API example #browser-example Browser example #db-example DB example #cli-example CLI example"],["getting-started@@what-is-this@@rest-api-example","Getting Started","What Is This","Rest API Example","Webtau provides a succinct DSL for exercising HTTP end points (e.g. REST APIs) and provides simplified way to assert responses. Groovy package scenarios.rest import static org.testingisdocumenting.webtau.WebTauGroovyDsl.* scenario(\"check weather\") { http.get(\"/weather\") { temperature.shouldBe < 100 } } package com.example.tests.junit5 import org.junit.jupiter.api.Test import org.testingisdocumenting.webtau.junit5.WebTau import static org.testingisdocumenting.webtau.WebTauGroovyDsl.* @WebTau class WeatherGroovyTest { @Test void checkWeather() { http.get(\"/weather\") { temperature.shouldBe < 100 } } } json { \"temperature\": 88 } Java package com.example.tests.junit5; import org.junit.jupiter.api.Test; import org.testingisdocumenting.webtau.junit5.WebTau; import static org.testingisdocumenting.webtau.WebTauDsl.*; @WebTau public class WeatherJavaTest { @Test public void checkWeather() { http.get(\"/weather\", (header, body) -> { body.get(\"temperature\").shouldBe(lessThan(100)); }); } } json { \"temperature\": 88 }"],["getting-started@@what-is-this@@graphql-api-example","Getting Started","What Is This","GraphQL API Example","Similar to HTTP APIs, Webtau also provides the ability to test GraphQL servers with its GraphQL DSL. Groovy package scenarios.rest import static org.testingisdocumenting.webtau.WebTauGroovyDsl.* scenario(\"check weather\") { def query = \"{ weather { temperature } }\"; graphql.execute(query) { weather.temperature.shouldBe < 100 } } package com.example.tests.junit4 import org.junit.Test import org.junit.runner.RunWith import org.testingisdocumenting.webtau.junit4.WebTauRunner import static org.testingisdocumenting.webtau.WebTauDsl.graphql @RunWith(WebTauRunner.class) class GraphQLWeatherGroovyIT { @Test void checkWeather() { def query = \"{ weather { temperature } }\"; graphql.execute(query) { weather.temperature.shouldBe < 100 } } } json { \"data\": { \"weather\": { \"temperature\": 88 } } } Java package com.example.tests.junit4; import org.junit.Test; import org.junit.runner.RunWith; import org.testingisdocumenting.webtau.junit4.WebTauRunner; import static org.testingisdocumenting.webtau.WebTauDsl.*; @RunWith(WebTauRunner.class) public class GraphQLWeatherJavaIT { @Test public void checkWeather() { String query = \"{ weather { temperature } }\"; graphql.execute(query, (header, body) -> { body.get(\"data.weather.temperature\").shouldBe(lessThan(100)); }); } } json { \"data\": { \"weather\": { \"temperature\": 88 } } }"],["getting-started@@what-is-this@@browser-example","Getting Started","What Is This","Browser Example","Groovy package scenarios.ui import static org.testingisdocumenting.webtau.WebTauGroovyDsl.* import static pages.Pages.* scenario(\"search by specific query\") { search.submit(\"search this\") search.numberOfResults.waitToBe > 1 } package pages import static org.testingisdocumenting.webtau.WebTauDsl.* class SearchPage { def header = $(\"#header\") def welcomeMessage = $(\"#welcome\") def searchMessage = $(\"#message\") def box = $(\"#search-box\") def results = $(\"#results .result\") def numberOfResults = results.count def submit(query) { browser.open(\"/search\") box.setValue(query) box.sendKeys(browser.keys.enter) } } package pages class Pages { static final def search = new SearchPage() } Java package com.example.tests.junit5; import org.junit.jupiter.api.Test; import org.testingisdocumenting.webtau.junit5.WebTau; import static com.example.tests.junit5.pages.Pages.*; import static org.testingisdocumenting.webtau.WebTauDsl.*; @WebTau public class WebSearchJavaTest { @Test public void searchByQuery() { search.submit(\"search this\"); search.numberOfResults.waitToBe(greaterThan(1)); } } package com.example.tests.junit5.pages; import org.testingisdocumenting.webtau.browser.page.PageElement; import org.testingisdocumenting.webtau.browser.page.PageElementValue; import static org.testingisdocumenting.webtau.WebTauDsl.*; public class SearchPage { private final PageElement box = $(\"#search-box\"); private final PageElement results = $(\"#results .result\"); public final PageElementValue<Integer> numberOfResults = results.getCount(); public void submit(String query) { browser.open(\"/search\"); box.setValue(query); box.sendKeys(browser.keys.enter); } } package com.example.tests.junit5.pages; public class Pages { public static SearchPage search = new SearchPage(); }"],["getting-started@@what-is-this@@db-example","Getting Started","What Is This","DB Example","def PRICES = db.table(\"PRICES\") PRICES << [ \"id\" | \"description\" | \"available\" | \"type\" | \"price\" ] { _____________________________________________________________________________________________ cell.guid | \"nice set\" | true | \"card\" | 1000 // cell.guid generates random guid that can be used for ids cell.guid | \"nice set\" | true | \"card\" | cell.above + 10 // cell.above refers values above and can be modified with simple math operations cell.guid | \"another set\" | permute(true, false) | permute(\"rts\", \"fps\") | cell.above + 20 } // permute generates additional rows generating new rows with all the permutations"],["getting-started@@what-is-this@@cli-example","Getting Started","What Is This","CLI Example","cli.run('echo hello world') { output.should contain('hello') output.should contain('world') }"],["getting-started@@why@@consistent-api","Getting Started","Why","Consistent API","There are multiple tools to help you test REST API, GraphQL API, Web UI, Database and CLI. Some of them are JUnit specific, some of them are UI driven. Some use their own matchers and some try to integrate with a specific matcher interface.Question: Why did we create another tool?Tests I write, and the way I write them often require interactions and assertions on multiple layers. Combining multiple frameworks to achieve the goal ends up with a mix of styles in a single test file. It complicates tests creation and maintenance."],["getting-started@@why@@reporting","Getting Started","Why","Reporting","Webtau in its core captures test actions and assertions. Everything you do, every match that is passed or failed is being recorded.Information is available in console output, so you don't need to sprinkle println statements everywhere. And all the captured information is available as self-contained rich HTML report."],["getting-started@@why@@syntax-sugar","Getting Started","Why","Syntax Sugar","Webtau provides DSL to make common testing operations succinct. Syntax sugar is available for Java and Groovy and since webtau core is Java, additional syntax sugar can be added to languages like Kotlin and Scala."],["getting-started@@why@@repl","Getting Started","Why","REPL","Writing end-to-end tests is hard and there are a lot of excuses not write one. End to end test feedback loop is usually long and slow. Webtau provides REPL/experiments REPL mode to help you experiment with API and write a test in incremental fashion."],["getting-started@@why@@utilities","Getting Started","Why","Utilities","Webtau provides many utility functions to simplify data organization and setup. utilities/data Data module provides shortcuts to deal with CSV and JSON based data. utilities/file-system File System module provides shortcuts to deal with file system related things."],["getting-started@@why@@documentation-artifacts","Getting Started","Why","Documentation Artifacts","I believe that big chunks of a documentation of your product should be automatically generated:Screenshots (with annotations) API request/response examples CLI params and sample output Webtau provides a set of commands to help you capture artifacts of your happy path tests to later be used by a documentation system.Captured artifacts are agnostic to the documentation system. I personally use https://github.com/testingisdocumenting/znai Znai, a markdown based documentation with custom extensions (I am a maintainer of the project)."],["getting-started@@installation@@runners","Getting Started","Installation","Runners","To run webtau tests you have a few options: #groovy-runner Standalone Groovy Runner #junit5 JUnit5 #junit4 JUnit4"],["getting-started@@installation@@groovy-runner","Getting Started","Installation","Groovy Runner","If you have https://brew.sh brew installed in your system use brew install testingisdocumenting/brew/webtau If you have https://sdkman.io sdkman installed in your system use sdk install webtau Alternatively, download and unzip https://repo.maven.apache.org/maven2/org/testingisdocumenting/webtau/webtau-dist/1.41/webtau-dist-1.41-webtau.zip webtau. Add it to your PATH . webtau --example Navigate into todo example cd examples/todo import static org.testingisdocumenting.webtau.WebTauGroovyDsl.* scenario('fetch todo item') { http.get('/todos/1') { title.should == 'delectus aut autem' completed.should == false } } To run test webtau todolist.groovy --url=https://jsonplaceholder.typicode.com Note: using import is optional and is mainly for IDE auto completion. Imports are added implicitly during command line run. To integrate CLI run into maven build use: <dependency> <groupId>org.testingisdocumenting.webtau</groupId> <artifactId>webtau-groovy</artifactId> <version>1.41</version> </dependency> <plugin> <groupId>org.testingisdocumenting.webtau</groupId> <artifactId>webtau-maven-plugin</artifactId> <version>1.41</version> <executions> <execution> <phase>test</phase> <goals> <goal>run</goal> </goals> </execution> </executions> <configuration> <workingDir>${project.basedir}/src/main/groovy</workingDir> <env>integration</env> <url>http://optional-base-url</url> <tests> <directory>${project.basedir}/src/main/groovy</directory> <includes> <include>scenarios/simple*.groovy</include> </includes> </tests> </configuration> </plugin> groovy-standalone-runner/introduction Learn more about Groovy Runner features"],["getting-started@@installation@@junit5","Getting Started","Installation","JUnit5","Groovy <dependency> <groupId>org.testingisdocumenting.webtau</groupId> <artifactId>webtau-groovy</artifactId> <version>1.41</version> </dependency> <dependency> <groupId>org.testingisdocumenting.webtau</groupId> <artifactId>webtau-junit5</artifactId> <version>1.41</version> </dependency> package com.example.tests.junit5 import org.junit.jupiter.api.Test import org.testingisdocumenting.webtau.junit5.WebTau import static org.testingisdocumenting.webtau.WebTauGroovyDsl.* // convenient single import for all things webtau @WebTau // annotation required for reports generation class JUnit5ExampleGroovyTest { @Test void \"my test\"() { } } Java <dependency> <groupId>org.testingisdocumenting.webtau</groupId> <artifactId>webtau</artifactId> <version>1.41</version> </dependency> <dependency> <groupId>org.testingisdocumenting.webtau</groupId> <artifactId>webtau-junit5</artifactId> <version>1.41</version> </dependency> package com.example.tests.junit5; import org.junit.jupiter.api.Test; import org.testingisdocumenting.webtau.junit5.WebTau; import static org.testingisdocumenting.webtau.WebTauDsl.*; // convenient single import for all things webtau @WebTau // annotation required for reports generation public class JUnit5ExampleJavaTest { @Test public void myTest() { } }"],["getting-started@@installation@@junit4","Getting Started","Installation","JUnit4","Groovy <dependency> <groupId>org.testingisdocumenting.webtau</groupId> <artifactId>webtau-groovy</artifactId> <version>1.41</version> </dependency> <dependency> <groupId>org.testingisdocumenting.webtau</groupId> <artifactId>webtau-junit4</artifactId> <version>1.41</version> </dependency> package com.example.tests.junit4 import org.junit.Test import org.junit.runner.RunWith import org.testingisdocumenting.webtau.junit4.WebTauRunner import static org.testingisdocumenting.webtau.WebTauGroovyDsl.* // convenient single import for all things webtau @RunWith(WebTauRunner.class) // webtau runner to generate reports class JUnit4ExampleGroovyTest { @Test void \"my test\"() { } } Java <dependency> <groupId>org.testingisdocumenting.webtau</groupId> <artifactId>webtau</artifactId> <version>1.41</version> </dependency> <dependency> <groupId>org.testingisdocumenting.webtau</groupId> <artifactId>webtau-junit4</artifactId> <version>1.41</version> </dependency> package com.example.tests.junit4; import org.junit.Test; import org.junit.runner.RunWith; import org.testingisdocumenting.webtau.junit4.WebTauRunner; import static org.testingisdocumenting.webtau.WebTauDsl.*; // convenient single import for all things webtau @RunWith(WebTauRunner.class) // webtau runner to generate reports public class JUnit4ExampleJavaTest { @Test public void myTest() { } }"],["getting-started@@configuration@@config-file","Getting Started","Configuration","Config File","Webtau let you specify services url, browser settings, DB url connections, etc in a config file. Depending on getting-started/installation runner you use webtau will read data from a different place. Groovy When you use the Groovy runner, it will look for webtau.cfg.groovy file (default). url = \"http://localhost:8080\" Note: webtau treats groovy config file as code Java When you use JUnit like runners, e.g. getting-started/installation#junit5 JUnit5, webtau expects file named webtau.properties to be present in test classpath, e.g. test resources: url = http://localhost:8080"],["getting-started@@configuration@@environments","Getting Started","Configuration","Environments","Webtau supports environment specific config values, and a way to select which environment to set active during tests run. Groovy url = \"http://localhost:8080\" environments { qa { url = \"http://server.qa:8080\" } } To select an active environment using groovy-standalone-runner/introduction Groovy Standalone Runner you can pass env as cli parameter webtau --env=qa Additionally you can use environment varialbe to set an active environment: WEBTAU_ENV=qa . Java url = http://localhost:8080 environments.qa.url = http://server.qa:8080 To select an active environment you have two options:System property -Denv=qa Environment variable WEBTAU_ENV=qa"],["getting-started@@configuration@@overrides","Getting Started","Configuration","Overrides","Webtau has a list of options you can specify using config file: configuration/options url, browserId, etc.. You can override any value using configuration/options#environment-variable-options environment variables: export WEBTAU_URL=http://another-server export WEBTAU_CHROME_DRIVER_PATH=/path/to/chrome/driver In addition to environment variables, you can use a runner specific way to override: Groovy Standalone Runner In case of Groovy standalone runner, pass --<option>=<value> : webtau --waitTimeout=25000 --url=http://another-server JUnit Like Runners Pass system property via java -D option: -Durl=http://another-server"],["HTTP@@introduction@@","HTTP","Introduction","","Webtau http. module lets you exercise and validate HTTP endpoints. It provides a simplified way to access JSON response of an end-point and simplifies REST API tests. Groovy package scenarios.rest import static org.testingisdocumenting.webtau.WebTauGroovyDsl.* scenario(\"check weather\") { http.get(\"/weather\") { temperature.shouldBe < 100 } } package com.example.tests.junit5 import org.junit.jupiter.api.Test import org.testingisdocumenting.webtau.junit5.WebTau import static org.testingisdocumenting.webtau.WebTauGroovyDsl.* @WebTau class WeatherGroovyTest { @Test void checkWeather() { http.get(\"/weather\") { temperature.shouldBe < 100 } } } json { \"temperature\": 88 } Java package com.example.tests.junit5; import org.junit.jupiter.api.Test; import org.testingisdocumenting.webtau.junit5.WebTau; import static org.testingisdocumenting.webtau.WebTauDsl.*; @WebTau public class WeatherJavaTest { @Test public void checkWeather() { http.get(\"/weather\", (header, body) -> { body.get(\"temperature\").shouldBe(lessThan(100)); }); } } json { \"temperature\": 88 }"],["HTTP@@CRUD@@example","HTTP","CRUD","Example","We have an app that exposes create , read , update , and delete operations for customer records. Records are being served under /customers .Here is an example of a CRUD operations test. Groovy package scenarios.rest.springboot import static org.testingisdocumenting.webtau.WebTauGroovyDsl.* scenario(\"CRUD operations for customer\") { def customerPayload = [firstName: \"FN\", lastName: \"LN\"] // new customer data def id = http.post(\"/customers\", customerPayload) { return id // return id value from response body } http.get(\"/customers/${id}\") { body.should == customerPayload // only specified properties will be asserted against } def changedLastName = \"NLN\" http.put(\"/customers/${id}\", [*:customerPayload, lastName: changedLastName]) { lastName.should == changedLastName // specifying body is optional } http.get(\"/customers/${id}\") { firstName.should == \"FN\" lastName.should == changedLastName } def changedFirstName = \"NFN\" http.patch(\"/customers/${id}\", [firstName: changedFirstName]) http.get(\"/customers/${id}\") { firstName.should == changedFirstName lastName.should == changedLastName } http.delete(\"/customers/${id}\") { statusCode.should == 204 } http.get(\"/customers/${id}\") { statusCode.should == 404 } } Java package com.example.tests.junit5; import org.testingisdocumenting.webtau.junit5.WebTau; import org.junit.jupiter.api.Test; import java.util.Map; import static org.testingisdocumenting.webtau.WebTauDsl.*; @WebTau public class CustomerCrudJavaTest { @Test public void crud() { Map<String, ?> customerPayload = aMapOf( // new customer data \"firstName\", \"FN\", \"lastName\", \"LN\" ); int id = http.post(\"/customers\", customerPayload, ((header, body) -> { return body.get(\"id\"); // return id value from response body })); http.get(\"/customers/\" + id, ((header, body) -> { body.should(equal(customerPayload)); // only specified properties will be asserted against })); String changedLastName = \"NLN\"; Map<String, ?> changedCustomerPayload = aMapOf( \"firstName\", \"FN\", \"lastName\", changedLastName); http.put(\"/customers/\" + id, changedCustomerPayload, ((header, body) -> { body.get(\"firstName\").should(equal(\"FN\")); body.get(\"lastName\").should(equal(changedLastName)); })); http.get(\"/customers/\" + id, ((header, body) -> { body.should(equal(changedCustomerPayload)); })); http.delete(\"/customers/\" + id, ((header, body) -> { header.statusCode().should(equal(204)); })); http.get(\"/customers/\" + id, ((header, body) -> { header.statusCode().should(equal(404)); })); } }"],["HTTP@@CRUD@@implicit-statuscode-check","HTTP","CRUD","Implicit statusCode Check","If you don't have an explicit statusCode validation it will be automatically validated based on the rules below Method Expected Code [{text=GET, type=SimpleText}] [{text=200, type=SimpleText}] [{text=POST, type=SimpleText}] [{text=201, type=SimpleText}] [{text=PUT, type=SimpleText}] [{text=200, type=SimpleText}] [{text=PUT (no content), type=SimpleText}] [{text=204, type=SimpleText}] [{text=DELETE, type=SimpleText}] [{text=200, type=SimpleText}] [{text=DELETE (no content), type=SimpleText}] [{text=204, type=SimpleText}] [{text=PATCH, type=SimpleText}] [{text=200, type=SimpleText}] [{text=PATCH (no content), type=SimpleText}] [{text=204, type=SimpleText}]"],["HTTP@@CRUD@@report","HTTP","CRUD","Report","After your test executions a report will be produced.Note: asserted values are being tracked and highlighted inside the report"],["HTTP@@CRUD-separated@@lazy-resource","HTTP","CRUD Separated","Lazy Resource","Groovy One of the benefits of separating one CRUD scenario into multiple is to be able to run one test at a time. In order to make each test runnable independently we will use createLazyResource . package scenarios.rest.springboot import static org.testingisdocumenting.webtau.WebTauGroovyDsl.* def customerPayload = [firstName: \"FN\", lastName: \"LN\"] def customer = createLazyResource(\"customer\") { // lazy resource to be created on the first access def id = http.post(\"/customers\", customerPayload) { return id } return new Customer(id: id, url: \"/customers/${id}\") // definition is below } scenario(\"customer create\") { customer.id.should != null // accessing resource for the first time will trigger POST (in this example) } scenario(\"customer read\") { http.get(customer.url) { // convenient re-use of url defined above body.should == customerPayload } } scenario(\"customer update\") { def changedLastName = \"NLN\" http.put(customer.url, [*:customerPayload, lastName: changedLastName]) { lastName.should == changedLastName } http.get(customer.url) { lastName.should == changedLastName } } scenario(\"customer delete\") { http.delete(customer.url) { statusCode.should == 204 } http.get(customer.url) { statusCode.should == 404 } } package scenarios.rest.springboot class Customer { Number id String url // store url of the created entity } Note: to run one scenario at a time use sscenario (additional s in front). groovy-standalone-runner/selective-run Read more Java One of the benefits of separating one CRUD @Test into multiple is to be able to run one test at a time. In order to make each test runnable independently we will leverage BeforeAll , AfterAll , and TestMethodOrder . package com.example.tests.junit5; import org.testingisdocumenting.webtau.junit5.WebTau; import org.junit.jupiter.api.*; import java.util.Map; import static org.testingisdocumenting.webtau.WebTauDsl.*; @WebTau @TestMethodOrder(MethodOrderer.OrderAnnotation.class) // forcing methods execution order @DisplayName(\"customer CRUD\") public class CustomerCrudSeparatedJavaTest { private static final Map<String, ?> customerPayload = aMapOf( \"firstName\", \"FN\", \"lastName\", \"LN\" ); private static final Map<String, ?> changedCustomerPayload = aMapOf( customerPayload, \"lastName\", \"NLN\"); private static int id; @BeforeAll @DisplayName(\"create customer\") // optional friendly name for reporting purposes static void createCustomer() { id = http.post(\"/customers\", customerPayload, ((header, body) -> { return body.get(\"id\"); })); actual(id).shouldNot(equal(0)); } @Test @Order(1) @DisplayName(\"read customer\") void read() { http.get(\"/customers/\" + id, ((header, body) -> { body.should(equal(customerPayload)); })); } @Test @Order(2) // order dependence saves from creating customer on every test @DisplayName(\"update customer\") void update() { http.put(\"/customers/\" + id, changedCustomerPayload, ((header, body) -> { body.should(equal(changedCustomerPayload)); })); http.get(\"/customers/\" + id, ((header, body) -> { body.should(equal(changedCustomerPayload)); })); } @Test @Order(3) // but you can still run each method independently @DisplayName(\"delete customer\") void delete() { http.delete(\"/customers/\" + id, ((header, body) -> { header.statusCode().should(equal(204)); })); http.get(\"/customers/\" + id, ((header, body) -> { header.statusCode().should(equal(404)); })); id = -1; // marking as deleted to let cleanup step know that no delete is required } @AfterAll static void cleanup() { // optional (since we create new ids all the time) step to keep your environment clean if (id == -1) { return; } http.delete(\"/customers/\" + id); } }"],["HTTP@@CRUD-separated@@report","HTTP","CRUD Separated","Report","As you can see in the report below, each CRUD operation has its own entry. If you follow this pattern, then you can filter tests by create , update , read , delete to streamline investigation."],["HTTP@@data-node@@special-values","HTTP","Data Node","Special Values","http.get(\"/end-point\") { price.should == 100 assert price instanceof DataNode } Values that you access inside validation block are special values of DataNode type. When you assert them using should statement they act as proxies that record every assertion that you do."],["HTTP@@data-node@@extracting-values","HTTP","Data Node","Extracting Values","As you have seen in HTTP/CRUD CRUD example you can return values back from a validation block. def id = http.get(\"/end-point\") { return id } assert id == 10 assert id.getClass() == Integer When you return a value from a validation block, it automatically gets converted to its correspondent primitive.Note: asserting that value after returning will not track and associated assertions with the call anymore. Use it only to get values required for consequent test calls."],["HTTP@@data-node@@properties-on-lists","HTTP","Data Node","Properties On Lists","If you have a list of objects like complexList above, you can access all its children property value with complexList.k2 . http.get(\"/end-point\") { complexList.k2.should == [30, 40] }"],["HTTP@@data-node@@path-based-properties-access","HTTP","Data Node","Path based properties access","Primarily for Java users, webtau supports the ability to query properties of a DataNode via a path instead of chaining get(String name) calls. For example, to obtain a simple property: http.get(\"/end-point\", (header, body) -> { body.get(\"object.k1\").should(equal(\"v1\")); }); It is also possible to query arrays, including the ability to query for the Nth element from the end: http.get(\"/end-point\", (header, body) -> { body.get(\"complexList[0].k1\").should(equal(\"v1\")); body.get(\"complexList[-1].k1\").should(equal(\"v11\")); }); Similarly to the Groovy example in HTTP/data-node#properties-on-lists Properties On Lists, it is possible to access all children property values: http.get(\"/end-point\", (header, body) -> { body.get(\"complexList.k1\").should(equal(Arrays.asList(\"v1\", \"v11\"))); });"],["HTTP@@data-node@@if-else-logic","HTTP","Data Node","If-Else Logic","Even though values that you access inside validation block are special values of DataNode type, you can still perform simple if-else like logic checks on them. Accessing the values will mark them as \"touched\" for data coverage statistic. def zipCode = http.get(\"/address\") { return addressType == \"complex\" ? address.zipCode : \"NA\" } zipCode.should == \"12345\" Warning: Comparison of complex values is not properly implemented due to current Groovy API implementation details"],["HTTP@@data-node@@each","HTTP","Data Node","Each","Special values inside assertion block have convenient methods each to iterate over a list http.get(\"/end-point\") { list.each { it.shouldBe > 0 } } http.get(\"/end-point\") { complexList.each { k2.shouldBe > 0 } }"],["HTTP@@data-node@@find","HTTP","Data Node","Find","find to find a single value def found = http.get(\"/end-point\") { return list.find { it > 1 } } assert found == 2 assert found.getClass() == Integer and findAll to find all the values matching predicate def found = http.get(\"/end-point\") { return list.findAll { it > 1 } } assert found == [2, 3] assert found[0].getClass() == Integer Note: While values inside a predicate are normal values, the result of find and findAll is still DataNode def id = http.get(\"/end-point\") { def found = complexList.find { assert k1.getClass() == String k1 == 'v1' } assert found.getClass() == GroovyDataNode return found.id } assert id.getClass() == String"],["HTTP@@data-node@@collect","HTTP","Data Node","Collect","Use collect to transform a collection of items def transformed = http.get(\"/end-point\") { return list.collect { \"world#${it}\" } } assert transformed == ['world#1', 'world#2', 'world#3'] assert transformed[0] instanceof GString"],["HTTP@@data-node@@combine","HTTP","Data Node","Combine","Methods find and collect can be chained def sum = http.get(\"/end-point\") { return complexList .findAll { k1.startsWith('v1') } .collect { k2 } .sum() } assert sum == 70"],["HTTP@@headers@@standard-header","HTTP","Headers","Standard Header","Standard headers like Content-Type and Accept are set on your behalf. When payload content is present then values are based on the content type you are sending. When no payload is present, it defaults to application/json ."],["HTTP@@headers@@common-header","HTTP","Headers","Common Header","If each http request requires the same header you can specify that header using httpHeaderProvider . Common example is specifying authentication header. package scenarios.rest.headers import scenarios.rest.headers.auth.Auth url = \"http://localhost:8080\" httpHeaderProvider = Auth.&authHeader Where Auth.&authHeader is implemented as follows: package scenarios.rest.headers.auth import org.testingisdocumenting.webtau.console.ConsoleOutputs import org.testingisdocumenting.webtau.http.HttpHeader class Auth { static HttpHeader authHeader(String fullUrl, String url, HttpHeader original) { ConsoleOutputs.out('auth header injection point') return original.merge([Authorization: 'Bearer <token>']) } } This removes implementation details from your tests and makes them less brittle."],["HTTP@@headers@@explicit-header","HTTP","Headers","Explicit Header","To explicitly set header pass http.header(values) as an additional parameter. http.get(\"/end-point\", http.header('Accept', 'application/octet-stream')) { // assertions go here } http.get(\"/end-point\", [queryParam1: 'queryParamValue1'], http.header('Accept', 'application/octet-stream')) { // assertions go here } http.patch(\"/end-point\", http.header('Accept', 'application/octet-stream'), [fileId: 'myFile']) { // assertions go here } http.post(\"/end-point\", http.header('Accept', 'application/octet-stream'), [fileId: 'myFile']) { // assertions go here } http.put(\"/end-point\", http.header('Accept', 'application/octet-stream'), [fileId: 'myFile', file: sampleFile]) { // assertions go here } http.delete(\"/end-point\", http.header('Custom-Header', 'special-value')) Additionally http.header accepts values as a map. def varArgHeader = http.header( 'My-Header1', 'Value1', 'My-Header2', 'Value2') def mapBasedHeader = http.header([ 'My-Header1': 'Value1', 'My-Header2': 'Value2']) assert varArgHeader == mapBasedHeader"],["HTTP@@headers@@mime-type-combined-with-payload","HTTP","Headers","Mime Type Combined With Payload","Use http.body to combine Content-Type and payload. def content = binaryFile('path') http.post(\"/end-point\", http.body(\"application/octet-stream\", content)) { // assertions go here } If you need a standard type consider using def content = binaryFile('path') http.post(\"/end-point\", http.application.octetStream(content)) { // assertions go here } def content = 'text content' http.post(\"/end-point\", http.text.plain(content)) { // assertions go here }"],["HTTP@@headers@@response-header","HTTP","Headers","Response Header","To validate values from response header use header object. http.post(\"/end-point\") { header.location.should == 'http://www.example.org/url/23' header['Location'].should == 'http://www.example.org/url/23' header.contentLocation.should == '/url/23' header['Content-Location'].should == '/url/23' header.contentLength.shouldBe > 300 header['Content-Length'].shouldBe > 300 } At the moment only location , contentLocation , contentLength have camelCase shortcuts. All the other header values you need to use ['Header-Name'] syntax."],["HTTP@@query-parameters@@passing-query-parameters","HTTP","Query Parameters","Passing Query Parameters","Webtau offers a number of ways of specifying query parameters: http.get(\"params?a=1&b=text\") { // assertions go here } Use Map as a second parameter to pass query parameters. Suitable for languages that support in-line creation of Map . http.get(\"params\", [a: 1, b: 'text']) { // assertions go here } Only http.get has a Map variant, for http.put , http.post , etc you must use http.query . http.get(\"params\", http.query([a: 1, b: 'text']), http.header(['x-param': 'value'])) { // assertions go here } Additionally http.query has a vararg variant which is more convenient for Java . http.get(\"params\", http.query('a', '1', 'b', 'text')) { // assertions go here }"],["HTTP@@query-parameters@@parameters-encoding","HTTP","Query Parameters","Parameters Encoding","All query parameters are encoded automatically. http.get(\"params\", http.query([message: 'hello world !'])) { // assertions go here } params?message=hello+world+%21"],["HTTP@@ping@@get","HTTP","Ping","GET","Use http.ping to have a simplified way to check if url is responding with 200 on GET request. if (!http.ping(\"/weather\")) { http.post(\"/cluster-master\", [restart: \"weather\"]) } http.ping(\"/weather\") http.ping(\"/weather\", [\"query-param\": \"value\"]) http.ping(\"/weather\", [\"query-param\": \"value\"], http.header([\"X-flag\": \"test\"]))"],["HTTP@@files-upload@@file-system-content","HTTP","Files Upload","File System Content","In following examples backend expects a file passed as multipart/form-data . File content is expected to be stored in file field. Backend responds with received file name and file description.To POST form data, you need to use the same http.post statement as you saw in previous examples. Second parameter should be http.formData instead of a map payload we used for JSON . def imagePath = testResourcePath(\"src/test/resources/image.png\") http.post(\"/file-upload\", http.formData(file: imagePath)) { fileName.should == 'image.png' } Use http.formFile to override file name that is being sent to the backend. def imagePath = testResourcePath(\"src/test/resources/image.png\") http.post(\"/file-upload\", http.formData(file: http.formFile('myFileName.png', imagePath))) { fileName.should == 'myFileName.png' } Multiple form fields can be specified like in the example below. def imagePath = testResourcePath(\"src/test/resources/image.png\") http.post(\"/file-upload\", http.formData(file: imagePath, fileDescription: 'new report')) { fileName.should == 'image.png' description.should == 'new report' }"],["HTTP@@files-upload@@in-memory-content","HTTP","Files Upload","In-Memory Content","If your test already has content, you can explicitly pass it as is. byte[] fileContent = [1, 2, 3, 4] as byte[] http.post(\"/file-upload\", http.formData(file: fileContent)) { fileName.should == 'backend-generated-name-as-no-name-provided' } Note: no file name is passed and this particular backend generated file name on your behalf.Use http.formFile to provide a file name byte[] fileContent = [1, 2, 3, 4] as byte[] http.post(\"/file-upload\", http.formData( file: http.formFile('myFileName.dat', fileContent))) { fileName.should == 'myFileName.dat' }"],["HTTP@@PDF@@asserting-text","HTTP","PDF","Asserting Text","If response contains a pdf file you can assert its content using pdf(body) function. http.get(\"/report\") { pdf(body).pageText(0).should contain('Quarterly earnings:') } If more than one assertion needs to be made, assign pdf result to a local variable. http.get(\"/report\") { def pdf = pdf(body) pdf.pageText(0).should contain('Quarterly earnings:') pdf.pageText(1).should == 'Intentional blank page\\n' } Note: use pdf assertions for sanity checks like presence of correct client names or account numbers. Leave comprehensive pdf generation test to unit tests."],["HTTP@@documentation@@scenarios","HTTP","Documentation","Scenarios","You document REST endpoints so users can use them to achieve various goals. You also need to make sure that documented scenarios work as advertised.To automate the process, capture executed scenarios and use them inside your documentation."],["HTTP@@documentation@@capturing-test-artifacts","HTTP","Documentation","Capturing Test Artifacts","To capture REST artifacts use http.doc.capture : package scenarios.rest import static org.testingisdocumenting.webtau.WebTauDsl.http import static org.testingisdocumenting.webtau.WebTauGroovyDsl.scenario scenario(\"extracting id after POST to use inside GET request\") { def id = http.post(\"/employee\", [firstName: 'FN', lastName: 'LN']) { return id } http.doc.capture('employee-post') http.get(\"/employee/$id\") { firstName.should == 'FN' lastName.should == 'LN' } http.doc.capture('employee-get') // capture previous HTTP call into <docDir>/employee-get } An employee-get directory will be created containing a number of test artifacts."],["HTTP@@documentation@@test-artifacts-location","HTTP","Documentation","Test Artifacts Location","By default, the directory will be created in the current working directory. To change it add docPath to your webtau.cfg.groovy file. url = \"http://localhost:8180\" docPath = \"doc-artifacts\""],["HTTP@@documentation@@test-artifacts","HTTP","Documentation","Test Artifacts","A number of artifacts will be created depending on the exact call being captured. Request and response payloads Request bodies are captured in either request.json , request.pdf or request.data depending on the type.Similarly, response bodies are captured in either response.json , response.pdf or response.data . Request and response headers Just like payloads, request and response headers are captured in request.header.txt and response.header.txt respectively. These files contain a header per line with the name and values colon separated. The values are redacted for any potentially sensitive headers. Response body assertions Any assertions you perform on the response body in your scenarios are captured in a paths.json file. This contains an array with the list of paths within the body whose values were asserted. Request URLs The actual request URL is captured in two forms into two different files: request.fullurl.txt - contains the full URL request.url.txt - contains only the part specified in the http call in the scenario /params?a=1&b=text http://localhost:39673/params?a=1&b=text"],["HTTP@@documentation@@document-rest-calls","HTTP","Documentation","Document REST calls","If you have user facing scenario tests, capture them and refer to them inside your documentation. Set your documentation build pipeline like below.Combine REST requests and responses with Open API generated specs for complete documentation."],["HTTP@@complex-types@@contain","HTTP","Complex Types","Contain","Use contain matcher to test scenarios like search or list of recently created entries. This way you don't have to assume an existing state of your backend under test.Given the response, we want to make sure there is an entry with a specified firstName and lastName . package scenarios.rest.springboot import static org.testingisdocumenting.webtau.WebTauGroovyDsl.* scenario(\"list Customers and assert that it contains a specified entry\") { http.get(\"/customers\") { body.should contain([firstName: 'FN1', lastName: 'LN1']) } }"],["HTTP@@complex-types@@list-of-objects","HTTP","Complex Types","List Of Objects","If you want to make sure that all the values in the list are what you need - use TableData . package scenarios.rest.springboot import static org.testingisdocumenting.webtau.WebTauGroovyDsl.* scenario(\"list Customers and assert with a Table Data\") { http.post(\"/customers\", [firstName: \"FN1\", lastName: \"LN1\"]) http.post(\"/customers\", [firstName: \"FN2\", lastName: \"LN2\"]) http.post(\"/customers\", [firstName: \"FN3\", lastName: \"LN3\"]) http.get(\"/customers?sortBy=firstName\") { body.should == ['firstName' | 'lastName'] { __________________________ 'FN1' | 'LN1' 'FN2' | 'LN2' 'FN3' | 'LN3' } } http.doc.capture('list-match') }"],["HTTP@@complex-types@@order-agnostic-match","HTTP","Complex Types","Order Agnostic Match","Use *key column(s) if list order is not guaranteed package scenarios.rest.springboot import static org.testingisdocumenting.webtau.WebTauGroovyDsl.* scenario(\"list Customers and assert with a Table Data using key column\") { def id1 = createCustomer firstName: \"FN1\", lastName: \"LN1\" def id2 = createCustomer firstName: \"FN2\", lastName: \"LN2\" def id3 = createCustomer firstName: \"FN3\", lastName: \"LN3\" http.get(\"/customers\") { body.should == ['*id' | 'firstName' | 'lastName'] { _________________________________ id2 | 'FN2' | 'LN2' id1 | 'FN1' | 'LN1' id3 | 'FN3' | 'LN3'} } } def createCustomer(Map payload) { return http.post(\"/customers\", payload) { id } }"],["HTTP@@openAPI-spec@@validation","HTTP","OpenAPI Spec","Validation","Webtau supports validation of responses against an https://www.openapis.org/ OpenAPI specification. This feature can be enabled by specifying the openApiSpecUrl configuration option. This should be the URL to the specification against which to validate. url = \"http://localhost:8080\" openApiSpecUrl = \"scenarios/rest/springboot/api-spec.json\""],["HTTP@@openAPI-spec@@current-limitations","HTTP","OpenAPI Spec","Current limitations","OpenAPI specification support is still in its early stage. It is fully functional but there are a few limitations to be aware of:webtau currently only supports OpenAPI specification v2 specification matching is currently done based on the path and method any HTTP requests which do not match any operation in the specification will not fail tests but will produce a warning on the console"],["HTTP@@openAPI-spec@@validations-report","HTTP","OpenAPI Spec","Validations report","The validation errors are reported in the same manner as assertion errors. They are available in the output from the command line webtau runner: bash > executing HTTP POST http://localhost:8080/customers { \"id\": 1, \"firstName\": \"FN\", \"lastName\": \"LN\", \"_links\": { \"self\": { \"href\": \"http://localhost:8080/customers/1\" }, \"customer\": { \"href\": \"http://localhost:8080/customers/1\" } } } X failed executing HTTP POST http://localhost:8080/customers : API spec validation failure: ERROR - Response status 201 not defined for path ''.: [] [x] failed java.lang.AssertionError: API spec validation failure: ERROR - Response status 201 not defined for path ''.: [] at scenarios.rest.springboot.customerCrud$_run_closure1.doCall(customerCrud.groovy:8) at scenarios.rest.springboot.customerCrud$_run_closure1.doCall(customerCrud.groovy) Total: 1, Passed: 0, Skipped: 0, Failed: 1, Errored: 0 They are also available in the HTML report:"],["HTTP@@openAPI-spec@@validation-configuration","HTTP","OpenAPI Spec","Validation Configuration","To ignore additional properties in responses set openApiIgnoreAdditionalProperties to true . As any other config value it can be done via command line, config file or system properties."],["HTTP@@openAPI-spec@@disable-validation","HTTP","OpenAPI Spec","Disable Validation","import org.testingisdocumenting.webtau.openapi.OpenApi OpenApi.withoutValidation { http.post(\"/employee\", [firstName: 'First']) { // ... } } OpenApi.responseOnlyValidation() { http.post(\"/employee\", [firstName: 'First']) { // ... } } OpenApi.requestOnlyValidation() { http.post(\"/employee\", [firstName: 'First', lastName: 'Second']) { // ... } }"],["HTTP@@JSON-schema@@validation","HTTP","JSON Schema","Validation","Webtau supports validation of objects against https://json-schema.org/ JSON Schema. It is possible to validate either the entire body or just a specific field with the complyWithSchema matcher as shown in the two examples below: http.get(\"/weather\") { body.should complyWithSchema('valid-schema.json') } http.get(\"/city/London\") { weather.should complyWithSchema('valid-schema.json') } Both examples above validate against the following schema:"],["HTTP@@JSON-schema@@error-messages","HTTP","JSON Schema","Error messages","Using the first example above, an invalid schema will generate an error similar to: invalid schema (examples/scenarios/rest/jsonSchema/validateSchema.groovy) > executing HTTP GET http://localhost:8080/weather X failed expecting body to comply with schema invalid-schema.json : body expected to comply with schema invalid-schema.json [#: required key [anotherField] not found, #/temperature: expected type: Boolean, found: Integer] { \"temperature\": 88 } The schema used in validation to generate this error is as follows:"],["HTTP@@JSON-schema@@configuration","HTTP","JSON Schema","Configuration","The path to the schema file specified in complyWithSchema can be relative or absolute. If it's relative, it'll be relative to the jsonSchemasDir specified in configuration and if not specified then relative to working directory. For example: url = \"http://localhost:8180\" jsonSchemasDir = 'schemas'"],["HTTP@@report@@location","HTTP","Report","Location","By default report is generated at <workingdir>/webtau.report.html . To change the location use --reportPath option."],["HTTP@@report@@summary","HTTP","Report","Summary","Out of the box report provides high level information like number of failed tests and HTTP Operations coverage."],["HTTP@@report@@test-summary","HTTP","Report","Test Summary","Selected test to see a summary information about test run"],["HTTP@@report@@navigation","HTTP","Report","Navigation","Report is a self contained single page application. Url tracks your navigation through screens, so you can share url with your teammates to narrow down a problem."],["HTTP@@report@@additional-reports","HTTP","Report","Additional Reports","To generate custom reports or upload report data to your server, specify a reportGenerator config property. url = \"http://localhost:8080\" reportGenerator = Report.&generateReport Where Report.&generateReport is implemented as following package scenarios.rest.report import org.testingisdocumenting.webtau.console.ConsoleOutputs import org.testingisdocumenting.webtau.console.ansi.Color import org.testingisdocumenting.webtau.reporter.WebTauReport import static org.testingisdocumenting.webtau.WebTauDsl.cfg class Report { static void generateReport(WebTauReport report) { def reportPath = cfg.workingDir.resolve('report.txt') ConsoleOutputs.out('generating report: ', Color.PURPLE, reportPath) reportPath.toFile().text = report.tests.size() } }"],["HTTP@@maven@@dependency","HTTP","Maven","Dependency","You can use maven to add webtau as a dependency to you project (for autocompletion or to use with JUnit like runners). Groovy <dependency> <groupId>org.testingisdocumenting.webtau</groupId> <artifactId>webtau-groovy</artifactId> <version>1.41</version> </dependency> Java <dependency> <groupId>org.testingisdocumenting.webtau</groupId> <artifactId>webtau</artifactId> <version>1.41</version> </dependency>"],["HTTP@@maven@@plugin","HTTP","Maven","Plugin","Use maven plugin to run pure groovy tests as part of your build. <plugin> <groupId>org.testingisdocumenting.webtau</groupId> <artifactId>webtau-maven-plugin</artifactId> <version>1.41</version> <executions> <execution> <phase>test</phase> <goals> <goal>run</goal> </goals> </execution> </executions> <configuration> <workingDir>${project.basedir}/src/main/groovy</workingDir> <env>integration</env> <url>http://optional-base-url</url> <tests> <directory>${project.basedir}/src/main/groovy</directory> <includes> <include>scenarios/simple*.groovy</include> </includes> </tests> </configuration> </plugin> Use env to specify configuration/environments environment to use. Alternatively you can use url to override base url."],["HTTP@@matchers@@imports-to-use","HTTP","Matchers","Imports to use","import static org.testingisdocumenting.webtau.WebTauGroovyDsl.*"],["HTTP@@matchers@@response-mapping","HTTP","Matchers","Response Mapping","Identifiers inside validation closure are automatically mapped to a response body. Groovy http.get(\"/end-point-simple-object\") { k1.should == 'v1' } Java http.get(\"/end-point-simple-object\", (header, body) -> { body.get(\"k1\").should(equal(\"v1\")); }); List responses are handled by using index chain Groovy http.get(\"/end-point-simple-list\") { body[0].k1.should == 'v1' } Note: Groovy API implicitly assumes body , but if you need to deal with array response you need to access values using body explicitly. Java http.get(\"/end-point-simple-list\", (header, body) -> { body.get(0).get(\"k1\").should(equal(\"v1\")); });"],["HTTP@@matchers@@should-and-should-not","HTTP","Matchers","Should and Should Not","Matchers in webtau are triggered with should and shouldNot keywords. Additionally shouldBe and shouldNotBe alias keywords are available to make certain matcher combinations easier to read. Groovy http.get(\"/example\") { year.shouldNot == 2000 year.should != 2000 // alternative shortcut genres.should contain('RPG') rating.shouldBe > 7 } Java http.get(\"/example\", (header, body) -> { body.get(\"year\").shouldNot(equal(2000)); body.get(\"genres\").should(contain(\"RPG\")); body.get(\"rating\").shouldBe(greaterThan(7)); });"],["HTTP@@matchers@@equality","HTTP","Matchers","Equality","Webtau defines its own set of equality rules to simplify testing. Groovy http.get(\"/end-point\") { id.should != 0 amount.should == 30 list.should == [1, 2, 3] object.k1.should == ~/v\\d/ // regular expression matching object.should == [k1: 'v1', k3: 'v3'] // matching only specified fields and can be nested multiple times complexList.should == [\"k1\" | \"k2\"] { // matching only specified fields, but number of entries must be exact ________________ \"v1\" | 30 \"v11\" | 40 } } Java http.get(\"/end-point\", (header, body) -> { body.get(\"id\").shouldNot(equal(0)); body.get(\"amount\").should(equal(30)); body.get(\"list\").should(equal(Arrays.asList(1, 2, 3))); body.get(\"object\").get(\"k1\").should(equal( Pattern.compile(\"v\\\\d\"))); // regular expression matching body.get(\"object\").should(equal(aMapOf( \"k1\", \"v1\", \"k3\", \"v3\"))); // matching only specified fields and can be nested multiple times body.get(\"complexList\").should(equal(table(\"k1\" , \"k2\", // matching only specified fields, but number of entries must be exact ________________, \"v1\" , 30, \"v11\", 40))); }); Groovy http.get(\"/end-point\") { complexList.should == [ \"*id\" | \"k1\" | \"k2\"] { // order agnostic key based match ________________________ \"id2\" | \"v11\" | 40 \"id1\" | \"v1\" | 30 } } Java http.get(\"/end-point\", (header, body) -> { body.get(\"complexList\").should(equal(table(\"*id\", \"k1\" , \"k2\", // order agnostic key based match ________________, \"id2\", \"v11\", 40, \"id1\", \"v1\" , 30))); });"],["HTTP@@matchers@@greaterlessequal","HTTP","Matchers","Greater/Less/Equal","Use greaterThan , greaterThanOrEqual , lessThan , and lessThanOrEqual to assert numeric values. Groovy http.get(\"/end-point-numbers\") { id.shouldBe > 0 price.shouldBe >= 100 amount.shouldBe < 150 list[1].shouldBe <= 2 id.shouldNotBe <= 0 price.shouldNotBe < 100 amount.shouldNotBe >= 150 list[1].shouldNotBe > 2 } Note: Groovy can use shortcuts > , >= , < , <= . Java http.get(\"/end-point-numbers\", (header, body) -> { body.get(\"id\").shouldBe(greaterThan(0)); body.get(\"price\").shouldBe(greaterThanOrEqual(100)); body.get(\"amount\").shouldBe(lessThan(150)); body.get(\"list\").get(1).shouldBe(lessThanOrEqual(2)); body.get(\"id\").shouldNotBe(lessThanOrEqual(0)); body.get(\"price\").shouldNotBe(lessThan(100)); body.get(\"amount\").shouldNotBe(greaterThanOrEqual(150)); body.get(\"list\").get(1).shouldNotBe(greaterThan(2)); });"],["HTTP@@matchers@@contain","HTTP","Matchers","Contain","Use contain when you cannot rely on order of values in a response. Groovy http.get(\"/end-point-list\") { body.should contain([k1: 'v1', k2: 'v2']) body[1].k2.shouldNot contain(22) } Java http.get(\"/end-point-list\", (header, body) -> { body.should(contain(aMapOf( \"k1\", \"v1\", \"k2\", \"v2\"))); body.get(1).get(\"k2\").shouldNot(contain(22)); });"],["HTTP@@matchers@@contain-all","HTTP","Matchers","Contain All","Use containAll when you cannot rely on order of values in a response and need to check more than one value. Groovy http.get(\"/end-point-list\") { body[1].k2.should containAll(10, 30) body[1].k2.shouldNot containAll(40, 60, 80) } Java http.get(\"/end-point-list\", (header, body) -> { body.get(1).get(\"k2\").should(containAll(10, 30)); body.get(1).get(\"k2\").shouldNot(containAll(40, 60, 80)); });"],["HTTP@@matchers@@nested-contain-all","HTTP","Matchers","Nested Contain All","Use containingAll alias to make it easier to read containAll matcher nested inside contain . Groovy http.get(\"/prices\") { body.prices.should contain(containingAll(10, 30)) } Java http.get(\"/prices\", (header, body) -> { body.get(\"prices\").should(contain(containingAll(10, 30))); });"],["HTTP@@matchers@@date-and-time","HTTP","Matchers","Date and Time","You can assert actual string against LocalDate and ZonedDateTime . String will be automatically converted using ISO formatter. Groovy http.get(\"/end-point-dates\") { def expectedDate = LocalDate.of(2018, 6, 12) def expectedTime = ZonedDateTime.of(expectedDate, LocalTime.of(9, 0, 0), ZoneId.of(\"UTC\")) tradeDate.should == expectedDate transactionTime.should == expectedTime transactionTime.shouldBe >= expectedDate paymentSchedule.should contain(expectedDate) } Java http.get(\"/end-point-dates\", (header, body) -> { LocalDate expectedDate = LocalDate.of(2018, 6, 12); ZonedDateTime expectedTime = ZonedDateTime.of(expectedDate, LocalTime.of(9, 0, 0), ZoneId.of(\"UTC\")); body.get(\"tradeDate\").should(equal(expectedDate)); body.get(\"transactionTime\").should(equal(expectedTime)); body.get(\"transactionTime\").shouldBe(greaterThanOrEqual(expectedDate)); body.get(\"paymentSchedule\").should(contain(expectedDate)); });"],["HTTP@@matchers@@mixing-matchers","HTTP","Matchers","Mixing Matchers","You can use matchers in place of expected values to build a more complex expectation. Groovy http.get(\"/end-point-mixed\") { list.should contain(lessThanOrEqual(2)) // lessThanOrEqual will be matched against each value object.should == [k1: 'v1', k3: ~/v\\d/] // regular expression match against k3 complexList[0].should == [k1: 'v1', k2: lessThan(120)] // lessThen match against k2 complexList[1].should == [ k1: notEqual('v1'), // any value but v1 k2: greaterThanOrEqual(120)] complexList.should == [\"k1\" | \"k2\"] { ___________________________ ~/v\\d/ | lessThan(120) \"v11\" | greaterThan(150) } // using matchers as cell values } Java Pattern withNumber = Pattern.compile(\"v\\\\d\"); http.get(\"/end-point-mixed\", (header, body) -> { body.get(\"list\").should(contain(lessThanOrEqual(2))); // lessThanOrEqual will be matched against each value body.get(\"object\").should(equal(aMapOf( \"k1\", \"v1\", \"k3\", withNumber))); // regular expression match against k3 body.get(\"complexList\").get(0).should(equal(aMapOf( \"k1\", \"v1\", \"k2\", lessThan(120)))); // lessThen match against k2 body.get(\"complexList\").get(1).should(equal(aMapOf( \"k1\", notEqual(\"v1\"), // any value but v1 \"k2\", greaterThanOrEqual(120)))); TableData expected = table(\"k1\" , \"k2\", // matching only specified fields, but number of entries must be exact ________________________________, withNumber , lessThan(120), \"v11\" , greaterThan(150)); body.get(\"complexList\").should(equal(expected)); });"],["GraphQL@@introduction@@","GraphQL","Introduction","","The Webtau graphql. module lets you exercise and validate a GraphQL API. It provides a simplified way to access the JSON response of an end-point and provides a DSL to execute queries and mutations. Groovy package scenarios.rest import static org.testingisdocumenting.webtau.WebTauGroovyDsl.* scenario(\"check weather\") { def query = \"{ weather { temperature } }\"; graphql.execute(query) { weather.temperature.shouldBe < 100 } } package com.example.tests.junit4 import org.junit.Test import org.junit.runner.RunWith import org.testingisdocumenting.webtau.junit4.WebTauRunner import static org.testingisdocumenting.webtau.WebTauDsl.graphql @RunWith(WebTauRunner.class) class GraphQLWeatherGroovyIT { @Test void checkWeather() { def query = \"{ weather { temperature } }\"; graphql.execute(query) { weather.temperature.shouldBe < 100 } } } json { \"data\": { \"weather\": { \"temperature\": 88 } } } Java package com.example.tests.junit4; import org.junit.Test; import org.junit.runner.RunWith; import org.testingisdocumenting.webtau.junit4.WebTauRunner; import static org.testingisdocumenting.webtau.WebTauDsl.*; @RunWith(WebTauRunner.class) public class GraphQLWeatherJavaIT { @Test public void checkWeather() { String query = \"{ weather { temperature } }\"; graphql.execute(query, (header, body) -> { body.get(\"data.weather.temperature\").shouldBe(lessThan(100)); }); } } json { \"data\": { \"weather\": { \"temperature\": 88 } } } Before diving further into writing tests for your GraphQL server, please read through the HTTP testing documentation starting with the HTTP/data-node Data node page as much of the same core principles apply to GraphQL also.The main GraphQL specific features are covered in the subsequent pages: GraphQL/queries-and-mutations Queries and Mutations GraphQL/customized-graphql-urls Customized GraphQL URLs GraphQL/report Report"],["GraphQL@@queries-and-mutations@@executing-queries-and-mutations","GraphQL","Queries And Mutations","Executing Queries and Mutations","Webtau follows GraphQL's https://graphql.org/learn/serving-over-http/ Serving over HTTP best practices when invoking GraphQL servers over HTTP.It therefore assumes the server responds to requests to /graphql so you do not need to specify that in the URL in your configuration. Requests allow providing:a query/mutation string variables an operation name Webtau will default to issuing POST requests according to the https://graphql.org/learn/serving-over-http/#post-request best practices and will expect a 200 status code and a response with a data or errors field.The following example demonstrates most of these query features: package scenarios.graphql import static org.testingisdocumenting.webtau.WebTauGroovyDsl.* def listAllQuery = ''' { allTasks(uncompletedOnly: false) { id description } } ''' def taskByIdQuery = ''' query taskById($id: ID!) { taskById(id: $id) { id description completed } } ''' def completeMutation = ''' mutation complete($id: ID!) { complete(id: $id) } ''' scenario(\"list all tasks\") { graphql.execute(listAllQuery) { // Execute a simple query with no variables errors.should == null // Validate there were no errors body.data.allTasks.id.should == [\"a\", \"b\", \"c\"] // Access response data with the full path allTasks.id.should == [\"a\", \"b\", \"c\"] // Access response data via a shortcut allowing omitting of `body.data` id.should == [\"a\", \"b\", \"c\"] // For single query requests, access response data via a shortcut allowing omitting of `body.data` and the query name } } scenario(\"complete a task\") { graphql.execute(completeMutation, [id: \"a\"]) { // Execute a mutation with a variables map errors.should == null complete.should == true } graphql.execute(taskByIdQuery, [id: \"a\"]) { errors.should == null taskById.id.should == \"a\" taskById.completed.should == true } } scenario(\"cannot complete a completed task\") { graphql.execute(completeMutation, [id: \"b\"]) { // Execute a mutation with a variables map errors.should == null complete.should == true } graphql.execute(completeMutation, [id: \"b\"]) { // force an error errors[0].message.shouldNot == null complete.should == null } }"],["GraphQL@@queries-and-mutations@@response-assertions","GraphQL","Queries And Mutations","Response Assertions","Response assertions follow a similar pattern to REST APIs.For Groovy specifically, there are shortcuts for accessing data in the response directly as demonstrated in the example above. You may access errors directly via errors or fields in the response directly with the field names, omitting the data field."],["GraphQL@@customized-graphql-urls@@customizing-the-graphql-endpoint","GraphQL","Customized Graphql Urls","Customizing the GraphQL Endpoint","By default, webtau assumes that all requests are made to a /graphql endpoint. The config value graphQLEndpoint can be set to use a non-standard endpoint, e.g. graphQLEndpoint=/api/graphql .Webtau also decorates the query with a (typically ignored) query parameter that contains the request's operationName , e.g. /graphql?operation=myOperation . This makes execution logs as well as webtau's step reports easier to read and debug, especially since the operation's name is part of the request's payload and is usually not logged by request loggers. If you want to turn this feature off, set the config value for graphQLShowOperationAsQueryParam to false .In order to customize the graphQL URL in different ways, you need to implement a GraphQLHttpConfiguration and ensure it gets loaded at runtime via the Java ServiceLoader.Here is an example in groovy: package org.testingisdocumenting.webtau.graphql import org.testingisdocumenting.webtau.graphql.config.GraphQLHttpConfiguration import org.testingisdocumenting.webtau.graphql.model.GraphQLRequest class CustomGraphQLHttpConfiguration implements GraphQLHttpConfiguration { // Note: our test server requires the graphql endpoint to start with \"graphql\" public static final CUSTOM_GRAPHQL_ENDPOINT = 'graphql-custom' @Override String requestUrl(String url, GraphQLRequest graphQLRequest) { if (null != graphQLRequest.operationName && !graphQLRequest.operationName.isEmpty()) { return \"${CUSTOM_GRAPHQL_ENDPOINT}?operation=${graphQLRequest.operationName}\" } return url } }"],["GraphQL@@report@@additional-reports","GraphQL","Report","Additional Reports","To generate custom reports or upload report data to your server, specify a reportGenerator config property. package scenarios.graphql url = \"http://localhost:8180\" graphQLIgnoreIntrospectionFailures = false reportGenerator = Report.&generateReport Where Report.&generateReport is implemented as follows: package scenarios.graphql import org.testingisdocumenting.webtau.console.ConsoleOutputs import org.testingisdocumenting.webtau.console.ansi.Color import org.testingisdocumenting.webtau.report.ReportDataProviders import org.testingisdocumenting.webtau.reporter.WebTauReport import org.testingisdocumenting.webtau.utils.JsonUtils import static org.testingisdocumenting.webtau.WebTauDsl.cfg class Report { static void generateReport(WebTauReport report) { def additionalData = [:] ReportDataProviders.provide(report.tests) .map { it.toMap() } .forEach { additionalData.putAll(it) } def reportData = [:] reportData.graphQLSkippedQueries = additionalData.graphQLSkippedQueries // All queries present in the GraphQL schema but not tested reportData.graphQLCoveredQueries = additionalData.graphQLCoveredQueries // All queries present in the GraphQL schema and tested reportData.graphQLCoverageSummary = additionalData.graphQLCoverageSummary // Summary of test coverage compared to the GraphQL schema reportData.graphQLQueryTimeStatistics = additionalData.graphQLQueryTimeStatistics // Summary of timing by query reportData.graphQLCoveredSuccessBranches = additionalData.graphQLCoveredSuccessBranches // All queries present in the GraphQL schema that were hit with a success result reportData.graphQLSkippedSuccessBranches = additionalData.graphQLSkippedSuccessBranches // All queries present in the GraphQL schema but not hit with a success result reportData.graphQLCoveredErrorBranches = additionalData.graphQLCoveredErrorBranches // All queries present in the GraphQL schema that were hit with an error result reportData.graphQLSkippedErrorBranches = additionalData.graphQLSkippedErrorBranches // All queries present in the GraphQL schema but not hit with an error result def reportPath = cfg.workingDir.resolve('webtau.graphql-report.json') ConsoleOutputs.out('generating report: ', Color.PURPLE, reportPath) reportPath.toFile().text = JsonUtils.serializePrettyPrint(reportData) } } The output looks as follows: { \"graphQLSkippedQueries\" : [ { \"name\" : \"uncomplete\", \"type\" : \"mutation\" }, { \"name\" : \"taskById\", \"type\" : \"query\" }, { \"name\" : \"allTasks\", \"type\" : \"query\" }, { \"name\" : \"complete\", \"type\" : \"mutation\" } ], \"graphQLCoveredQueries\" : [ { \"name\" : \"weather\", \"type\" : \"query\" } ], \"graphQLCoverageSummary\" : { \"coverage\" : 0.2, \"branchCoverage\" : 0.1, \"types\" : { \"mutation\" : { \"coverage\" : 0.0, \"declaredQueries\" : 2, \"coveredQueries\" : 0.0 }, \"query\" : { \"coverage\" : 0.3333333333333333, \"declaredQueries\" : 3, \"coveredQueries\" : 1.0 } }, \"successBranchCoverage\" : 0.2, \"errorBranchCoverage\" : 0.0, \"totalDeclaredQueries\" : 5.0, \"totalCoveredQueries\" : 1.0 }, \"graphQLQueryTimeStatistics\" : [ { \"name\" : \"weather\", \"type\" : \"query\", \"statistics\" : { \"mean\" : 3.0, \"min\" : 3, \"max\" : 3, \"count\" : 1, \"p95\" : 3.0, \"p99\" : 3.0 } } ], \"graphQLCoveredSuccessBranches\" : [ { \"name\" : \"weather\", \"type\" : \"query\" } ], \"graphQLSkippedSuccessBranches\" : [ { \"name\" : \"uncomplete\", \"type\" : \"mutation\" }, { \"name\" : \"taskById\", \"type\" : \"query\" }, { \"name\" : \"allTasks\", \"type\" : \"query\" }, { \"name\" : \"complete\", \"type\" : \"mutation\" } ], \"graphQLCoveredErrorBranches\" : [ ], \"graphQLSkippedErrorBranches\" : [ { \"name\" : \"weather\", \"type\" : \"query\" }, { \"name\" : \"uncomplete\", \"type\" : \"mutation\" }, { \"name\" : \"taskById\", \"type\" : \"query\" }, { \"name\" : \"allTasks\", \"type\" : \"query\" }, { \"name\" : \"complete\", \"type\" : \"mutation\" } ] } Coverage and Timing Statistics Webtau will implicitly invoke your GraphQL server's introspection queries in order to fetch a subset of the schema. It uses this schema in conjunction with the requests in tests to compute:query coverage - which queries were invoked by tests and which were not as well as an overall summary of coverage timing information - http call timing statistics by query"],["browser@@introduction@@","Browser","Introduction","","Webtau browser. module lets you interact with a browser. It provides higher level abstractions to locate elements, encapsulate page implementation details and deal with async nature of modern UIs. Groovy package scenarios.ui import static org.testingisdocumenting.webtau.WebTauGroovyDsl.* import static pages.Pages.* scenario(\"search by specific query\") { search.submit(\"search this\") search.numberOfResults.waitToBe > 1 } package pages import static org.testingisdocumenting.webtau.WebTauDsl.* class SearchPage { def header = $(\"#header\") def welcomeMessage = $(\"#welcome\") def searchMessage = $(\"#message\") def box = $(\"#search-box\") def results = $(\"#results .result\") def numberOfResults = results.count def submit(query) { browser.open(\"/search\") box.setValue(query) box.sendKeys(browser.keys.enter) } } package pages class Pages { static final def search = new SearchPage() } Java package com.example.tests.junit5; import org.junit.jupiter.api.Test; import org.testingisdocumenting.webtau.junit5.WebTau; import static com.example.tests.junit5.pages.Pages.*; import static org.testingisdocumenting.webtau.WebTauDsl.*; @WebTau public class WebSearchJavaTest { @Test public void searchByQuery() { search.submit(\"search this\"); search.numberOfResults.waitToBe(greaterThan(1)); } } package com.example.tests.junit5.pages; import org.testingisdocumenting.webtau.browser.page.PageElement; import org.testingisdocumenting.webtau.browser.page.PageElementValue; import static org.testingisdocumenting.webtau.WebTauDsl.*; public class SearchPage { private final PageElement box = $(\"#search-box\"); private final PageElement results = $(\"#results .result\"); public final PageElementValue<Integer> numberOfResults = results.getCount(); public void submit(String query) { browser.open(\"/search\"); box.setValue(query); box.sendKeys(browser.keys.enter); } } package com.example.tests.junit5.pages; public class Pages { public static SearchPage search = new SearchPage(); }"],["browser@@basic-configuration@@base-url","Browser","Basic Configuration","Base URL","Robust tests don't specify the full URL of an application under test. Instead you only pass a relative URL to functions like open . package scenarios.ui import static org.testingisdocumenting.webtau.WebTauGroovyDsl.* scenario('simple open') { browser.open(\"/search\") $('#welcome').should == 'welcome to super search' } Define base URL either inside a webtau.cfg.groovy file url = \"http://localhost:8180\" or pass as a command line argument --url=http://..."],["browser@@basic-configuration@@browser-only-base-url","Browser","Basic Configuration","Browser Only Base URL","When you use url parameter you set base url for both REST and UI testing.Use browserUrl to specify UI only base url. This can be handy when your backend and frontend live separately."],["browser@@basic-configuration@@browser-id","Browser","Basic Configuration","Browser Id","Use browserId via command line, or a config file parameter to specify which browser to use. webtau --browserId=firefox Note: Default browserId is chrome"],["browser@@page-element-and-value@@element-selection","Browser","Page Element And Value","Element Selection","Use $('css-selector') to select a page element. groovy $('#element-id') groovy $('.label') groovy $('[data-test-id=\"my-id\"]') browser/finders-and-filters Read Finders And Filters to learn how to select elements using more advanced techniques. https://www.w3schools.com/cssref/css_selectors.asp Read W3Schools CSS selectors to learn all kind of CSS selection techniques."],["browser@@page-element-and-value@@lazy-element","Browser","Page Element And Value","Lazy Element","When you use $('css-selector') you create an instance of PageElement . PageElement represent an element that is present or will be present on a web page. It is safe to declare an element before you open a browser or navigate to the page you need to test. package scenarios.ui import static org.testingisdocumenting.webtau.WebTauGroovyDsl.* def welcomeMessage = $('#welcome') scenario('simple open') { browser.open(\"/search\") welcomeMessage.should == 'welcome to super search' }"],["browser@@page-element-and-value@@lazy-value","Browser","Page Element And Value","Lazy Value","Consider a simple search page. Enter value, hit enter, see results.Here is simple test. package scenarios.ui import static org.testingisdocumenting.webtau.WebTauGroovyDsl.* scenario('search by specific query') { browser.open('/search') $('#search-box').setValue('search this') $('#search-box').sendKeys(\"\\n\") $('#results .result').count.shouldBe > 1 } In the example $('#results .result').count represents the number of elements matching the css selector. Let's extract it. package scenarios.ui import static org.testingisdocumenting.webtau.WebTauGroovyDsl.* def searchBox = $('#search-box') def numberOfResults = searchBox.count scenario('search by specific query') { browser.open('/search') searchBox.setValue('search this') searchBox.sendKeys(\"\\n\") numberOfResults.shouldBe > 1 }"],["browser@@page-object@@test-encapsulation","Browser","Page Object","Test Encapsulation","Robust tests should not depend on implementation details. UI has plenty of those:UI Elements placement Actions UI test should not depend on any of them. Move elements placement and available actions outside of UI test. Multiple tests can then reuse that information. And more importantly you will have only one place to change if UI changes."],["browser@@page-object@@definition","Browser","Page Object","Definition","To define PageObject create a class. package pages import static org.testingisdocumenting.webtau.WebTauDsl.* class SearchPage { def header = $(\"#header\") def welcomeMessage = $(\"#welcome\") def searchMessage = $(\"#message\") def box = $(\"#search-box\") def results = $(\"#results .result\") def numberOfResults = results.count def submit(query) { browser.open(\"/search\") box.setValue(query) box.sendKeys(browser.keys.enter) } }"],["browser@@page-object@@grouping","Browser","Page Object","Grouping","To make it easier to refer PageObjects from different tests combine them in one file package pages class Pages { static final def search = new SearchPage() static final def calculation = new CalculationPage() static final def form = new FormPage() static final def payments = new PaymentsPage() } Use static import to have seamless access to all of them package scenarios.ui import static org.testingisdocumenting.webtau.WebTauGroovyDsl.* import static pages.Pages.* scenario(\"search by specific query\") { search.submit(\"search this\") search.numberOfResults.should == 2 }"],["browser@@element-actions@@clicks","Browser","Element Actions","Clicks","payments.confirmation.click() expandArea.doubleClick() paymentsTable.rightClick() payments.confirmation.shiftClick() payments.confirmation.altClick() payments.confirmation.controlClick() payments.confirmation.commandClick() payments.confirmation.commandOrControlClick()"],["browser@@element-actions@@modifications","Browser","Element Actions","Modifications","payments.dollarAmount.clear() payments.dollarAmount.sendKeys(\"104.5\") Generic way to set a form element value. Will be covered more in browser/forms forms payments.dollarAmount.setValue(\"104.5\")"],["browser@@element-actions@@move-over","Browser","Element Actions","Move over","menu.hover()"],["browser@@element-actions@@drag-and-drop","Browser","Element Actions","Drag And Drop","def draggable = $(\"#draggable\") def dropZone = $(\"#drop-zone\") draggable.dragAndDropOver(dropZone)"],["browser@@forms@@universal-set-value","Browser","Forms","Universal Set Value","Use setValue on a declared page element to set its value. It will work on all the standard input types out of the box.Define all the input fields inside a page object. In combination with universal setValue it will make your tests robust.Given a html snippet <html> <body> <div id=\"form\"> <input id=\"name\" /> <input id=\"startDate\" type=\"date\" /> <input id=\"confirmation\" type=\"checkbox\" /> <div id=\"choice-group\" class=\"radio-group\"> <div> <input type=\"radio\" id=\"one\" name=\"choice\" value=\"value-one\"/> <label for=\"one\">one</label> </div> <div> <input type=\"radio\" id=\"two\" name=\"choice\" value=\"value-two\"/> <label for=\"two\">two</label> </div> <div> <input type=\"radio\" id=\"three\" name=\"choice\" value=\"value-three\"/> <label for=\"three\">three</label> </div> </div> <select id=\"rank\"> <option /> <option value=\"A\">A</option> <option value=\"B\">B</option> <option value=\"C\">C</option> <option value=\"D\">D</option> <option value=\"E\">E</option> </select> </div> </body> </html> Page object can be defined as package pages import static org.testingisdocumenting.webtau.WebTauDsl.* class FormPage { def name = $('#name') def rank = $('#rank') def confirmation = $('#confirmation') def choice = $('[name=\"choice\"]') def startDate = $('#startDate') }"],["browser@@forms@@default-input","Browser","Forms","Default Input","form.name.setValue('Full Automation')"],["browser@@forms@@date-input","Browser","Forms","Date Input","form.startDate.setValue('2016-06-21')"],["browser@@forms@@select","Browser","Forms","Select","form.rank.setValue('B')"],["browser@@forms@@checkbox","Browser","Forms","CheckBox","form.confirmation.setValue(true)"],["browser@@forms@@radio-button","Browser","Forms","Radio Button","form.choice.setValue('value-two')"],["browser@@forms@@universal-assert","Browser","Forms","Universal Assert","Form element value can be asserted the same way as any regular element. Underlying value will be extracted based on the element type form.name.should == 'Full Automation' form.rank.should == 'B' form.confirmation.should == true form.choice.should == 'value-two' form.startDate.should == '2016-06-21'"],["browser@@forms@@custom-form-elements","Browser","Forms","Custom Form Elements","One of the benefits of universal set and assert is that your test is focused on the data and not implementation details. But what if you decided to use a custom component to enter the data?To hide implementation details from your test you should define a custom input handler for your UI component.Let's consider a form component that you can start interacting with only after you clicked it. And after the value is entered, the input box disappears again. <div id=\"answer\" class=\"special-selector\" onclick=\"activate('answer')\"> <div class=\"current-value\"> current value </div> <input class=\"value-input\" value=\"\" onblur=\"valueEntered('answer')\"> </div> Our test should still be written in terms of data entering and validation. def customFormElement = $('#answer') customFormElement.setValue('hello') customFormElement.should == 'hello' In order to achieve this we need to register a custom handler. package scenarios.ui import static org.testingisdocumenting.webtau.WebTauGroovyDsl.* scenario('open forms') { browser.open('/special-forms') } scenario('get set custom based on registered handler') { def customFormElement = $('#answer') customFormElement.setValue('hello') customFormElement.should == 'hello' } package formHandlers import org.openqa.selenium.Keys import org.testingisdocumenting.webtau.browser.page.HtmlNode import org.testingisdocumenting.webtau.browser.page.HtmlNodeAndWebElementList import org.testingisdocumenting.webtau.browser.page.PageElement import org.testingisdocumenting.webtau.browser.page.PageElementStepExecutor import org.testingisdocumenting.webtau.browser.handlers.PageElementGetSetValueHandler import org.testingisdocumenting.webtau.reporter.TokenizedMessage class CustomInput implements PageElementGetSetValueHandler { @Override boolean handles(HtmlNodeAndWebElementList htmlNodeAndWebElements, PageElement pageElement) { def htmlNode = htmlNodeAndWebElements.firstHtmlNode() return htmlNode.attributes.class =~ /special-selector/ } @Override void setValue(PageElementStepExecutor stepExecutor, TokenizedMessage pathDescription, HtmlNodeAndWebElementList htmlNodeAndWebElements, PageElement pageElement, Object value) { pageElement.click() pageElement.find('input').sendKeys(\"${value}\" + Keys.TAB) } @Override Object getValue(HtmlNodeAndWebElementList htmlNodeAndWebElements, PageElement pageElement, int idx) { return pageElement.find('.current-value').getUnderlyingValue() } }"],["browser@@asynchronous-page@@synchronization","Browser","Asynchronous Page","Synchronization","Many actions in a modern web page are asynchronous. User presses a button and a moment later a result appears. In modern web pages there is no full page reload and only a portion of a page will be changed.If a test will try to assert a value after a user action, chances are assertion will fail since it will take time for a result to appear on a page.Question: How do users know that their action is done and they can move on?"],["browser@@asynchronous-page@@visiblehidden-element","Browser","Asynchronous Page","Visible/Hidden Element","One way to deal with asynchronous pages is to wait for a feedback to appear or disappear. calculation.start() calculation.feedback.waitTo beVisible() calculation.results.should == [100, 230]"],["browser@@asynchronous-page@@enableddisabled-element","Browser","Asynchronous Page","Enabled/Disabled Element","Disabled input box and buttons can be used as a user feedback as well. calculation.open() calculation.input.waitTo beEnabled() calculation.input.setValue(100)"],["browser@@asynchronous-page@@wait-to-match","Browser","Asynchronous Page","Wait to match","If presence/absence of an element is not important, you can directly to wait for a matcher to match. calculation.start() calculation.results.waitTo == [100, 230] Note: any matcher that you can use with should and shouldNot can be used with waitTo and waitToNot"],["browser@@asynchronous-page@@wait-on-url","Browser","Asynchronous Page","Wait on url","Another cue to use could be a url change after an action. browser.open('/resource-creation') $('#new').click() browser.url.ref.waitTo == 'created-id' Note: url exposes other parts that you can browser/navigation#assert-url read more about here"],["browser@@documentation-artifacts@@scenarios","Browser","Documentation Artifacts","Scenarios","To document how to use a User Interface we often take screenshots and annotate them. At the same time we need to make sure that documented scenario works as advertised.With UI testing we can validate scenarios and at the same time capture screenshots with automatically placed annotations."],["browser@@documentation-artifacts@@capturing-screenshots-with-annotations","Browser","Documentation Artifacts","Capturing Screenshots With Annotations","To capture screenshots use browser.doc[.withAnnotations].capture : search.submit(\"search this\") browser.doc.withAnnotations( browser.doc.badge(search.box), browser.doc.badge(search.results)).capture('search') The result of the capture command is two files: actual screenshot and search.json . { \"shapes\" : [ { \"id\" : \"badge13\", \"type\" : \"badge\", \"text\" : \"1\", \"color\" : \"a\", \"darkFriendly\" : false, \"x\" : 120, \"y\" : 84, \"align\" : \"Center\" }, { \"id\" : \"badge14\", \"type\" : \"badge\", \"text\" : \"2\", \"color\" : \"a\", \"darkFriendly\" : false, \"x\" : 494, \"y\" : 177, \"align\" : \"Center\" } ], \"pixelRatio\" : 1 } https://testingisdocumenting.org/webtau Webtau documentation site is generated using https://github.com/testingisdocumenting/znai Znai. It has include-image plugin that supports annotations format generated by capture command. :include-image: doc-artifacts/search.png {fit: true, annotationsPath: \"doc-artifacts/search.json\"}"],["browser@@documentation-artifacts@@annotation-types","Browser","Documentation Artifacts","Annotation Types","search.submit(\"search this\") browser.doc.withAnnotations( browser.doc.badge(search.box), browser.doc.badge(search.results)).capture('search') browser.doc.withAnnotations( browser.doc.highlight(search.box), browser.doc.cover(search.results, \"covering text\")).capture('search-highlight-cover')"],["browser@@documentation-artifacts@@annotation-placement","Browser","Documentation Artifacts","Annotation Placement","Use above , below , toTheLeft and toTheRight to put an annotation outside of element center. search.submit(\"search this\") browser.doc.withAnnotations( browser.doc.badge(search.box).toTheRight(), browser.doc.badge(search.results).above()).capture('search-diff-placement')"],["browser@@documentation-artifacts@@inverted-colors","Browser","Documentation Artifacts","Inverted Colors","By default, annotation colors assume light theme of an UI you document. Use invertedColors() to change an annotation color to be dark theme compatible. search.submit(\"search this\") browser.doc.withAnnotations( browser.doc.badge(search.header).invertedColors(), browser.doc.badge(search.box)).capture('search-inverted-colors') To change all annotations to be dark theme compatible by default, use webtau config file browserAnnotationsDarkFriendly = true In this case invertedColors will flip from light annotations to dark one browser.doc.withAnnotations( browser.doc.badge(search.header), browser.doc.badge(search.results).invertedColors()).capture('search-inverted-colors-from-config')"],["browser@@advanced-configuration@@timeouts","Browser","Advanced Configuration","Timeouts","Default timeout in milliseconds for waitTo and waitToNot waitTimeout = 25000 --waitTimeout=25000"],["browser@@advanced-configuration@@browser-size","Browser","Advanced Configuration","Browser Size","Browser window size can be set using browserWidth and browserHeight url = \"http://localhost:8180\" browserWidth = 1280 browserHeight = 800"],["browser@@advanced-configuration@@documentation-artifacts","Browser","Advanced Configuration","Documentation Artifacts","By default all generated documentation artifacts (e.g. screenshots) are created in the current directory. To override url = \"http://localhost:8180\" docPath = \"screenshots\""],["browser@@local-storage@@access-local-storage","Browser","Local Storage","Access Local Storage","To access local storage use browser.localStorage .Lets consider a simple web page that displays a value from a local storage. <div id=\"favorite-color\"> </div> <script> const element = document.getElementById('favorite-color'); element.innerHTML = localStorage.getItem('favoriteColor'); </script> package scenarios.ui import static org.testingisdocumenting.webtau.WebTauGroovyDsl.* scenario(\"local storage api\") { browser.open('/local-storage') browser.localStorage.setItem('favoriteColor', 'clean') def color = $('#favorite-color') browser.reopen('/local-storage') color.should == 'clean' browser.localStorage.clear() browser.reopen('/local-storage') color.should == '' } public String getItem(String key) public void setItem(String key, String value) public void removeItem(String key) public void clear() public int size()"],["browser@@cookies@@add-cookies","Browser","Cookies","Add Cookies","browser.cookies.add(\"cookie-a\", \"hello\") browser.cookies.add(\"cookie-b\", \"world\")"],["browser@@cookies@@get-cookies","Browser","Cookies","Get Cookies","browser.cookies.get(\"cookie-a\").should == \"hello\" browser.cookies.get(\"cookie-b\").should == \"world\" browser.cookies.getAll().should == [\"cookie-a\": \"hello\", \"cookie-b\": \"world\"]"],["browser@@cookies@@delete-cookies","Browser","Cookies","Delete Cookies","browser.cookies.delete(\"cookie-b\") browser.cookies.deleteAll()"],["browser@@navigation@@open","Browser","Navigation","Open","To open a page use browser.open . Browser will load a page only if the current url doesn't match the passed one. search.submit('query') browser.open(\"/search\") // page is not be ing refreshed search.searchMessage.should == 'searching for query' Note: relative url will be automatically expanded to the full url based on the browser/basic-configuration configuration"],["browser@@navigation@@reopen","Browser","Navigation","Reopen","Use brower.reopen to force open the page even if the page url already matches the passed one. search.submit('name') browser.reopen(\"/search\") // page is going to be refreshed search.searchMessage.should == ''"],["browser@@navigation@@refresh","Browser","Navigation","Refresh","Use browser.refresh to refresh current page. search.submit('name') browser.reopen(\"/search\") // page is going to be refreshed search.searchMessage.should == ''"],["browser@@navigation@@restart","Browser","Navigation","Restart","Use browser.restart to restart a browser and open last opened url. browser.open('/local-storage') browser.localStorage.setItem('favoriteColor', 'pretty') browser.refresh() $('#favorite-color').should == 'pretty' browser.restart() $('#favorite-color').should == '' Note: restarting creates a clean instance of a browser. Local storage is going to be reset."],["browser@@navigation@@assert-url","Browser","Navigation","Assert URL","Use browser.url to assert on or wait for url changes. http://example.com/resource/id?type=full&debug=true#subId browser.url.path.should == '/resource/id' browser.url.path.should contain('/id') browser.url.query.should == 'type=full&debug=true' browser.url.ref.should == 'subId' browser.url.should == 'http://example.com/resource/id?type=full&debug=true#subId' browser.url.should contain('resource/id?type=') browser.url.path.waitTo == '/resource/id' browser.url.query.waitTo == 'type=full&debug=true' browser.url.ref.waitTo == 'subId'"],["browser@@navigation@@persist-url","Browser","Navigation","Persist URL","Use browser.saveCurrentUrl to save url in a local cache and browser.openSavedUrl to open a page later.It can be handy in multipart tests where first part creates an entity and the second part updates the created entity. browser.open('/resource-creation') $('#new').click() browser.saveCurrentUrl() In order to simplify tests development of a second part you can run first part once, save URL, and iterate on a second part by opening a page using saved URL. browser.openSavedUrl() // continue resource related manipulations Note: url is stored in a local cache file and will survive tests restart."],["browser@@navigation@@assert-title","Browser","Navigation","Assert Title","browser.title.should == \"Super Search\" browser.title.waitTo == \"Super Search\""],["browser@@page-open-handlers@@implicit-page-open-logic","Browser","Page Open Handlers","Implicit Page Open Logic","You can register a custom callback that will be called implicitly every time a web page is opened. One of the typical use cases is to inject cookies or values into a local storage before tests logic begins."],["browser@@page-open-handlers@@auto-login","Browser","Page Open Handlers","Auto Login","To register an open handler you need to define browserPageNavigationHandlerProvider config value. url = \"http://localhost:8180\" def userNameKey = 'userName' browserPageNavigationHandler = { passedUrl, fullUrl, currentUrl -> if (browser.localStorage.getItem(userNameKey)) { return } browser.localStorage.setItem(userNameKey, 'LoggedIn User') browser.reopen(fullUrl) } package scenarios.ui import static org.testingisdocumenting.webtau.WebTauGroovyDsl.* scenario(\"page open handlers\") { browser.open('/logged-in-user') $('#welcome').should == 'Welcome LoggedIn User' } scenario(\"page open handlers during re-open\") { browser.localStorage.clear() browser.reopen('/logged-in-user') $('#welcome').should == 'Welcome LoggedIn User' } Note: usage of localStorage is just an example. You can use cookies , call external services using http. or load credentials from a file system."],["browser@@finders-and-filters@@finders","Browser","Finders And Filters","Finders","Finders in webtau is the initial web element selection that could select one or more elements."],["browser@@finders-and-filters@@css-finder","Browser","Finders And Filters","CSS Finder","Use $ to select an element by a given css selector ( https://www.w3schools.com/cssref/css_selectors.asp Read W3Schools CSS selectors to learn all kind of CSS selection techniques). def welcomeMessage = $('#welcome') welcomeMessage.should == 'hello' If more than one element is matched, the first one will be used for actions and assertions. def menu = $('ul li a') menu.should == 'book' While click and sendKeys will always work on a first element only, the matchers can work with a list of things. def menu = $('ul li a') menu.should == ['book', 'orders', 'help'] Note: declaring element this way will not trigger element search right away."],["browser@@finders-and-filters@@filters","Browser","Finders And Filters","Filters","You can use filters to narrow down elements selected by finders.Filter comes in a way of get method. Parameter is one of the followingElement number Element text Element regexp def ordersMenu = $('ul li a').get(2) ordersMenu.should == 'orders' def ordersMenu = $('ul li a').get('orders') ordersMenu.should == 'orders' def ordersMenu = $('ul li a').get(~/ord/) ordersMenu.should == 'orders'"],["browser@@finders-and-filters@@chaining","Browser","Finders And Filters","Chaining","After you filtered, you can use finders again to find nested elements. def ordersMenu = $('ul li').get(2).find('a') ordersMenu.should == 'orders'"],["browser@@matchers@@text","Browser","Matchers","Text","def message = $('#message') message.should == 'Select option' def message = $('#message') message.should == ~/option/ def menu = $('#menu ul li') menu.should == ['Hello', 'Text', 'World'] def menu = $('#menu ul li') menu.should contain('Text') def menu = $('#menu ul li') menu.should == ['Hello', ~/T..t/, 'World']"],["browser@@matchers@@numbers","Browser","Matchers","Numbers","def total = $('#total') total.should == 300.6 def total = $('#total') total.shouldBe > 200 def total = $('#total') total.shouldBe >= 300 def split = $('#split ul li') split.should == [100, 28, 172.6] def split = $('#split ul li') split.should == [100, lessThan(100), greaterThanOrEqual(150)]"],["browser@@matchers@@state","Browser","Matchers","State","def button = $(\"#action\") button.should beDisabled() button.shouldNot beEnabled() def feedback = $(\"#feedback\") feedback.should beHidden() feedback.shouldNot beVisible() <div> <button id=\"action\" disabled>Click me</button> <div id=\"feedback\" style=\"display: none;\"></div> </div>"],["database@@introduction@@","Database","Introduction","","Webtau provides database access layer db. to help with data setup, validation and manipulation. Use it in conjunction with other layers like http. to write more powerful tests. database/data-setup Data Setup database/data-query Data Query PRICES << [ \"id\" | \"description\" | \"price\"] { ___________________________________ \"id1\" | \"nice set\" | 1000 \"id2\" | \"another set\" | 2000 } def prices = db.query(\"select * from PRICES where id=:id\", [id: \"id1\"]) prices.should == [\"ID\" | \"DESCRIPTION\" | \"PRICE\"] { ___________________________________ \"id1\" | \"nice set\" | 1000 }"],["database@@data-setup@@handcrafted-data","Database","Data Setup","Handcrafted Data","One way to set up a DB state is to use handcrafted reference/table-data TableData. def PRICES = db.table(\"PRICES\") // declare PRICES table PRICES << [ \"id\" | \"description\" | \"price\"] { // append two rows to PRICES ___________________________________ \"id1\" | \"nice set\" | 1000 \"id2\" | \"another set\" | 2000 } Alternatively use list of maps as the parameter to perform multiple rows insertion def PRICES = db.table(\"PRICES\") PRICES << [ [id: \"id1\", description: \"nice set\", price: 1000], [id: \"id2\", description: \"warm set\", price: 2000]] Use map as the parameter to perform a single row insertion def PRICES = db.table(\"PRICES\") PRICES << [id: \"id1\", description: \"nice set\", price: 1000]"],["database@@data-setup@@semi-auto-generated-tabledata","Database","Data Setup","Semi-Auto Generated TableData","reference/table-data TableData has features like reference/table-data#permutations permute and reference/table-data#guid cell.guid among others. Using them can reduce the effort required to maintain data setup. def PRICES = db.table(\"PRICES\") PRICES << [ \"id\" | \"description\" | \"available\" | \"type\" | \"price\" ] { _____________________________________________________________________________________________ cell.guid | \"nice set\" | true | \"card\" | 1000 // cell.guid generates random guid that can be used for ids cell.guid | \"nice set\" | true | \"card\" | cell.above + 10 // cell.above refers values above and can be modified with simple math operations cell.guid | \"another set\" | permute(true, false) | permute(\"rts\", \"fps\") | cell.above + 20 } // permute generates additional rows generating new rows with all the permutations Note: code above assumes WebTauCore.* static import or WebTauGroovyDsl.* static import import static org.testingisdocumenting.webtau.WebTauCore.* ID EXTERNAL_ID DESCRIPTION AVAILABLE TYPE PRICE 40143f04-5a1f-49cd-9546-943f2088535c nice set true card 1000 bcb69bd4-5e23-4f22-8313-cc9b3f700812 nice set true card 1010 79a6bc10-78bd-47ad-8671-c86640d81d15 another set true rts 1030 33bdfe5d-29d9-4c87-9ceb-f9b58463c25a another set false rts 1050 755ce53f-6490-47f5-98a1-3655dd319ca8 another set true fps 1070 f2b08c32-09ff-4f11-91d1-0660b2e7c7d9 another set false fps 1090"],["database@@data-setup@@external-file-tabledata","Database","Data Setup","External File TableData","def PRICES = db.table(\"PRICES\") PRICES << data.csv.table('prices-db.csv') id, description, available, type, price id1, description1, true, card, 200 id2, description2, false, rts, 400 ID EXTERNAL_ID DESCRIPTION AVAILABLE TYPE PRICE id1 description1 true card 200 id2 description2 false rts 400"],["database@@data-setup@@cleaning-tables","Database","Data Setup","Cleaning Tables","db.update(\"delete from PRICES where price > :price\", [price: 950]) db.update(\"delete from PRICES where price > :price\", 950)"],["database@@data-setup@@updating-tables","Database","Data Setup","Updating Tables","ID EXTERNAL_ID DESCRIPTION AVAILABLE TYPE PRICE id1 nice set 1000 id2 another set 2000 db.update(\"update PRICES set price=:price where id=:id\", [id: 'id2', price: 4000]) ID EXTERNAL_ID DESCRIPTION AVAILABLE TYPE PRICE id1 nice set 1000 id2 another set 4000"],["database@@data-query@@full-table","Database","Data Query","Full Table","To query all data from a table use: def PRICES = db.table(\"PRICES\") PRICES.should == [\"ID\" | \"DESCRIPTION\" | \"PRICE\"] { ___________________________________ \"id1\" | \"nice set\" | 1000 \"id2\" | \"another set\" | 2000 }"],["database@@data-query@@custom-query","Database","Data Query","Custom Query","def prices = db.query(\"select * from PRICES where id=:id\", [id: \"id1\"]) prices.should == [\"ID\" | \"DESCRIPTION\" | \"PRICE\"] { ___________________________________ \"id1\" | \"nice set\" | 1000 } def prices = db.query(\"select * from PRICES where id=:id\", [id: \"id1\"]) prices.should == [ID: \"id1\", \"DESCRIPTION\": \"nice set\", PRICE: 1000] def prices = db.query(\"select * from PRICES where id in (:ids)\", [ids: [\"id1\", \"id2\"]]) prices.should == [\"ID\" | \"DESCRIPTION\" | \"PRICE\"] { ___________________________________ \"id1\" | \"nice set\" | 1000 \"id2\" | \"another set\" | 2000 }"],["database@@data-query@@named-parameter-shortcut","Database","Data Query","Named Parameter Shortcut","If your query uses a single unique placeholder name, you can pass a regular value instead of a java.util.Map def prices = db.query(\"select * from PRICES where id=:id or external_id=:id\", \"id1\") prices.should == [ID: \"id1\", \"DESCRIPTION\": \"nice set\", PRICE: 1000]"],["database@@data-query@@lazy-declaration","Database","Data Query","Lazy Declaration","query doesn't query database at the call time. It defines a query to be used later. def prices = db.query(\"select * from PRICES\") prices.shouldNot == [] db.update(\"delete from PRICES\") prices.should == [] def PRICES = db.table(\"PRICES\") def numberOfItems = PRICES.queryCount() numberOfItems.shouldNot == 0 db.update(\"delete from PRICES\") numberOfItems.should == 0"],["database@@data-query@@single-value","Database","Data Query","Single Value","def price = db.query(\"select price from PRICES where id=:id\", [id: 'id1']) price.should == 1000 price.shouldNot == 2000"],["database@@data-query@@wait-on-result","Database","Data Query","Wait On Result","Use waitTo on query result to continuously query database until condition is met or timeout is reached. def count = db.query(\"select count(*) from PRICES\") count.should == 2 // event happen somewhere to increase the number of rows... count.waitTo == 3"],["database@@data-query@@query-result-value","Database","Data Query","Query Result Value","Value returned from query methods is an instance of DbQuery type. No actual query is performed when DbQuery instance is created. It holds information about what query is, and what its parameters and only performs query when validation is triggered.Use queryXXX to access underlying value. def price = db.query(\"select price from PRICES where id=:id\", [id: 'id1']) if (price.singleValue() > 100) { println(\"do something\") } Avoid: When you use queryXXX for assertions you may lose additional report information"],["database@@config@@jdbc","Database","Config","JDBC","Webtau is JVM based API and it uses https://en.wikipedia.org/wiki/Java_Database_Connectivity#:~:text=Java%20Database%20Connectivity%20(JDBC)%20is,used%20for%20Java%20database%20connectivity. JDBC interface behind the scenes to connect to a database.You don't need to know how to use JDBC API as webtau expose higher level APIs, but you will need to understand how to build JDBC connection url to be able to connect to a database."],["database@@config@@primary-database","Database","Config","Primary Database","Primary DB config used when execute operations using db.update , db.query , etc, without specifying data source name. import groovy.grape.Grape Grape.grab(group:'com.h2database', module: 'h2', version: '1.4.200', // auto download DB driver dependency (in this case H2 db) classLoader: ClassLoader.getSystemClassLoader()) dbUrl = \"jdbc:h2:file:~/h2db/test-db\" // primary DB JDBC connection url dbDriverClassName = \"org.h2.Driver\" // JDBC driver class name dbUserName = \"sa\" dbPassword = \"password\""],["cli@@introduction@@","Cli","Introduction","","Webtau provides cli. module to run and validate command line tools. Combine it with other modules to create powerful tests: use cli to run a tool, and http , graphql , browser , or db to validate the outcome. scenario(\"example of ls run\") { cli.run('ls') { output.should contain('scripts') } } webtau basicLs.groovy examples pom.xml pom.xml.versionsBackup scripts src target test-expectations webtau-reports"],["cli@@foreground-command@@run","Cli","Foreground Command","Run","Webtau can run commands in foreground and in background . When command is ran in foreground webtau will wait for the command to finish.To run a command use cli.run with a single string parameter that includes a command and all its arguments: cli.run('echo hello world')"],["cli@@foreground-command@@run-with-validation","Cli","Foreground Command","Run With Validation","cli.run('echo hello world') { output.should contain('hello') output.should contain('world') } cli.run('scripts/error-output') { error.should == 'error B892T' } cli.run('scripts/exit-code 8') { exitCode.should == 8 exitCode.shouldNot == 0 }"],["cli@@foreground-command@@implicit-exit-code-validation","Cli","Foreground Command","Implicit Exit Code Validation","Webtau performs implicit exit code validation and adds exitCode equals zero when you don't specify explicit exitCode validation. cli.run('echo hello world') Example above is equivalent to cli.run('echo hello world') { exitCode.should == 0 }"],["cli@@foreground-command@@run-result","Cli","Foreground Command","Run Result","Use the result of cli.run if you need to process the output of the command. def result = cli.run('echo hello world') println result.output println result.error if (result.exitCode == 1) { // ... } Warning: Perform validation inside validation block so webtau can track what was checked. def result = cli.run('scripts/generate-id') def id = result.extractFromOutputByRegexp(\"id=(\\\\d+)\") def result = cli.run('scripts/generate-id') def id = result.extractFromErrorByRegexp(\"id=(\\\\d+)\")"],["cli@@foreground-command@@working-dir","Cli","Foreground Command","Working Dir","Use cli.workingDir as a second parameter to cli.run to set a working dir: cli.run('./listing', cli.workingDir('../scripts')) { output.should contain('listing files') output.should contain('sleeps') }"],["cli@@foreground-command@@environment-variables","Cli","Foreground Command","Environment Variables","Use cli.env as a second parameter to cli.run to set the environment variables: cli.run('scripts/hello-env-var', cli.env([my_var: 'webtau'])) { output.should == 'hello webtau' }"],["cli@@foreground-command@@chain-cli-run-config","Cli","Foreground Command","Chain Cli Run Config","Combine configs by using cli.env(...).workingDir(...) in any order to set both: cli.run('./hello-env-var', cli.workingDir('../scripts').env([my_var: 'webtau'])) { output.should == 'hello webtau' }"],["cli@@foreground-command@@path","Cli","Foreground Command","Path","To specify PATH to use for CLI commands lookup use cliPath = ['../scripts/more']"],["cli@@foreground-command@@timeout","Cli","Foreground Command","Timeout","cli.run command fails if it doesn't complete in 30 seconds.To override default timeout use cliTimeout config value: cliTimeout = 400 Note: Timeout value is specified in milliseconds"],["cli@@background-command@@run-in-background","Cli","Background Command","Run In Background","Webtau can run commands in foreground and in background . When command is ran in background webtau will continue execution, leaving command to run its course.To run a command in a background use cli.runInBackground with a single string parameter that includes a command and all its arguments: cli.runInBackground('scripts/sleeps') println \"process above may still be running\""],["cli@@background-command@@stop-command","Cli","Background Command","Stop Command","Use .stop to explicitly terminate the running background command def command = cli.runInBackground('scripts/sleeps') println \"some commands that assume running process\" command.stop()"],["cli@@background-command@@interacting-with-command","Cli","Background Command","Interacting With Command","We are going to test a \"hello world\" script that asks you for a name and greet you: #!/bin/bash echo \"enter your name\" read name echo \"hello $name\" Use .send to send input to a running command. Use .output.waitTo to wait for command to rich a certain state: def helloWorld = cli.runInBackground(\"scripts/hello-world\") helloWorld.output.waitTo contain(\"enter your name\") helloWorld.send(\"webtau\\n\") helloWorld.output.waitTo contain(\"hello webtau\") helloWorld.stop() You can use << instead of .send for extra syntax sugar: def helloWorld = cli.runInBackground(\"scripts/hello-world\") helloWorld.output.waitTo contain(\"enter your name\") helloWorld << \"webtau\\n\" helloWorld.output.waitTo contain(\"hello webtau\") helloWorld.stop()"],["cli@@background-command@@working-dir","Cli","Background Command","Working Dir","Use cli.workingDir as a second parameter to cli.runInBackground to set a working dir: def command = cli.runInBackground('./listing', cli.workingDir('../scripts')) command.output.waitTo contain('listing files') command.output.waitTo contain('sleeps') command.stop()"],["cli@@background-command@@environment-variables","Cli","Background Command","Environment Variables","Use cli.env as a second parameter to cli.runInBackground to set the environment variables: def command = cli.runInBackground('scripts/hello-env-var', cli.env([my_var: 'webtau'])) command.output.waitTo contain('hello webtau') command.stop()"],["cli@@background-command@@chain-cli-run-config","Cli","Background Command","Chain Cli Run Config","Combine configs by using cli.env(...).workingDir(...) in any order to set both: def command = cli.runInBackground('./hello-env-var', cli.workingDir('../scripts').env([my_var: 'webtau'])) command.output.waitTo contain('hello webtau') command.stop()"],["cli@@background-command@@path","Cli","Background Command","Path","To specify PATH to use for CLI commands lookup use cliPath = ['../scripts/more']"],["REPL@@experiments@@read-eval-print-loop","REPL","Experiments","Read Eval Print Loop","Webtau command line tool comes with a REPL mode that stands for 'read-eval-print-loop'. REPL is an established way to perform interactive execution of an API for the purpose of learning or experimenting. The REPL preserves the context of execution and each new command you run can rely on the established context."],["REPL@@experiments@@start-repl","REPL","Experiments","Start REPL","To run webtau in REPL mode run webtau repl webtau:000> 2 + 2 ===> 4 webtau:000> a = 5 ===> 5 webtau:000> a + 3 ===> 8"],["REPL@@experiments@@experiment-with-api","REPL","Experiments","Experiment With API","Use the REPL to try out various apis like http. , browser. , db. , cli. , etc. webtau:000> http.get(\"https://jsonplaceholder.typicode.com/todos/1\") > executing HTTP GET https://jsonplaceholder.typicode.com/todos/1 . header.statusCode equals 200 matches: header.statusCode: actual: 200 <java.lang.Integer> expected: 200 <java.lang.Integer> (28ms) response (application/json; charset=utf-8): { \"userId\": 1, \"id\": 1, \"title\": \"delectus aut autem\", \"completed\": false } . executed HTTP GET https://jsonplaceholder.typicode.com/todos/1 (692ms)"],["REPL@@experiments@@setting-config-value","REPL","Experiments","Setting Config Value","Use cfg.url = \"http://url\" to set base url for experiments. webtau:000> cfg.url = \"https://jsonplaceholder.typicode.com\" > setting url source: manual url: https://jsonplaceholder.typicode.com . set url (0ms) ===> https://jsonplaceholder.typicode.com webtau:000> http.get(\"/todos/1\") > executing HTTP GET https://jsonplaceholder.typicode.com/todos/1 . header.statusCode equals 200 matches: header.statusCode: actual: 200 <java.lang.Integer> expected: 200 <java.lang.Integer> (1ms) response (application/json; charset=utf-8): { \"userId\": 1, \"id\": 1, \"title\": \"delectus aut autem\", \"completed\": false } . executed HTTP GET https://jsonplaceholder.typicode.com/todos/1 (28ms)"],["REPL@@experiments@@preserving-browser-context","REPL","Experiments","Preserving Browser Context","During browser testing the REPL preserves the context of an opened browser, so you can experiment with css selectors and element actions without re-opening the browser and setting the right web app state. webtau:000> browser.open(\"file:///home/runner/work/webtau/webtau/webtau-cli-testing/src/test/groovy/data/basic.html\") > initializing webdriver for chrome . initialized webdriver for chrome (809ms) > opening file:///home/runner/work/webtau/webtau/webtau-cli-testing/src/test/groovy/data/basic.html . opened file:///home/runner/work/webtau/webtau/webtau-cli-testing/src/test/groovy/data/basic.html (65ms) Using element selectors provides additional information in REPL mode to help with exploration webtau:000> $(\"p\") element is found: by css p getText(): hello web page"],["REPL@@test-runs@@incremental-tests-development","REPL","Test Runs","Incremental Tests Development","You can combine experimentation in REPL with actual test development. Your feedback loop becomes even faster:Try API Add the line to test Re-run test with REPL Experiment within preserved context Enumerate test files you want to REPL with and add repl to get into incremental tests development mode webtau testscipts/* repl"],["REPL@@test-runs@@test-files-listing","REPL","Test Runs","Test Files Listing","Use ls command to list available test files. webtau:000> ls Test files: 0 testscripts/dataDownload.groovy 1 testscripts/downstreamValidation.groovy 2 testscripts/resourceCreation.groovy Note: Listing will happen automatically at the start"],["REPL@@test-runs@@test-file-selection","REPL","Test Runs","Test File Selection","webtau:000> s 0 Test scenarios of testscripts/dataDownload.groovy: 0 clean data 1 download data 2 validate data webtau:000> b Test files: 0 testscripts/dataDownload.groovy 1 testscripts/downstreamValidation.groovy 2 testscripts/resourceCreation.groovy webtau:000> s 'datadownload' Test scenarios of testscripts/dataDownload.groovy: 0 clean data 1 download data 2 validate data"],["REPL@@test-runs@@single-test-scenario-run","REPL","Test Runs","Single Test Scenario Run","Selected test file has three scenarios package testscripts import static org.testingisdocumenting.webtau.WebTauGroovyDsl.scenario scenario(\"clean data\") { println \"cleaning...\" } scenario(\"download data\") { println \"downloading...\" } scenario(\"validate data\") { println \"validating...\" } To run scenario by index webtau:000> r 0 scenario before first test (Setup) [.] before first test (Setup) running: testscripts/dataDownload.groovy clean data scenario clean data (dataDownload.groovy) cleaning... [.] clean data (dataDownload.groovy) Use negative index to select from the bottom, i.e. -1 will select the last scenario, -2 will select second from the end webtau:000> r -1 running: testscripts/dataDownload.groovy validate data scenario validate data (dataDownload.groovy) validating... [.] validate data (dataDownload.groovy) To run scenario by partial name match webtau:000> r 'clean' running: testscripts/dataDownload.groovy clean data scenario clean data (dataDownload.groovy) cleaning... [.] clean data (dataDownload.groovy)"],["REPL@@test-runs@@re-run-last-run","REPL","Test Runs","Re-run Last Run","Use r to re-run previous run webtau:000> r running: testscripts/dataDownload.groovy clean data scenario clean data (dataDownload.groovy) cleaning... [.] clean data (dataDownload.groovy)"],["REPL@@test-runs@@multiple-test-scenarios-run","REPL","Test Runs","Multiple Test Scenarios Run","Use comma separated list of indexes or partial text match to run more than one scenario webtau:000> r 0, 1 running: testscripts/dataDownload.groovy clean data scenario clean data (dataDownload.groovy) cleaning... [.] clean data (dataDownload.groovy) running: testscripts/dataDownload.groovy download data scenario download data (dataDownload.groovy) downloading... [.] download data (dataDownload.groovy) webtau:000> r 'download', 'clean' running: testscripts/dataDownload.groovy download data scenario download data (dataDownload.groovy) downloading... [.] download data (dataDownload.groovy) running: testscripts/dataDownload.groovy clean data scenario clean data (dataDownload.groovy) cleaning... [.] clean data (dataDownload.groovy) Note: Order of execution follows the order of specified indexes or textUse r from:to to run a range of scenarios. From , to can be either index or partial text match. webtau:000> r 0:'validate' running: testscripts/dataDownload.groovy clean data scenario clean data (dataDownload.groovy) cleaning... [.] clean data (dataDownload.groovy) running: testscripts/dataDownload.groovy download data scenario download data (dataDownload.groovy) downloading... [.] download data (dataDownload.groovy) running: testscripts/dataDownload.groovy validate data scenario validate data (dataDownload.groovy) validating... [.] validate data (dataDownload.groovy) webtau:000> r 'validate':0 running: testscripts/dataDownload.groovy validate data scenario validate data (dataDownload.groovy) validating... [.] validate data (dataDownload.groovy) running: testscripts/dataDownload.groovy download data scenario download data (dataDownload.groovy) downloading... [.] download data (dataDownload.groovy) running: testscripts/dataDownload.groovy clean data scenario clean data (dataDownload.groovy) cleaning... [.] clean data (dataDownload.groovy)"],["REPL@@test-runs@@select-scenarios-without-run","REPL","Test Runs","Select Scenarios Without Run","package testscripts import static org.testingisdocumenting.webtau.WebTauGroovyDsl.scenario scenario(\"clean data\") { println \"cleaning...\" } scenario(\"download data\") { println \"downloading...\" } scenario(\"validate data\") { println \"validating...\" } Lets run scenarios by ranage again webtau:000> r 'validate':0 running: testscripts/dataDownload.groovy validate data scenario validate data (dataDownload.groovy) validating... [.] validate data (dataDownload.groovy) running: testscripts/dataDownload.groovy download data scenario download data (dataDownload.groovy) downloading... [.] download data (dataDownload.groovy) running: testscripts/dataDownload.groovy clean data scenario clean data (dataDownload.groovy) cleaning... [.] clean data (dataDownload.groovy) Use s to display last ran or selected scenarios. These scenarios will be ran with r webtau:000> s Selected scenarios: validate data download data clean data webtau:000> s 0,2 Selected scenarios: clean data validate data"],["utilities@@introduction@@","Utilities","Introduction","","Webtau has several modules to help you simplify automation processes. All operations in the modules provide detailed information on steps executed and details are included in web report as well as console output. utilities/data data - module to read structured data like CSV and JSON into data structures like TableData , lists and maps utilities/file-system file system - module to create files, directories, reading data, unzipping, etc utilities/cache cache - module to cache results of test steps to be able to skip them during test development and exploration"],["utilities@@data@@csv-read","Utilities","Data","CSV Read","Table Data Use data.csv.table to read data as TableData from CSV file. Passed path is either relative based on working dir or absolute file path. Or it can be a resource class path. A B C 1 2 3 a b c def table = data.csv.table('data/table.csv') table.row(0).B.should == '2' table.row(0).B.class.canonicalName.should == 'java.lang.String' Note: by default numeric values are read as strings, to auto convert numeric values to actual numbers use tableAutoConverted method Use data.csv.tableAutoConverted to read data as TableData from CSV file. Numeric values become values of Numeric type instead of String type. Passed path is either relative based on working dir or absolute file path. Or it can be a resource class path. def table = data.csv.tableAutoConverted('data/table.csv') table.row(0).B.should == 2 table.row(0).B.class.canonicalName.should == 'java.lang.Long' List Of Map A B C 1 2 3 a b c Use data.csv.listOfMaps to read data as java.util.List of java.util.Map from CSV file. Passed path is either relative based on working dir or absolute file path. Or it can be a resource class path. def list = data.csv.listOfMaps('data/table.csv') list.get(0).B.should == '2' list.get(0).B.class.canonicalName.should == 'java.lang.String' Note: by default numeric values are read as strings, to auto convert numeric values to actual numbers use tableAutoConverted method Use data.csv.listOfMapsAutoConverted to read data as java.util.List of java.util.Map from CSV file. Numeric values become values of Numeric type instead of String type. Passed path is either relative based on working dir or absolute file path. Or it can be a resource class path. def list = data.csv.listOfMapsAutoConverted('data/table.csv') list.get(0).B.should == 2 list.get(0).B.class.canonicalName.should == 'java.lang.Long' Specify Header 1, 2, 3 a, b, c Use data.csv.listOfMapsAutoConverted(header, path) to read data as java.util.List of java.util.Map from CSV file. Header will be taken from first parameter and first row of CSV file will not be treated as header. Numeric values become values of Numeric type instead of String type. Passed path is either relative based on working dir or absolute file path. Or it can be a resource class path. def list = data.csv.listOfMapsAutoConverted(['C1', 'C2', 'C3'],'data/table-no-header.csv') list.get(0).C2.should == 2 list.get(0).C2.class.canonicalName.should == 'java.lang.Long'"],["utilities@@data@@csv-write","Utilities","Data","CSV Write","Use data.csv.write to write data to CSV file. def path = data.csv.write('generated/from-list-maps.csv', list) colA,colB 1,R1 2,R2"],["utilities@@data@@json-read","Utilities","Data","JSON Read","Read List Use data.json.list to read data as java.util.List from JSON file. Passed path is either relative based on working dir or absolute file path. Or it can be a resource class path. def list = data.json.list('data/flat-list.json') list[0].name.should == 'hello' list[1].payload.info.should == ~/id2 payload/ Read Map Use data.json.map to read data as java.util.Map from JSON file. Passed path is either relative based on working dir or absolute path. Or it can be a resource class path. def map = data.json.map('data/root-map.json') map.payload.info.should == \"additional id1 payload\""],["utilities@@data@@guid","Utilities","Data","GUID","Generate Use data.guid.generate to generate unique identifier. def id = data.guid.generate()"],["utilities@@file-system@@file-content","Utilities","File System","File Content","def path = fs.writeText('my-test-file.txt', 'hello world') fs.textContent('my-test-file.txt').should == 'hello world\\nid=15' fs.textContent declares file content, but doesn't access it right away. Webtau reads file content when validation happens. Here is an example of waiting on file content: def fileTextContent = fs.textContent('my-test-file.txt') fileTextContent.waitTo contain('id=15') Use .data to access actual file content for further processing def actualFileContent = fileTextContent.data Use extractByRegexp to extract content from a file by regular expression def id = fileTextContent.extractByRegexp(\"id=(\\\\d+)\") http.get(\"/customers/${id}\") { // ... }"],["utilities@@file-system@@copy","Utilities","File System","Copy","def dir = fs.createDir(\"my-dir\") fs.copy(\"data/message.txt\", dir) def dir = fs.tempDir(\"fs-copy\") fs.copy(\"data/message.txt\", dir) fs.copy(\"data/message.txt\", \"data/new-message.txt\")"],["utilities@@file-system@@archive","Utilities","File System","Archive","def dir = fs.tempDir('for-unzip') fs.unzip('data/data.zip', dir) def dir = fs.tempDir('for-untar') fs.untar('data/data.tar', dir)"],["utilities@@cache@@cached-value","Utilities","Cache","Cached Value","When you develop tests, you don't have to restart the whole flow from the beginning.Imagine you have a multi step test that includes running Command Line tool and then validating REST API response, and then opening a browser to assert UI values.Cache long steps results like created entities ids to speed up tests development.In the example below, you create first scenario that runs a heavy command line tool that generates an id. We then cache the value and you can write a second scenario and keep re-running it, without the need to re-run the first one. import static org.testingisdocumenting.webtau.WebTauGroovyDsl.* def createdId = cache.value(\"cli-heavy-created-id\") // declare cached value with distinct id scenario(\"heavy setup operation\") { def cliResult = cli.run(\"scripts/cli-heavy-process\") // long running process that you don't want to re-run as you write your tests createdId.set(cliResult.extractFromOutputByRegexp(\"id=(\\\\S+)\")) // caching the extracted id from CLI run } scenario(\"using previous setup id even after restart\") { def id = createdId.get() // using cached value from previous test run. value will be preserved between restarts and re-compile http.get(\"/resource/${id}\") { message.should == \"hello\" } } Note: Use groovy-standalone-runner/selective-run Selective Run or REPL/test-runs REPL mode to run one scenario at a time."],["groovy-standalone-runner@@introduction@@standalone-cli","Groovy Standalone Runner","Introduction","Standalone CLI","Webtau has a standalone runner, so you can author and run tests without needing a build system or IDEs. You can fire your editor of choice and start creating automations without worrying about imports and packages to get your first result.In Enterprise setups webtau command line tool can be shared with everyone through mount drives or other similar mechanisms which makes local testing and CI testing to be much more streamlined."],["groovy-standalone-runner@@introduction@@setup","Groovy Standalone Runner","Introduction","Setup","If you have https://brew.sh brew installed in your system use brew install testingisdocumenting/brew/webtau If you have https://sdkman.io sdkman installed in your system use sdk install webtau Alternatively, download and unzip https://repo.maven.apache.org/maven2/org/testingisdocumenting/webtau/webtau-dist/1.41/webtau-dist-1.41-webtau.zip webtau. Add it to your PATH . webtau --example Navigate into todo example cd examples/todo import static org.testingisdocumenting.webtau.WebTauGroovyDsl.* scenario('fetch todo item') { http.get('/todos/1') { title.should == 'delectus aut autem' completed.should == false } } To run test webtau todolist.groovy --url=https://jsonplaceholder.typicode.com"],["groovy-standalone-runner@@introduction@@repl","Groovy Standalone Runner","Introduction","REPL","Webtau standalone runner comes with repl mode that let you experiment with API and write tests incrementally. Repl mode preserves context of the runs which significantly speeds up tests development.Even if you don't want to use Groovy for your tests, you can still benefit from REPL mode as you experiment with APIs and system under tests. REPL/experiments Learn more about REPL"],["groovy-standalone-runner@@data-driven-scenarios@@dynamic-scenarios","Groovy Standalone Runner","Data Driven Scenarios","Dynamic Scenarios","Every time you call scenario method a new scenario is being registered. Define scenarios in a loop to have dynamic scenarios based on provided data. package scenarios.concept import static org.testingisdocumenting.webtau.WebTauGroovyDsl.* [1, 2, 3].each { number -> scenario(\"number $number\") { println number } }"],["groovy-standalone-runner@@data-driven-scenarios@@csv","Groovy Standalone Runner","Data Driven Scenarios","CSV","Use utilities/data#csv-read data.csv to conveniently build your scenarios from an external CSV data set. title, input, output hello, 10, 20 world, 30, 40 package scenarios.concept import static org.testingisdocumenting.webtau.WebTauGroovyDsl.* data.csv.table('use-cases.csv').each { row -> scenario(\"use case ${row.title}\") { println row.input println row.output } }"],["groovy-standalone-runner@@data-driven-scenarios@@table-data","Groovy Standalone Runner","Data Driven Scenarios","Table Data","Use TableData if you want to derive data and/or have a convenience of collocating data and tests package scenarios.concept import static org.testingisdocumenting.webtau.WebTauGroovyDsl.* def lever = 10 def useCases = ['title' | 'input' | 'output'] { ____________________________________ 'hello' | lever | lever + 10 'world' | lever + 30 | lever + 40 } useCases.each { row -> scenario(\"use case ${row.title}\") { println row.input println row.output } }"],["groovy-standalone-runner@@tests-hard-stops@@terminate-all","Groovy Standalone Runner","Tests Hard Stops","Terminate All","Use terminateAll if you need to stop a current scenario and all the scenarios after that. Consequent scenarios will be marked as skipped in the produced report. package scenarios.concept import static org.testingisdocumenting.webtau.WebTauGroovyDsl.* scenario(\"first test\") { terminateAll('hard stop of the rest of the tests') } scenario(\"second test\") { browser.open(\"/app\") } scenario(\"third test\") { http.get(\"/weather\") { temperature.shouldBe < 100 } } Test two and three in the example above will not be executed. Browser will not be opened and REST API will not be called."],["groovy-standalone-runner@@selective-run@@sscenario","Groovy Standalone Runner","Selective Run","sscenario","Define tests with sscenario or singleScenario to only run those tests and skip all the other tests defined in all the test files. Useful during tests creation or debugging. package scenarios.concept import static org.testingisdocumenting.webtau.WebTauGroovyDsl.* scenario('step one') { http.post('/reset') { // ... } } sscenario('step two') { // test that you want to focus on } singleScenario('step three') { // test that you want to focus on } scenario('step four') { http.put('/extra') { // ... } } Note: webtau command line will exit with non zero code if there are sscenario tests present"],["groovy-standalone-runner@@skipping-tests@@skipping-tests-on-condition","Groovy Standalone Runner","Skipping Tests","Skipping Tests on Condition","Use onlyWhen if you need to skip tests based on a condition. package scenarios.concept import static org.testingisdocumenting.webtau.WebTauGroovyDsl.* String emailHost = cfg.emailHost onlyWhen('email server is internal', { -> emailHost.contains('internal.server')}) { scenario('confirmation emails should be sent') { // ... http.get(emailHost) { subjects.should contain('my message') } } } Tests will still appear as part of your report but will be marked as skipped."],["groovy-standalone-runner@@skipping-tests@@skipping-tests-based-on-env","Groovy Standalone Runner","Skipping Tests","Skipping Tests Based on Env","Use the skipForEnv and onlyForEnv shortcuts if you need to skip or enable tests for a certain environment. package scenarios.concept import static org.testingisdocumenting.webtau.WebTauGroovyDsl.* onlyForEnv('experimental') { scenario('this scenario will only be executed in \"experimental\" env') { http.get('/new-endpoint') { price.shouldBe > 0 } } } skipForEnv('experimental') { scenario('this scenario will not be executed in \"experimental\" env') { http.get('/new-endpoint') { price.shouldBe > 0 } } }"],["groovy-standalone-runner@@skipping-tests@@custom-shortcuts","Groovy Standalone Runner","Skipping Tests","Custom Shortcuts","Consider creating your project specific shortcuts to avoid boilerplate. Here is an example of onlyForEnv shortcut definition. static void onlyForEnv(String env, Closure registrationCode) { onlyWhen(\"only for <$env> environment\", { -> getCfg().getEnv() == env }, registrationCode) }"],["groovy-standalone-runner@@skipping-tests@@unconditionally-skipping-tests","Groovy Standalone Runner","Skipping Tests","Unconditionally Skipping Tests","Instead of scenario , use dscenario or disabledScenario to always skip a test. This is analogous to Junit's @Ignore or @Disabled . package scenarios.concept import static org.testingisdocumenting.webtau.WebTauGroovyDsl.* dscenario('do not execute this scenario') { http.get('/new-endpoint') { price.shouldBe > 0 } } disabledScenario('do not execute this scenario either') { http.get('/new-endpoint') { price.shouldBe > 0 } }"],["groovy-standalone-runner@@test-metadata@@specifying-test-metadata","Groovy Standalone Runner","Test Metadata","Specifying Test Metadata","To attach custom metadata to a test use metadata from WebTauGroovyDsl package scenarios.concept import static org.testingisdocumenting.webtau.WebTauGroovyDsl.* metadata([owner: \"team A\"]) // setting owner for all the scenarios below scenario(\"one\") { } scenario(\"two\") { } scenario(\"three\") { metadata([owner: \"team B\"]) // owner is overridden for scenario \"three\" } scenario(\"four\") { } metadata can be called multiple times outside of scenario . It will be applied to all the scenarios below. package scenarios.concept import static org.testingisdocumenting.webtau.WebTauGroovyDsl.* metadata([owner: \"team A\"]) // setting owner for scenarios \"one\" and \"two\" scenario(\"one\") { } scenario(\"two\") { } metadata([owner: \"team B\"]) // setting owner for scenarios \"three\" and \"four\" scenario(\"three\") { } scenario(\"four\") { } Unlike previous example, \"team B\" will be set for scenario \"three\" and \"four\"."],["groovy-standalone-runner@@test-metadata@@metadata-encapsulation","Groovy Standalone Runner","Test Metadata","Metadata Encapsulation","You can encapsulate repeated metadata into a separate file. package scenarios.concept import static org.testingisdocumenting.webtau.WebTauGroovyDsl.* Support.teamA() scenario(\"one\") { } scenario(\"two\") { } scenario(\"three\") { Support.teamB() } scenario(\"four\") { } package scenarios.concept import static org.testingisdocumenting.webtau.WebTauGroovyDsl.* class Support { static void owner(String name) { metadata([owner: name]) } static void severity(int level) { metadata([severity: level]) } static void teamA() { owner(\"team A\") } static void teamB() { owner(\"team B\") } static void critical() { severity(100) } static void low() { severity(1) } }"],["groovy-standalone-runner@@test-metadata@@report","Groovy Standalone Runner","Test Metadata","Report","Test metadata will be available in a generated report as well as in test listeners.If metadata is present, it will be displayed at the test summary page"],["groovy-standalone-runner@@test-listeners@@test-listener-interface","Groovy Standalone Runner","Test Listeners","Test Listener Interface","To define a custom test listener you need to implement the TestListener interface /* * Copyright 2020 webtau maintainers * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an \"AS IS\" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.testingisdocumenting.webtau; import org.testingisdocumenting.webtau.reporter.WebTauTest; /** * Lowest common denominator for Groovy Standalone Tests, JUnit4, JUnit5 */ public interface TestListener { /** * before any test is ran */ default void beforeFirstTest() {} /** * before test code is invoked * @param test test */ default void beforeTestRun(WebTauTest test) {} /** * after test code is invoked * @param test test */ default void afterTestRun(WebTauTest test) {} /** * after all the tests are invoked */ default void afterAllTests() {} /** * after test is ran but before its first statement. * executed code in this listener is considered to be part of a test. * @param test test */ default void beforeFirstTestStatement(WebTauTest test) {} /** * right before test considered to be complete. May not be executed if the test didn't reach the last statement. * executed code in this listener is considered to be part of a test. * @param test test */ default void afterLastTestStatement(WebTauTest test) {} }"],["groovy-standalone-runner@@test-listeners@@config","Groovy Standalone Runner","Test Listeners","Config","Once you have an implementation, use the testListeners key in your config file to use it import listeners.MetadataValidationTestListener testListeners = [MetadataValidationTestListener] package listeners import org.testingisdocumenting.webtau.TestListener import org.testingisdocumenting.webtau.reporter.WebTauTest class MetadataValidationTestListener implements TestListener { @Override void afterLastTestStatement(WebTauTest test) { if (!test.isSynthetic() && !test.metadata.has('owner')) { throw new RuntimeException('owner for <' + test.scenario + '> is not set') } } }"],["groovy-standalone-runner@@test-execution@@serial-execution","Groovy Standalone Runner","Test Execution","Serial execution","The default mode for running tests is serially; in other words, scenario files are executed one after the other."],["groovy-standalone-runner@@test-execution@@parallel-execution","Groovy Standalone Runner","Test Execution","Parallel execution","Webtau supports executing tests in parallel. In this mode, scenario files are executed in parallel. Individual scenarios are still executed sequentially.For large test suites, it is therefore advisable to create many small focused scenario files instead of few large files.To enable parallel execution, specify the numberOfThreads configuration property either through the configuration file or as a CLI parameter. This property dictates the maximum number of threads on which to run tests. Alternatively, set numberOfThreads to -1 and webtau will use as many threads as there are scenario files.Note: scenario file execution order is not guaranteed."],["groovy-standalone-runner@@test-execution@@scenario-discovery","Groovy Standalone Runner","Test Execution","Scenario discovery","Webtau via CLI or Maven plugin supports a number of methods for specifying and discovering scenarios.The simplest way is to list the scenario files explicitly: CLI webtau scenarios/rest/simpleGet.groovy scnearios/rest/simplePost.groovy Maven <plugin> <groupId>org.testingisdocumenting.webtau</groupId> <artifactId>webtau-maven-plugin</artifactId> <version>1.41</version> <executions> <execution> <phase>test</phase> <goals> <goal>run</goal> </goals> </execution> </executions> <configuration> <workingDir>${project.basedir}/src/main/groovy</workingDir> <env>integration</env> <url>http://optional-base-url</url> <tests> <directory>${project.basedir}/src/main/groovy</directory> <includes> <include>scenarios/simpleGet.groovy</include> <include>scenarios/simplePost.groovy</include> </includes> </tests> </configuration> </plugin> Wildcard matching is also supported. In the CLI version this is normal shell https://en.wikipedia.org/wiki/Glob_(programming) glob and in Maven it's a standard Maven file inclusion block: CLI webtau scenarios/rest/simple*.groovy Maven <plugin> <groupId>org.testingisdocumenting.webtau</groupId> <artifactId>webtau-maven-plugin</artifactId> <version>1.41</version> <executions> <execution> <phase>test</phase> <goals> <goal>run</goal> </goals> </execution> </executions> <configuration> <workingDir>${project.basedir}/src/main/groovy</workingDir> <env>integration</env> <url>http://optional-base-url</url> <tests> <directory>${project.basedir}/src/main/groovy</directory> <includes> <include>scenarios/simple*.groovy</include> </includes> </tests> </configuration> </plugin> It is also possible to include a set of base directories and webtau will then find all *.groovy files within them, recursively: CLI webtau scenarios/rest Maven <plugin> <groupId>org.testingisdocumenting.webtau</groupId> <artifactId>webtau-maven-plugin</artifactId> <version>1.41</version> <executions> <execution> <phase>test</phase> <goals> <goal>run</goal> </goals> </execution> </executions> <configuration> <workingDir>${project.basedir}/src/main/groovy</workingDir> <env>integration</env> <url>http://optional-base-url</url> <tests> <directory>${project.basedir}/src/main/groovy</directory> </tests> </configuration> </plugin> In this mode, the HTML report that webtau generates will show paths to the files relative to the requested directories."],["configuration@@environments@@select","Configuration","Environments","Select","cfg waitTimeout = 2500 url = http://my-server environments { dev { url = \"http://localhost:8080\" } } webtau --env=dev"],["configuration@@options@@cli-and-configuration-file-options","Configuration","Options","CLI and configuration file options","name description default value browserAnnotationsDarkFriendly browser doc capture to use light colors annotations by default (for dark theme UI) false browserDisableExtensions run browser without extensions false browserHeadless run browser in headless mode false browserHeight browser window height 0 browserId browser to use: chrome, firefox chrome browserRemoteDriverUrl browser remote driver url browserStaleElementRetry number of times to automatically retry for browser stale element actions 5 browserStaleElementRetryWait wait time in between browser stale element retries 100 browserUrl browser base url for application under test. It is being used instead of url when provided browserVersion browser version for automatic driver download browserWidth browser window width 0 cachePath user driven cache base dir ${workingDir}/.webtau-cache chromeBinPath path to chrome binary chromeDriverPath path to chrome driver binary cliPath path items to append to path used for cli runs [] cliTimeout cli foreground command run timeout (ms) 30000 config config file path webtau.cfg.groovy consolePayloadOutputLimit max number of lines to display in console for outputs (e.g. http response) 500 dbDriverClassName primary database driver class name dbPassword primary database password dbUrl primary database url dbUserName primary database user name disableRedirects disable following of redirects from HTTP calls false docPath path for captured request/responses, screenshots and other generated artifacts for documentation ${workingDir}/doc-artifacts env environment id local failedReportPath failed report file path firefoxBinPath path to firefox binary firefoxDriverPath path to firefox driver binary fullStackTrace print full stack trace to console false graphQLEndpoint override the default graphQL endpoint /graphql graphQLIgnoreIntrospectionFailures ignore graphQL introspection failures, introspection is required for coverage reporting true graphQLShowOperationAsQueryParam pass the graphQL operation as operation=<operation> query parameter if present true httpTimeout http connect and read timeout in milliseconds 30000 jsonSchemasDir url of directory containing JSON schemas /home/runner/work/webtau/webtau/webtau-groovy-app maxRedirects Maximum number of redirects to follow for an HTTP call 20 noColor disable ANSI colors false numberOfThreads number of threads on which to run test files (one file per thread), -1 will use as many threads as there are files 1 openApiIgnoreAdditionalProperties ignore additional OpenAPI properties false openApiSpecUrl url of OpenAPI 2 spec against which to validate http calls removeWebtauFromUserAgent By default webtau appends webtau and its version to the user-agent, this disables that part false reportPath report file path /home/runner/work/webtau/webtau/webtau-groovy-app/${workingDir}/webtau.report.html url base url for application under test userAgent User agent to send on HTTP requests webtau/1.41 verbosityLevel output verbosity level. 0 - no output; 1 - test names; 2 - first level steps; etc 2147483647 waitTimeout wait timeout in milliseconds 5000 workingDir logical working dir"],["configuration@@options@@environment-variable-options","Configuration","Options","Environment variable options","environment variable description default value WEBTAU_BROWSER_ANNOTATIONS_DARK_FRIENDLY browser doc capture to use light colors annotations by default (for dark theme UI) false WEBTAU_BROWSER_DISABLE_EXTENSIONS run browser without extensions false WEBTAU_BROWSER_HEADLESS run browser in headless mode false WEBTAU_BROWSER_HEIGHT browser window height 0 WEBTAU_BROWSER_ID browser to use: chrome, firefox chrome WEBTAU_BROWSER_REMOTE_DRIVER_URL browser remote driver url WEBTAU_BROWSER_STALE_ELEMENT_RETRY number of times to automatically retry for browser stale element actions 5 WEBTAU_BROWSER_STALE_ELEMENT_RETRY_WAIT wait time in between browser stale element retries 100 WEBTAU_BROWSER_URL browser base url for application under test. It is being used instead of url when provided WEBTAU_BROWSER_VERSION browser version for automatic driver download WEBTAU_BROWSER_WIDTH browser window width 0 WEBTAU_CACHE_PATH user driven cache base dir ${workingDir}/.webtau-cache WEBTAU_CHROME_BIN_PATH path to chrome binary WEBTAU_CHROME_DRIVER_PATH path to chrome driver binary WEBTAU_CLI_PATH path items to append to path used for cli runs [] WEBTAU_CLI_TIMEOUT cli foreground command run timeout (ms) 30000 WEBTAU_CONFIG config file path webtau.cfg.groovy WEBTAU_CONSOLE_PAYLOAD_OUTPUT_LIMIT max number of lines to display in console for outputs (e.g. http response) 500 WEBTAU_DB_DRIVER_CLASS_NAME primary database driver class name WEBTAU_DB_PASSWORD primary database password WEBTAU_DB_URL primary database url WEBTAU_DB_USER_NAME primary database user name WEBTAU_DISABLE_REDIRECTS disable following of redirects from HTTP calls false WEBTAU_DOC_PATH path for captured request/responses, screenshots and other generated artifacts for documentation ${workingDir}/doc-artifacts WEBTAU_ENV environment id local WEBTAU_FAILED_REPORT_PATH failed report file path WEBTAU_FIREFOX_BIN_PATH path to firefox binary WEBTAU_FIREFOX_DRIVER_PATH path to firefox driver binary WEBTAU_FULL_STACK_TRACE print full stack trace to console false WEBTAU_GRAPH_QLENDPOINT override the default graphQL endpoint /graphql WEBTAU_GRAPH_QLIGNORE_INTROSPECTION_FAILURES ignore graphQL introspection failures, introspection is required for coverage reporting true WEBTAU_GRAPH_QLSHOW_OPERATION_AS_QUERY_PARAM pass the graphQL operation as operation=<operation> query parameter if present true WEBTAU_HTTP_TIMEOUT http connect and read timeout in milliseconds 30000 WEBTAU_JSON_SCHEMAS_DIR url of directory containing JSON schemas /home/runner/work/webtau/webtau/webtau-groovy-app WEBTAU_MAX_REDIRECTS Maximum number of redirects to follow for an HTTP call 20 WEBTAU_NO_COLOR disable ANSI colors false WEBTAU_NUMBER_OF_THREADS number of threads on which to run test files (one file per thread), -1 will use as many threads as there are files 1 WEBTAU_OPEN_API_IGNORE_ADDITIONAL_PROPERTIES ignore additional OpenAPI properties false WEBTAU_OPEN_API_SPEC_URL url of OpenAPI 2 spec against which to validate http calls WEBTAU_REMOVE_WEBTAU_FROM_USER_AGENT By default webtau appends webtau and its version to the user-agent, this disables that part false WEBTAU_REPORT_PATH report file path /home/runner/work/webtau/webtau/webtau-groovy-app/${workingDir}/webtau.report.html WEBTAU_URL base url for application under test WEBTAU_USER_AGENT User agent to send on HTTP requests webtau/1.41 WEBTAU_VERBOSITY_LEVEL output verbosity level. 0 - no output; 1 - test names; 2 - first level steps; etc 2147483647 WEBTAU_WAIT_TIMEOUT wait timeout in milliseconds 5000 WEBTAU_WORKING_DIR logical working dir"],["generic-runners@@JUnit-4@@webtau-runner","Generic Runners","JUnit 4","WebTau Runner","You can use webtau http. , graphql. , browser. , cli. , db. methods as in a junit 4 tests, but to enable reporting you need to use @RunWith(WebTauRunner.class) Groovy package com.example.tests.junit4 import org.testingisdocumenting.webtau.junit4.WebTauRunner import org.junit.Test import org.junit.runner.RunWith import static org.testingisdocumenting.webtau.WebTauGroovyDsl.* // convenient single import for DSL methods and props like http @RunWith(WebTauRunner) // runner is required to have this test to be a part of generated html report class CustomerCrudSingleGroovyTest { private def customerPayload = [firstName: 'FN', lastName: 'LN'] private def changedCustomerPayload = [*:customerPayload, lastName: 'NLN'] @Test void crud() { def id = http.post(\"/customers\", customerPayload) { return id } http.get(\"/customers/$id\") { body.should == customerPayload } http.put(\"/customers/$id\", changedCustomerPayload) { body.should == changedCustomerPayload } http.get(\"/customers/$id\") { body.should == changedCustomerPayload } http.delete(\"/customers/$id\") { statusCode.should == 204 } http.get(\"/customers/$id\") { statusCode.should == 404 } } } Java package com.example.tests.junit4; import org.testingisdocumenting.webtau.junit4.WebTauRunner; import org.junit.Test; import org.junit.runner.RunWith; import java.util.Map; import static org.testingisdocumenting.webtau.WebTauDsl.*; // convenient single import for DSL methods and props like http and equal, aMapOf, etc @RunWith(WebTauRunner.class) // runner is required to have this test to be a part of generated html report public class CustomerCrudSingleJavaTest { private Map<String, Object> customerPayload = createCustomerPayload(); private Map<String, Object> changedCustomerPayload = createChangedCustomerPayload(); @Test public void crud() { int id = http.post(\"/customers\", customerPayload, ((header, body) -> { return body.get(\"id\"); })); http.get(\"/customers/\" + id, ((header, body) -> { body.should(equal(customerPayload)); })); http.put(\"/customers/\" + id, changedCustomerPayload, ((header, body) -> { body.should(equal(changedCustomerPayload)); })); http.get(\"/customers/\" + id, ((header, body) -> { body.should(equal(changedCustomerPayload)); })); http.delete(\"/customers/\" + id, ((header, body) -> { header.statusCode().should(equal(204)); })); http.get(\"/customers/\" + id, ((header, body) -> { header.statusCode().should(equal(404)); })); } private Map<String, Object> createCustomerPayload() { return aMapOf( \"firstName\", \"FN\", \"lastName\", \"LN\"); } private Map<String, Object> createChangedCustomerPayload() { Map<String, Object> payload = createCustomerPayload(); payload.put(\"lastName\", \"NLN\"); return payload; } }"],["generic-runners@@JUnit-4@@beforeafter","Generic Runners","JUnit 4","Before/After","Use @Before , @After standard JUnit 4 annotations to implement init and cleanup logic for each test. Groovy package com.example.tests.junit4 import org.testingisdocumenting.webtau.junit4.WebTauRunner import org.junit.After import org.junit.Before import org.junit.Test import org.junit.runner.RunWith import static org.testingisdocumenting.webtau.WebTauGroovyDsl.* @RunWith(WebTauRunner.class) class CustomerCrudBeforeAfterGroovyTest { private def customerPayload = [firstName: 'FN', lastName: 'LN'] private def changedCustomerPayload = [*:customerPayload, lastName: 'NLN'] private int customerId @Before void \"create customer\"() { customerId = http.post(\"/customers\", customerPayload) { return id // We deliberately named field as \"customerId\" to avoid conflict with response field. Alternatively you can use body.id to avoid the conflict } } @Test void \"query customer\"() { http.get(\"/customers/$customerId\") { body.should == customerPayload } } @Test void \"update customer\"() { http.put(\"/customers/$customerId\", changedCustomerPayload) { body.should == changedCustomerPayload } http.get(\"/customers/$customerId\") { body.should == changedCustomerPayload } } @After void \"delete customer\"() { http.delete(\"/customers/$customerId\") { statusCode.should == 204 } http.get(\"/customers/$customerId\") { statusCode.should == 404 } } } Java package com.example.tests.junit4; import org.testingisdocumenting.webtau.junit4.WebTauRunner; import org.junit.After; import org.junit.Before; import org.junit.Test; import org.junit.runner.RunWith; import java.util.Map; import static org.testingisdocumenting.webtau.WebTauDsl.*; @RunWith(WebTauRunner.class) public class CustomerCrudBeforeAfterJavaTest { private Map<String, Object> customerPayload = createCustomerPayload(); private Map<String, Object> changedCustomerPayload = createChangedCustomerPayload(); private int customerId; @Before public void createCustomer() { customerId = http.post(\"/customers\", customerPayload, ((header, body) -> { return body.get(\"id\"); })); } @Test public void queryCustomer() { http.get(\"/customers/\" + customerId, ((header, body) -> { body.should(equal(customerPayload)); })); } @Test public void updateCustomer() { http.put(\"/customers/\" + customerId, changedCustomerPayload, ((header, body) -> { body.should(equal(changedCustomerPayload)); })); http.get(\"/customers/\" + customerId, ((header, body) -> { body.should(equal(changedCustomerPayload)); })); } @After public void deleteCustomer() { http.delete(\"/customers/\" + customerId, (header, body) -> { header.statusCode().should(equal(204)); }); http.get(\"/customers/\" + customerId, ((header, body) -> { header.statusCode().should(equal(404)); })); } private Map<String, Object> createCustomerPayload() { return aMapOf( \"firstName\", \"FN\", \"lastName\", \"LN\"); } private Map<String, Object> createChangedCustomerPayload() { Map<String, Object> payload = createCustomerPayload(); payload.put(\"lastName\", \"NLN\"); return payload; } }"],["generic-runners@@JUnit-4@@beforeclassafterclass","Generic Runners","JUnit 4","BeforeClass/AfterClass","Use @BeforeClass and @AfterClass to prepare and cleanup resources required for multiple test methods. Groovy package com.example.tests.junit4 import org.testingisdocumenting.webtau.junit4.WebTauRunner import org.junit.AfterClass import org.junit.BeforeClass import org.junit.Test import org.junit.runner.RunWith import static org.testingisdocumenting.webtau.WebTauDsl.http @RunWith(WebTauRunner.class) class CustomerQueryGroovyTest { private static def id1 // keep track of created ids to assert and cleanup later private static def id2 private static def id3 @BeforeClass static void createCustomers() { id1 = createCustomer(\"CQ_FN1\", \"CQ_LN1\") id2 = createCustomer(\"CQ_FN1\", \"CQ_LN2\") id3 = createCustomer(\"CQ_FN2\", \"CQ_LN2\") } @Test void queryByFirstName() { http.get(\"/customers/search/first-name\", [name: \"CQ_FN1\"]) { body.should == [\"*id\" | \"firstName\" | \"lastName\"] { // star(*) marks key column so assertion is order agnostic __________________________________ id1 | \"CQ_FN1\" | \"CQ_LN1\" id2 | \"CQ_FN1\" | \"CQ_LN2\" } } } @Test void queryByLastName() { http.get(\"/customers/search/last-name\", [name: \"CQ_LN2\"]) { body.should == [\"*id\" | \"firstName\" | \"lastName\"] { __________________________________ id2 | \"CQ_FN1\" | \"CQ_LN2\" id3 | \"CQ_FN2\" | \"CQ_LN2\" } } } @AfterClass static void cleanup() { [id1, id2, id3].each { http.delete(\"/customers/$it\") } } private static def createCustomer(String firstName, String lastName) { return http.post(\"/customers\", [firstName: firstName, lastName: lastName]) { id } } } Java package com.example.tests.junit4; import org.testingisdocumenting.webtau.junit4.WebTauRunner; import org.junit.AfterClass; import org.junit.BeforeClass; import org.junit.Test; import org.junit.runner.RunWith; import java.util.Map; import java.util.stream.Stream; import static org.testingisdocumenting.webtau.WebTauDsl.*; @RunWith(WebTauRunner.class) public class CustomerQueryJavaTest { private static Integer id1; // keep track of created ids to assert and cleanup later private static Integer id2; private static Integer id3; @BeforeClass public static void createCustomers() { id1 = createCustomer(\"CQ_FN1\", \"CQ_LN1\"); id2 = createCustomer(\"CQ_FN1\", \"CQ_LN2\"); id3 = createCustomer(\"CQ_FN2\", \"CQ_LN2\"); } @Test public void queryByFirstName() { http.get(\"/customers/search/first-name\", http.query(\"name\", \"CQ_FN1\"), (header, body) -> { body.should(equal(table(\"*id\", \"firstName\", \"lastName\", // star(*) marks key column so assertion is order agnostic ________________________________, id1, \"CQ_FN1\" , \"CQ_LN1\", id2, \"CQ_FN1\" , \"CQ_LN2\"))); }); } @Test public void queryByLastName() { http.get(\"/customers/search/last-name\", http.query(\"name\", \"CQ_LN2\"), (header, body) -> { body.should(equal(table(\"*id\", \"firstName\", \"lastName\", ________________________________, id2, \"CQ_FN1\" , \"CQ_LN2\", id3, \"CQ_FN2\" , \"CQ_LN2\"))); }); } @AfterClass public static void cleanup() { Stream.of(id1, id2, id3).forEach(id -> http.delete(\"/customers/\" + id)); } private static int createCustomer(String firstName, String lastName) { Map<String, Object> payload = aMapOf( \"firstName\", firstName, \"lastName\", lastName); return http.post(\"/customers\", payload, ((header, body) -> { return body.get(\"id\"); })); } }"],["generic-runners@@JUnit-4@@maven-import","Generic Runners","JUnit 4","Maven Import","<dependency> <groupId>org.testingisdocumenting.webtau</groupId> <artifactId>webtau-junit4</artifactId> <version>1.41</version> </dependency>"],["generic-runners@@JUnit-5@@webtau-runner","Generic Runners","JUnit 5","WebTau Runner","You can use webtau http. , graphql. , browser. , cli. , db. methods as in a junit 5 tests, but to enable reporting you need to use @Webtau annotation Groovy package com.example.tests.junit5 import org.testingisdocumenting.webtau.junit5.WebTau import org.junit.jupiter.api.* import static org.testingisdocumenting.webtau.WebTauGroovyDsl.* @WebTau @TestMethodOrder(MethodOrderer.OrderAnnotation) // forcing methods execution order @DisplayName(\"customer CRUD\") class CustomerCrudSeparatedGroovyTest { private static def customerPayload = [firstName: 'FN', lastName : 'LN'] private static def changedCustomerPayload = [*: customerPayload, lastName: 'NLN'] private static def id @BeforeAll @DisplayName(\"create customer\") // optional friendly name for reporting purposes static void createCustomer() { id = http.post(\"/customers\", customerPayload) { body.id // using body prefix is required in this case as id conflicts with class field name } id.shouldNot == 0 } @Test @Order(1) @DisplayName(\"read customer\") void read() { http.get(\"/customers/$id\") { body.should == customerPayload } } @Test @Order(2) // order dependence saves from creating customer on every test @DisplayName(\"update customer\") void update() { http.put(\"/customers/$id\", changedCustomerPayload) { body.should == changedCustomerPayload } http.get(\"/customers/$id\") { body.should == changedCustomerPayload } } @Test @Order(3) // but you can still run each method independently @DisplayName(\"delete customer\") void delete() { http.delete(\"/customers/$id\") { header.statusCode.should == 204 } http.get(\"/customers/$id\") { header.statusCode.should == 404 } id = -1 // marking as deleted to let cleanup step know that no delete is required } @AfterAll static void cleanup() { // optional (since we create new ids all the time) step to keep your environment clean if (id == -1) { return } http.delete(\"/customers/$id\") } } Java package com.example.tests.junit5; import org.testingisdocumenting.webtau.junit5.WebTau; import org.junit.jupiter.api.*; import java.util.Map; import static org.testingisdocumenting.webtau.WebTauDsl.*; @WebTau @TestMethodOrder(MethodOrderer.OrderAnnotation.class) // forcing methods execution order @DisplayName(\"customer CRUD\") public class CustomerCrudSeparatedJavaTest { private static final Map<String, ?> customerPayload = aMapOf( \"firstName\", \"FN\", \"lastName\", \"LN\" ); private static final Map<String, ?> changedCustomerPayload = aMapOf( customerPayload, \"lastName\", \"NLN\"); private static int id; @BeforeAll @DisplayName(\"create customer\") // optional friendly name for reporting purposes static void createCustomer() { id = http.post(\"/customers\", customerPayload, ((header, body) -> { return body.get(\"id\"); })); actual(id).shouldNot(equal(0)); } @Test @Order(1) @DisplayName(\"read customer\") void read() { http.get(\"/customers/\" + id, ((header, body) -> { body.should(equal(customerPayload)); })); } @Test @Order(2) // order dependence saves from creating customer on every test @DisplayName(\"update customer\") void update() { http.put(\"/customers/\" + id, changedCustomerPayload, ((header, body) -> { body.should(equal(changedCustomerPayload)); })); http.get(\"/customers/\" + id, ((header, body) -> { body.should(equal(changedCustomerPayload)); })); } @Test @Order(3) // but you can still run each method independently @DisplayName(\"delete customer\") void delete() { http.delete(\"/customers/\" + id, ((header, body) -> { header.statusCode().should(equal(204)); })); http.get(\"/customers/\" + id, ((header, body) -> { header.statusCode().should(equal(404)); })); id = -1; // marking as deleted to let cleanup step know that no delete is required } @AfterAll static void cleanup() { // optional (since we create new ids all the time) step to keep your environment clean if (id == -1) { return; } http.delete(\"/customers/\" + id); } }"],["generic-runners@@JUnit-5@@beforeallafterall","Generic Runners","JUnit 5","BeforeAll/AfterAll","Use @BeforeAll and @AfterAll to prepare and cleanup resources required for multiple test methods. Groovy package com.example.tests.junit5 import org.testingisdocumenting.webtau.junit5.WebTau import org.junit.jupiter.api.AfterAll import org.junit.jupiter.api.BeforeAll import org.junit.jupiter.api.DisplayName import org.junit.jupiter.api.Test import static org.testingisdocumenting.webtau.WebTauDsl.http @WebTau @DisplayName(\"customer query\") class CustomerQueryGroovyTest { private static def id1 // keep track of created ids to assert and cleanup later private static def id2 private static def id3 @BeforeAll @DisplayName(\"create customers\") static void createCustomers() { id1 = createCustomer(\"CQ_FN1\", \"CQ_LN1\") id2 = createCustomer(\"CQ_FN1\", \"CQ_LN2\") id3 = createCustomer(\"CQ_FN2\", \"CQ_LN2\") } @Test @DisplayName(\"query by first name\") void queryByFirstName() { http.get(\"/customers/search/first-name\", [name: \"CQ_FN1\"]) { body.should == [\"*id\" | \"firstName\" | \"lastName\"] { // star(*) marks key column so assertion is order agnostic __________________________________ id1 | \"CQ_FN1\" | \"CQ_LN1\" id2 | \"CQ_FN1\" | \"CQ_LN2\" } } } @Test @DisplayName(\"query by last name\") void queryByLastName() { http.get(\"/customers/search/last-name\", [name: \"CQ_LN2\"]) { body.should == [\"*id\" | \"firstName\" | \"lastName\"] { __________________________________ id2 | \"CQ_FN1\" | \"CQ_LN2\" id3 | \"CQ_FN2\" | \"CQ_LN2\" } } } @AfterAll @DisplayName(\"clean up\") static void cleanup() { [id1, id2, id3].each { http.delete(\"/customers/$it\") } } private static def createCustomer(String firstName, String lastName) { return http.post(\"/customers\", [firstName: firstName, lastName: lastName]) { id } } } Java package com.example.tests.junit5; import org.junit.jupiter.api.AfterAll; import org.junit.jupiter.api.BeforeAll; import org.junit.jupiter.api.DisplayName; import org.junit.jupiter.api.Test; import java.util.Map; import java.util.stream.Stream; import static org.testingisdocumenting.webtau.WebTauDsl.*; @DisplayName(\"customer query\") class CustomerQueryJavaTest { private static Integer id1; // keep track of created ids to assert and cleanup later private static Integer id2; private static Integer id3; @BeforeAll @DisplayName(\"create customers\") static void createCustomers() { id1 = createCustomer(\"CQ_FN1\", \"CQ_LN1\"); id2 = createCustomer(\"CQ_FN1\", \"CQ_LN2\"); id3 = createCustomer(\"CQ_FN2\", \"CQ_LN2\"); } @Test @DisplayName(\"query by first name\") void queryByFirstName() { http.get(\"/customers/search/first-name\", http.query(\"name\", \"CQ_FN1\"), (header, body) -> { body.should(equal(table(\"*id\", \"firstName\", \"lastName\", // star(*) marks key column so assertion is order agnostic ________________________________, id1, \"CQ_FN1\" , \"CQ_LN1\", id2, \"CQ_FN1\" , \"CQ_LN2\"))); }); } @Test @DisplayName(\"query by last name\") void queryByLastName() { http.get(\"/customers/search/last-name\", http.query(\"name\", \"CQ_LN2\"), (header, body) -> { body.should(equal(table(\"*id\", \"firstName\", \"lastName\", ________________________________, id2, \"CQ_FN1\" , \"CQ_LN2\", id3, \"CQ_FN2\" , \"CQ_LN2\"))); }); } @AfterAll @DisplayName(\"clean up\") static void cleanup() { Stream.of(id1, id2, id3).forEach(id -> http.delete(\"/customers/\" + id)); } private static int createCustomer(String firstName, String lastName) { Map<String, Object> payload = aMapOf( \"firstName\", firstName, \"lastName\", lastName); return http.post(\"/customers\", payload, ((header, body) -> { return body.get(\"id\"); })); } }"],["generic-runners@@JUnit-5@@maven-import","Generic Runners","JUnit 5","Maven Import","<dependency> <groupId>org.testingisdocumenting.webtau</groupId> <artifactId>webtau-junit5</artifactId> <version>1.41</version> </dependency>"],["generic-runners@@JUnit-5@@testfactory","Generic Runners","JUnit 5","TestFactory","With the additional annotation @TestFactory you can use TableData as an easy-to-read source of similar but independent tests where each row is treated as its own test (comparable to JUnit 4's parameterized tests), optionally with a descriptive label. Here are examples of parameterized tests with and without labels, and how an IDE uses the label for display purposes: @TestFactory def \"individual tests use generated display labels\"() { [\"price\" | \"quantity\" | \"outcome\"] { _________________________________ 10 | 30 | 300 -10 | 30 | -300 }.test { PriceCalculator.calculate(price, quantity).should == outcome } } @TestFactory def \"individual tests can use an optional display label to clarify the use case\"() { [\"label\" | \"price\" | \"quantity\" | \"outcome\"] { ___________________________________________________ \"positive price\" | 10 | 30 | 300 \"negative price\" | -10 | 30 | -300 }.test { PriceCalculator.calculate(price, quantity).should == outcome } }"],["JVM-business-logic@@data-driven@@data-focused-tests","JVM Business Logic","Data Driven","Data Focused Tests","Webtau simplifies writing REST/GraphQL/Browser/DB/CLI tests. On top of that if the logic behind those layers is written in JVM based language, webtau also simplifies testing logic behind those layers directly.Webtau makes tests to be focused on input and output by reducing boilerplate."],["JVM-business-logic@@data-driven@@simplified-input-preparation","JVM Business Logic","Data Driven","Simplified Input Preparation","Groovy @Test void \"diversified teams should have various levels and time at company\"() { def employeeData = [ \"id\" | \"level\" | \"monthsAtCompany\"] { _______________________________________ \"bob\" | 2 | 12 \"smith\" | 4 | 34 \"john\" | 3 | 20 } def diversified = peopleManagement.diversityLevel(employees(employeeData)) diversified.should == true } Java @Test public void diversifiedTeamsShouldHaveVariousLevelsAndTimeAtCompany() { TableData employeeData = table( \"id\", \"level\", \"monthsAtCompany\").values( \"bob\", 2, 12, \"smith\", 4, 34, \"john\", 3, 20); boolean diversified = peopleManagement.diversityLevel(employees(employeeData)); actual(diversified).should(equal(true)); }"],["JVM-business-logic@@data-driven@@simplified-output-validation","JVM Business Logic","Data Driven","Simplified Output Validation","Complex data and assertions are first class citizens. Groovy @Test void \"provides access to new joiners\"() { TableData allEmployees = [\"id\" | \"level\" | \"monthsAtCompany\"] { ______________________________________ \"alice\" | 5 | 1 \"bob\" | 3 | 0 \"smith\" | 4 | 1 \"cat\" | 4 | 0 } addEmployees(allEmployees) dao.thisWeekJoiners().should == [\"id\" | \"level\" | \"monthsAtCompany\"] { ______________________________________ \"bob\" | 3 | 0 \"cat\" | 4 | 0 } } Java @Test public void providesAccessToNewJoiners() { TableData allEmployees = table( \"id\", \"level\", \"monthsAtCompany\", ____________________________________, \"alice\", 5, 1, \"bob\", 3, 0, \"smith\", 4, 1, \"cat\", 4, 0); addEmployees(allEmployees); actual(dao.thisWeekJoiners()).should(equal(table( \"*id\", \"level\", \"monthsAtCompany\", ____________________________________, \"bob\", 3, 0, \"cat\", 4, 0))); } Note: The examples above assumes import static org.testingisdocumenting.webtau.WebTauCore.* or import static org.testingisdocumenting.webtau.WebTauDsl.* . For more TableData features, check reference/table-data reference page"],["JVM-business-logic@@documentation-artifacts@@living-document","JVM Business Logic","Documentation Artifacts","Living Document","In your test you can capture input and output and save it to a file. By using documentation systems you can use the captured artifacts to render business friendly documentation of your business logic.As system evolves, so do your tests and so does your documentation. Essentially you will have a living document describing your system."],["JVM-business-logic@@documentation-artifacts@@capture-input","JVM Business Logic","Documentation Artifacts","Capture Input","Use doc.capture to save a test captured value to a file. Example below assumes core static import. import static org.testingisdocumenting.webtau.WebTauCore.*; TableData allEmployees = table( \"id\", \"level\", \"monthsAtCompany\", ____________________________________, \"alice\", 5, 1, \"bob\", 3, 0, \"smith\", 4, 1, \"cat\", 4, 0); addEmployees(allEmployees); doc.capture(\"all-employees\", allEmployees); // capture all employees for documentation purposes"],["JVM-business-logic@@documentation-artifacts@@capture-expected-output","JVM Business Logic","Documentation Artifacts","Capture Expected Output","Use doc.expected.capture to save most recent expected value. actual(dao.thisWeekJoiners()).should(equal(table( \"*id\", \"level\", \"monthsAtCompany\", ____________________________________, \"bob\", 3, 0, \"cat\", 4, 0))); doc.expected.capture(\"new-joiners\"); // capture expected new joiners for documentation purposes"],["JVM-business-logic@@documentation-artifacts@@znai-example","JVM Business Logic","Documentation Artifacts","Znai Example","Since this documentation is rendered using https://github.org/testingisdocumenting/znai Znai here is an example of how to use the captured artifacts. https://github.org/testingisdocumenting/znai Znai has :include-table: plugin to render a table giving a json or CSV file. text :include-table: doc-artifacts/all-employees.json :include-table: doc-artifacts/new-joiners.json Below is the example of the business logic rendered as documentation.Our HR system consider all employees that has been in the company less than a month as new joiners. For example, giving employees: id level monthsAtCompany alice 5 1 bob 3 0 smith 4 1 cat 4 0 System will list following employees as new joiners: id level monthsAtCompany bob 3 0 cat 4 0"],["reference@@table-data@@create","Reference","Table Data","Create","Use language specific DSL to create TableData instance: Groovy [\"Col A\" | \"Col B\" | \"Col C\"] { ________________________________ \"v1a\" | \"v1b\" | \"v1c\" \"v2a\" | \"v2b\" | \"v2c\" } Java table(\"Col A\", \"Col B\", \"Col C\", ________________________________, \"v1a\", \"v1b\", \"v1c\", \"v2a\", \"v2b\", \"v2c\") Note: The example above assumes import static org.testingisdocumenting.webtau.WebTauCore.* or import static org.testingisdocumenting.webtau.WebTauDsl.* . Additionally WebTauCore has header-separating lines defined using underscores ___ of various lengths, which you can optionally use for aesthetics. Using ____ underscore is optional and is there for aesthetics only Groovy [\"Col A\" | \"Col B\" | \"Col C\"] { \"v1a\" | \"v1b\" | \"v1c\" \"v2a\" | \"v2b\" | \"v2c\" } Java table(\"Col A\", \"Col B\", \"Col C\").values( \"v1a\", \"v1b\", \"v1c\", \"v2a\", \"v2b\", \"v2c\")"],["reference@@table-data@@key-columns","Reference","Table Data","Key Columns","Use * in front of a column to specify it as a key column Groovy [\"*id\" | \"Name\" | \"Type\"] { ___________________________ \"id1\" | \"N\" | \"T\" \"id2\" | \"N2\" | \"T2\" \"id3\" | \"N\" | \"T\" } Java table(\"*id\" , \"Name\" , \"Type\", _______________________, \"id1\" , \"N\" , \"T\", \"id2\" , \"N2\" , \"T2\", \"id3\" , \"N\" , \"T\") To access a value by key column Groovy def found = tableData.find(key(\"id2\")) found.Name.should == \"N2\" Java Record found = tableData.find(key(\"id2\")); actual(found.get(\"Name\")).should(equal(\"N2\")); To change key columns of an existing table Groovy tableData.withNewKeyColumns(\"Name\", \"Type\") Java tableData.withNewKeyColumns(\"Name\", \"Type\") Note: withNewKeyColumns creates new table and validates new key column uniqueness"],["reference@@table-data@@permutations","Reference","Table Data","Permutations","Use permute(v1, v2) to automatically generate multiple rows. Groovy [\"Col A\" | \"Col B\" | \"Col C\"] { ___________________________________________________________ permute(true, false) | \"v1b\" | permute('a', 'b') \"v2a\" | permute(10, 20) | \"v2c\" } Java table(\"Col A\" , \"Col B\" , \"Col C\", ________________________________________________________________, permute(true, false), \"v1b\" , permute('a', 'b'), \"v2a\" , permute(10, 20) , \"v2c\") Col A Col B Col C true v1b a false v1b a true v1b b false v1b b v2a 10 v2c v2a 20 v2c"],["reference@@table-data@@guid","Reference","Table Data","GUID","Use cell.guid to automatically generate unique ids. Groovy [\"ID\" | \"Col A\" | \"Col B\" | \"Col C\"] { ________________________________________________________________________ cell.guid | permute(true, false) | \"v1b\" | permute('a', 'b') cell.guid | \"v2a\" | permute(10, 20) | \"v2c\" } Java table(\"ID\" , \"Col A\" , \"Col B\" , \"Col C\", ______________________________________________________________________, cell.guid, permute(true, false), \"v1b\" , permute('a', 'b'), cell.guid, \"v2a\" , permute(10, 20) , \"v2c\") ID Col A Col B Col C c3bf4807-e918-418b-9733-019d6846590c true v1b a 798b3873-5942-4396-a4a2-9449d45ce2a5 false v1b a 83fea072-6e05-4af8-86d9-7c7bbfb3a738 true v1b b ded35973-37b4-4c8f-b0d4-1626ac08316c false v1b b 404122a6-e2ff-4ee0-b4b1-1bcd784ae277 v2a 10 v2c 07063eaf-b740-433c-97af-012240a7389c v2a 20 v2c"],["reference@@table-data@@replace","Reference","Table Data","Replace","Use table.replace(before, after) to replace values in a table. Groovy [\"Col A\" | \"Col B\" | \"Col C\"] { ________________________________ \"v1a\" | \"v1b\" | \"v1c\" \"v2a\" | \"v2b\" | \"v2c\" } tableData.replace(\"v1b\", \"v1b_\") Java table(\"Col A\", \"Col B\", \"Col C\", ________________________________, \"v1a\", \"v1b\", \"v1c\", \"v2a\", \"v2b\", \"v2c\") tableData.replace(\"v1b\", \"v1b_\") Col A Col B Col C v1a v1b_ v1c v2a v2b v2c"],["reference@@table-data@@cell-above-value-reference","Reference","Table Data","Cell Above Value Reference","Use cell.above to refer to the previous row value Groovy [\"Name\" | \"Start Date\" | \"Games To Play\" ] { ______________________________________________________ \"John\" | LocalDate.of(2016, 6, 20) | 10 \"Bob\" | cell.above | 8 \"Mike\" | cell.above | 14 \"Drew\" | LocalDate.of(2016, 6, 22) | 10 \"Pete\" | cell.above | 11 \"Max\" | cell.above | 3 } Java table(\"Name\", \"Start Date\" , \"Games To Play\", __________________________________________________, \"John\", LocalDate.of(2016, 6, 20), 10, \"Bob\" , cell.above , 8, \"Mike\", cell.above , 14, \"Drew\", LocalDate.of(2016, 6, 22), 10, \"Pete\", cell.above , 11, \"Max\" , cell.above , 3) Name Start Date Games To Play John 2016-06-20 10 Bob 2016-06-20 8 Mike 2016-06-20 14 Drew 2016-06-22 10 Pete 2016-06-22 11 Max 2016-06-22 3"],["reference@@table-data@@cell-above-math","Reference","Table Data","Cell Above Math","Use cell.above.plus|minus to generate a derived value based on the previous row value Groovy [\"Name\" | \"Start Date\" | \"Games To Play\" ] { ______________________________________________________ \"John\" | LocalDate.of(2016, 6, 20) | 10 \"Bob\" | cell.above | cell.above + 1 \"Mike\" | cell.above | cell.above + 1 } Java table(\"Name\", \"Start Date\" , \"Games To Play\", ________________________________________________________________, \"John\", LocalDate.of(2016, 6, 20), 10, \"Bob\" , cell.above , cell.above.plus(1), \"Mike\", cell.above , cell.above.plus(1)) Name Start Date Games To Play John 2016-06-20 10 Bob 2016-06-20 11 Mike 2016-06-20 12 Extract cell.above.operation to make your intentions clearer Groovy def increment = cell.above + 1 [\"Name\" | \"Start Date\" | \"Games To Play\" ] { ______________________________________________________ \"John\" | LocalDate.of(2016, 6, 20) | 10 \"Bob\" | cell.above | increment \"Mike\" | cell.above | increment } Java TableDataCellValueGenerator<?> increment = cell.above.plus(1) table(\"Name\", \"Start Date\" , \"Games To Play\", ________________________________________________________________, \"John\", LocalDate.of(2016, 6, 20), 10, \"Bob\" , cell.above , increment, \"Mike\", cell.above , increment)"]]
/*
 * Copyright 2019 TWO SIGMA OPEN SOURCE, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

znaiSearchIdx = lunr(function () {
    this.ref('id')
    this.field('section')
    this.field('pageTitle')
    this.field('pageSection')
    this.field('text')

    this.metadataWhitelist = ['position']

    znaiSearchData.forEach(function (e) {
        this.add({
            id: e[0],
            section: e[1],
            pageTitle: e[2],
            pageSection: e[3],
            text: e[4],
        })
    }, this)
})
