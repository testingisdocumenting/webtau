znaiSearchData = [["getting-started@@what-is-this@@webtau","Getting Started","What Is This","WebTau","WebTau (Web Test automation) - concise and expressive way to write end-to-end and unit tests.Test your application across multiple layers and use unique features: #rest-api REST API #websocket WebSocket #graphql-api GraphQL API #persona Authorization Personas #browser Browser #fake-static-and-proxy-servers Fake, Static And Proxy Servers #database Database #cli CLI #business-logic-jvm Business Logic (JVM only) #repl REPL #reporting Reporting #documentation-assistance Documentation Assistance There are many modules, but you can use any module you need independently, or use all the modules at once with convenient single imports."],["getting-started@@what-is-this@@scripting-and-junit","Getting Started","What Is This","Scripting And JUnit","Tests can be written and groovy-standalone-runner/introduction executed as scripts via command line or using junit5/getting-started JUnit integration and build systems. Groovy scenario(\"search by specific query\") { search.submit(\"search this\") search.numberOfResults.waitToBe > 1 } webtau testscript.groovy Java public class WebSearchJavaTest { @Test public void searchByQuery() { search.submit(\"search this\"); search.numberOfResults.waitToBe(greaterThan(1)); } }"],["getting-started@@what-is-this@@rest-api","Getting Started","What Is This","Rest API","WebTau http module lets you exercise and validate HTTP endpoints. It provides a simplified way to make HTTP calls and validate responsesNow with HTTP/data-coverage Data Coverage. Groovy private final def livePrice = http.resource(\"/prices/:ticker\").price ... livePrice.of(\"IBM\").waitToBe > 115 Java private final HttpLazyResponseValue livePrice = http.resource(\"/prices/:ticker\").get(\"price\"); ... livePrice.of(\"IBM\").waitToBe(greaterThan(115))); > waiting for value of /prices/IBM: price to be greater than 115 > [1/3] executing HTTP GET http://localhost:39175/prices/IBM . header.statusCode equals 200 (0ms) response (application/json): { \"price\": **100** } . [1/3] executed HTTP GET http://localhost:39175/prices/IBM (6ms) > [3/3] executing HTTP GET http://localhost:39175/prices/IBM . header.statusCode equals 200 (0ms) response (application/json): { \"price\": ~~120~~ } . [3/3] executed HTTP GET http://localhost:39175/prices/IBM (2ms) . value of /prices/IBM: price greater than 115 (220ms) Groovy package scenarios.rest import static org.testingisdocumenting.webtau.WebTauGroovyDsl.* scenario(\"check weather\") { http.get(\"/weather\") { temperature.shouldBe < 100 } } package com.example.tests.junit5 import org.junit.jupiter.api.Test import org.testingisdocumenting.webtau.junit5.WebTau import static org.testingisdocumenting.webtau.WebTauGroovyDsl.* @WebTau class WeatherGroovyTest { @Test void checkWeather() { http.get(\"/weather\") { temperature.shouldBe < 100 } } } Java package com.example.tests.junit5; import org.junit.jupiter.api.Test; import org.testingisdocumenting.webtau.junit5.WebTau; import static org.testingisdocumenting.webtau.WebTauDsl.*; @WebTau public class WeatherJavaTest { @Test public void checkWeather() { http.get(\"/weather\", (header, body) -> { body.get(\"temperature\").shouldBe(lessThan(100)); }); } } > executing HTTP GET http://localhost:42733/weather . body.temperature less than 100 (0ms) . header.statusCode equals 200 (0ms) response (application/json): { \"temperature\": ~~88~~ } . executed HTTP GET http://localhost:42733/weather (30ms) HTTP/CRUD-example Read More"],["getting-started@@what-is-this@@websocket","Getting Started","What Is This","WebSocket","WebTau websocket module lets your send, receive and validate websocket messages in a convenient synchronous manner. Groovy def wsSession = websocket.connect(\"/prices\") wsSession.send([symbol: \"IBM\"]) wsSession.received.waitTo == [ price: greaterThan(100), symbol: \"IBM\"] wsSession.close() Java var wsSession = websocket.connect(\"/prices\"); wsSession.send(map(\"symbol\", \"IBM\")); wsSession.received.waitTo(equal(map( \"price\", greaterThan(100), \"symbol\", \"IBM\"))); wsSession.close(); > connecting to websocket /prices . connected to websocket ws://localhost:34197/prices (10ms) > sending text message to ws://localhost:34197/prices {\"symbol\": \"IBM\"} . sent text message to ws://localhost:34197/prices (1ms) > waiting for received from ws://localhost:34197/prices to equal {\"price\": <greater than 100>, \"symbol\": \"IBM\"} > [1/25] polling websocket message {\"symbol\": \"IBM\", \"price\": 77} . [1/25] polled new message (1ms) > [25/25] polling websocket message {\"symbol\": \"IBM\", \"price\": 101} . [25/25] polled new message (0ms) . received from ws://localhost:34197/prices equals {\"price\": <greater than 100>, \"symbol\": \"IBM\"} (207ms) > closing websocket ws://localhost:34197/prices . closed websocket ws://localhost:34197/prices (0ms) web-socket/received-messages Read More"],["getting-started@@what-is-this@@graphql-api","Getting Started","What Is This","GraphQL API","WebTau graphql module lets you exercise and validate a GraphQL API. It provides a simplified way to access the JSON response of an end-point and provides a DSL to execute queries and mutations. Groovy package scenarios.rest import static org.testingisdocumenting.webtau.WebTauGroovyDsl.* scenario(\"check weather\") { def query = \"{ weather { temperature } }\"; graphql.execute(query) { weather.temperature.shouldBe < 100 } } package com.example.tests.junit4 import org.junit.Test import org.junit.runner.RunWith import org.testingisdocumenting.webtau.junit4.WebTauRunner import static org.testingisdocumenting.webtau.WebTauDsl.graphql @RunWith(WebTauRunner.class) class GraphQLWeatherGroovyIT { @Test void checkWeather() { def query = \"{ weather { temperature } }\"; graphql.execute(query) { weather.temperature.shouldBe < 100 } } } Java package com.example.tests.junit4; import org.junit.Test; import org.junit.runner.RunWith; import org.testingisdocumenting.webtau.junit4.WebTauRunner; import static org.testingisdocumenting.webtau.WebTauDsl.*; @RunWith(WebTauRunner.class) public class GraphQLWeatherJavaIT { @Test public void checkWeather() { String query = \"{ weather { temperature } }\"; graphql.execute(query, (header, body) -> { body.get(\"data.weather.temperature\").shouldBe(lessThan(100)); }); } } GraphQL/queries-and-mutations Read More"],["getting-started@@what-is-this@@persona","Getting Started","What Is This","Persona","Use persona/introduction Persona concept to test API Authorization and collaboration Web Apps like chats and editors. Groovy scenario(\"my bank balance\") { Alice { http.get(\"/statement\") { balance.shouldBe > 100 } } Bob { http.get(\"/statement\") { balance.shouldBe < 50 } } } Java @WebTau public class PersonaHttpJavaTest { @Test public void checkBalance() { Alice.execute(() -> http.get(\"/statement\", (header, body) -> { body.get(\"balance\").shouldBe(greaterThan(100)); })); Bob.execute(() -> http.get(\"/statement\", (header, body) -> { body.get(\"balance\").shouldBe(lessThan(50)); })); } }"],["getting-started@@what-is-this@@browser","Getting Started","What Is This","Browser","WebTau browser module lets you interact with a browser.High level abstractions streamline location, assertion and async logic.WebTau leverages https://www.selenium.dev Selenium WebDriver to do the heavy lifting. Groovy package scenarios.ui import static org.testingisdocumenting.webtau.WebTauGroovyDsl.* import static pages.Pages.* scenario(\"search by specific query\") { search.submit(\"search this\") search.numberOfResults.waitToBe > 1 } package pages import static org.testingisdocumenting.webtau.WebTauDsl.* class SearchPage { def header = $(\"#header\") def welcomeMessage = $(\"#welcome\") def searchMessage = $(\"#message\") def box = $(\"#search-box\") def resultsArea = $(\"#results\") def results = $(\"#results .result\") def numberOfResults = results.count def submit(query) { browser.open(\"/search\") box.setValue(query) box.sendKeys(browser.keys.enter) } } package pages class Pages { static final def search = new SearchPage() } Java package com.example.tests.junit5; import org.junit.jupiter.api.Test; import org.testingisdocumenting.webtau.junit5.WebTau; import static com.example.tests.junit5.pages.Pages.*; import static org.testingisdocumenting.webtau.WebTauDsl.*; @WebTau public class WebSearchJavaTest { @Test public void searchByQuery() { search.submit(\"search this\"); search.numberOfResults.waitToBe(greaterThan(1)); } } package com.example.tests.junit5.pages; import org.testingisdocumenting.webtau.browser.page.PageElement; import org.testingisdocumenting.webtau.browser.page.PageElementValue; import static org.testingisdocumenting.webtau.WebTauDsl.*; public class SearchPage { private final PageElement box = $(\"#search-box\"); private final PageElement results = $(\"#results .result\"); public final PageElementValue<Integer> numberOfResults = results.count; public void submit(String query) { browser.open(\"/search\"); box.setValue(query); box.sendKeys(browser.keys.enter); } } package com.example.tests.junit5.pages; public class Pages { public static SearchPage search = new SearchPage(); } > initializing webdriver for chrome . initialized webdriver for chrome (501ms) > opening http://localhost:42733/search . opened http://localhost:42733/search (48ms) > setting value search this to by css #search-box > clearing by css #search-box . cleared by css #search-box (42ms) > sending keys search this to by css #search-box . sent keys search this to by css #search-box (58ms) . set value search this to by css #search-box (131ms) > sending keys <enter> to by css #search-box . sent keys <enter> to by css #search-box (30ms) > waiting for count of by css #results .result to be greater than 1 . count of by css #results .result greater than 1 (12ms) browser/basic-configuration Read More"],["getting-started@@what-is-this@@fake-static-and-proxy-servers","Getting Started","What Is This","Fake, Static And Proxy Servers","WebTau server module lets you create and control static, fake and proxy servers:Static servers to quickly host HTML, JSON, and similar content Fake servers to control response based request Proxy servers to simulate outages and record interactions for failures investigation def myServer = server.serve(\"my-server\", \"data/staticcontent\") def router = server.router() .get(\"/hello/:name\") { request -> server.response([message: \"hello ${request.param(\"name\")}\"]) } .get(\"/bye/:name\") { request -> server.response([message: \"bye ${request.param(\"name\")}\"]) } def proxyServer = server.proxy(\"test-proxy-server\", targetServer.baseUrl) You can apply overrides to any created server. You can also put servers into a \"bad\" state. proxyServer.markUnresponsive() def router = server.router() .get(\"/hello/:name\") {request -> server.response([message: \"hello ${request.param(\"name\")}\"]) } myServer.addOverride(router) servers/introduction Read More"],["getting-started@@what-is-this@@database","Getting Started","What Is This","Database","WebTau db module streamlines databases data setup, assertion and waiting on. database/introduction Read More def PRICES = db.table(\"PRICES\") PRICES << [ \"id\" | \"description\" | \"available\" | \"type\" | \"price\" ] { _____________________________________________________________________________________________ cell.guid | \"nice set\" | true | \"card\" | 1000 // cell.guid generates random guid that can be used for ids cell.guid | \"nice set\" | true | \"card\" | cell.above + 10 // cell.above refers values above and can be modified with simple math operations cell.guid | \"another set\" | permute(true, false) | permute(\"rts\", \"fps\") | cell.above + 20 } // permute generates additional rows generating new rows with all the permutations"],["getting-started@@what-is-this@@cli","Getting Started","What Is This","CLI","WebTau cli module helps with running and testing command line tools cli/introduction Read More cli.run('echo hello world') { output.should contain('hello') output.should contain('world') }"],["getting-started@@what-is-this@@business-logic-jvm","Getting Started","What Is This","Business Logic (JVM)","Powerful WebTau matchers help with complex data validation and provide rich output to help with failure investigation: matchers/introduction Read More Groovy List<Account> accounts = fetchAccounts() TableData expected = [\"*id\" | \"name\" | \"address\"] { // id is a key column _________________________________________ \"ac2\" | \"Works\" | [zipCode: \"zip2\"] // when key is present, comparison is order agnostic \"ac1\" | \"Home\" | [zipCode: \"zip1\"] \"ac3\" | \"My Account\" | [zipCode: \"zip8\"] } accounts.should == expected Java List<Account> accounts = fetchAccounts(); TableData expected = table(\"*id\", \"name\", \"address\", // id is a key column ________________________________________, \"ac2\", \"Works\", map(\"zipCode\", \"zip2\"), // when key is present, comparison is order agnostic \"ac1\", \"Home\", map(\"zipCode\", \"zip1\"), \"ac3\", \"My Account\", map(\"zipCode\", \"zip8\")); actual(accounts).should(equal(expected)); X failed expecting [value] to equal *id │ name │ address \"ac2\" │ \"Works\" │ {\"zipCode\": \"zip2\"} \"ac1\" │ \"Home\" │ {\"zipCode\": \"zip1\"} \"ac3\" │ \"My Account\" │ {\"zipCode\": \"zip8\"}: [value][2].address.zipCode: actual: \"zip3\" <java.lang.String> expected: \"zip8\" <java.lang.String> ^ [value][1].name: actual: \"Work\" <java.lang.String> expected: \"Works\" <java.lang.String> ^ (2ms) address │ description │ id │ name {\"city\": \"TC1\", \"zipCode\": \"zip1\"} │ \"test account\" │ \"ac1\" │ \"Home\" {\"city\": \"TC2\", \"zipCode\": \"zip2\"} │ \"test account\" │ \"ac2\" │ **\"Work\"** {\"city\": \"TC3\", \"zipCode\": **\"zip3\"**} │ \"test account\" │ \"ac3\" │ \"My Account\""],["getting-started@@what-is-this@@repl","Getting Started","What Is This","REPL","Use powerful REPL/experiments REPL mode to significantly speed up end-to-end tests development. Build your tests one step at a time without losing time on restarts. webtau:000> $(\"p\") found single element using by css p innerText: hello web page <p>hello web page</p>"],["getting-started@@what-is-this@@reporting","Getting Started","What Is This","Reporting","Leverage out of the box report/introduction rich reporting. Report captures everything you do. Single self-sufficient file that can be slacked or emailed. Permalinks let you share the exact failure problem with your colleagues."],["getting-started@@what-is-this@@documentation-assistance","Getting Started","What Is This","Documentation Assistance","WebTau helps you to capture test artifacts like HTTP/documentation-artifacts API Responses, browser/documentation-artifacts screenshots, command line output to automate your user facing documentation creation.Below is the example of API documentation with example of requests/response captured by a test: Request Responses 200 201"],["getting-started@@why@@reporting","Getting Started","Why","Reporting","WebTau in its core captures test actions and assertions. Everything you do, every match that is passed or failed is being recorded.Information is available in console output, so you don't need to sprinkle println statements everywhere. And all the captured information is available as self-contained rich HTML report.Single report HTML file that you can email, slack or host on an FS and open with no servers required. Groovy TableData table = data.csv.table(\"data/table.csv\") Java TableData table = data.csv.table(\"data/table.csv\"); > reading csv from file or resource data/table.csv . read 3 lines of csv from file /home/runner/work/webtau/webtau/webtau-feature-testing/examples/data/table.csv (0ms)"],["getting-started@@why@@high-level-api","Getting Started","Why","High Level API","WebTau provides high level API to interact with HTTP, Browser, Database, File System. It is easy to use, requires minimum setup and every action is reported.You can use WebTau to only test a single layer of your product, but you can als combine layers in a single test and setup data using HTTP layer and validate using a Browser layer or a DB layer. All is with a single configuration, consistent set of matchers and rich reporting."],["getting-started@@why@@syntax-sugar","Getting Started","Why","Syntax Sugar","WebTau provides DSL to make common testing operations succinct. Syntax sugar is available for Java and Groovy and since WebTau core is Java, additional syntax sugar can be added to languages like Kotlin and Scala. Groovy [\"Name\" | \"Start Date\" | \"Games To Play\" ] { ______________________________________________________ \"John\" | LocalDate.of(2016, 6, 20) | 10 \"Bob\" | cell.above | cell.above + 1 \"Mike\" | cell.above | cell.above + 1 } Java table(\"Name\", \"Start Date\" , \"Games To Play\", ________________________________________________________________, \"John\", LocalDate.of(2016, 6, 20), 10, \"Bob\" , cell.above , cell.above.plus(1), \"Mike\", cell.above , cell.above.plus(1))"],["getting-started@@why@@repl","Getting Started","Why","REPL","Writing end-to-end tests is hard and there are a lot of excuses not write one. End-to-end test feedback loop is usually long and slow. WebTau provides REPL/experiments REPL mode to help you experiment with API and write a test in incremental fashion. webtau:000> http.get(\"https://jsonplaceholder.typicode.com/todos/1\") > executing HTTP GET https://jsonplaceholder.typicode.com/todos/1 . header.statusCode equals 200 (4ms) response (application/json; charset=utf-8): { \"userId\": 1, \"id\": 1, \"title\": \"delectus aut autem\", \"completed\": false } . executed HTTP GET https://jsonplaceholder.typicode.com/todos/1 (480ms)"],["getting-started@@why@@documentation-artifacts","Getting Started","Why","Documentation Artifacts","Your users deserve useful and up-to date documentation. Manually maintaining documentation is hard and expensive. WebTau helps you to capture test artifacts during the tests, for exampleScreenshots (with annotations) API request/response examples CLI params and sample output Captured artifacts are agnostic to the documentation system. However, you can take a look at https://github.com/testingisdocumenting/znai Znai documentation system that was designed with documentation maintenance in mind. Enter search query Results are displayed in a grid"],["getting-started@@installation@@runners","Getting Started","Installation","Runners","To run WebTau tests you have a few options: #groovy-runner Standalone Groovy Runner #junit5 JUnit5 #junit4 JUnit4"],["getting-started@@installation@@groovy-runner","Getting Started","Installation","Groovy Runner","If you have https://brew.sh brew installed in your system use brew install testingisdocumenting/brew/webtau If you have https://sdkman.io sdkman installed in your system use sdk install webtau Alternatively, download and unzip https://repo.maven.apache.org/maven2/org/testingisdocumenting/webtau/webtau-dist/2.3/webtau-dist-2.3-webtau.zip WebTau. Add it to your PATH .Note: WebTau installed manually requires Java 17+ to be present in PATH webtau --example Navigate into todo example cd examples/todo import static org.testingisdocumenting.webtau.WebTauGroovyDsl.* scenario('fetch todo item') { http.get('/todos/1') { title.should == 'delectus aut autem' completed.should == false } } To run test webtau todolist.groovy --url=https://jsonplaceholder.typicode.com Note: using import is optional and is mainly for IDE auto completion. Imports are added implicitly during command line run. To integrate CLI run into maven build use: <dependency> <groupId>org.testingisdocumenting.webtau</groupId> <artifactId>webtau-groovy</artifactId> <version>2.3</version> </dependency> <plugin> <groupId>org.testingisdocumenting.webtau</groupId> <artifactId>webtau-maven-plugin</artifactId> <version>2.3</version> <executions> <execution> <phase>test</phase> <goals> <goal>run</goal> </goals> </execution> </executions> <configuration> <workingDir>${project.basedir}/src/main/groovy</workingDir> <env>integration</env> <url>http://optional-base-url</url> <config>optional-config-file-name-override.cfg.groovy</config> <reportPath>optional-report-path-override.html</reportPath> <failedReportPath>optional-failed-report-path-override.html</failedReportPath> <reportName>my service</reportName> <reportNameUrl>https://service-under-test</reportNameUrl> <noColor>false</noColor> <tests> <directory>${project.basedir}/src/main/groovy</directory> <includes> <include>scenarios/*.groovy</include> </includes> </tests> </configuration> </plugin> groovy-standalone-runner/introduction Learn more about Groovy Runner features"],["getting-started@@installation@@junit5","Getting Started","Installation","JUnit5","Groovy <dependency> <groupId>org.testingisdocumenting.webtau</groupId> <artifactId>webtau-groovy</artifactId> <version>2.3</version> </dependency> <dependency> <groupId>org.testingisdocumenting.webtau</groupId> <artifactId>webtau-junit5</artifactId> <version>2.3</version> </dependency> package com.example.tests.junit5 import org.junit.jupiter.api.Test import org.testingisdocumenting.webtau.junit5.WebTau import static org.testingisdocumenting.webtau.WebTauGroovyDsl.* // convenient single import for all things webtau @WebTau // annotation required for reports generation class JUnit5ExampleGroovyTest { @Test void \"my test\"() { } } Java <dependency> <groupId>org.testingisdocumenting.webtau</groupId> <artifactId>webtau</artifactId> <version>2.3</version> </dependency> <dependency> <groupId>org.testingisdocumenting.webtau</groupId> <artifactId>webtau-junit5</artifactId> <version>2.3</version> </dependency> package com.example.tests.junit5; import org.junit.jupiter.api.Test; import org.testingisdocumenting.webtau.junit5.WebTau; import static org.testingisdocumenting.webtau.WebTauDsl.*; // convenient single import for all things webtau @WebTau // annotation required for reports generation public class JUnit5ExampleJavaTest { @Test public void myTest() { } } junit5/getting-started Learn more about JUnit5 features"],["getting-started@@installation@@junit4","Getting Started","Installation","JUnit4","Groovy <dependency> <groupId>org.testingisdocumenting.webtau</groupId> <artifactId>webtau-groovy</artifactId> <version>2.3</version> </dependency> <dependency> <groupId>org.testingisdocumenting.webtau</groupId> <artifactId>webtau-junit4</artifactId> <version>2.3</version> </dependency> package com.example.tests.junit4 import org.junit.Test import org.junit.runner.RunWith import org.testingisdocumenting.webtau.junit4.WebTauRunner import static org.testingisdocumenting.webtau.WebTauGroovyDsl.* // convenient single import for all things webtau @RunWith(WebTauRunner.class) // webtau runner to generate reports class JUnit4ExampleGroovyTest { @Test void \"my test\"() { } } Java <dependency> <groupId>org.testingisdocumenting.webtau</groupId> <artifactId>webtau</artifactId> <version>2.3</version> </dependency> <dependency> <groupId>org.testingisdocumenting.webtau</groupId> <artifactId>webtau-junit4</artifactId> <version>2.3</version> </dependency> package com.example.tests.junit4; import org.junit.Test; import org.junit.runner.RunWith; import org.testingisdocumenting.webtau.junit4.WebTauRunner; import static org.testingisdocumenting.webtau.WebTauDsl.*; // convenient single import for all things webtau @RunWith(WebTauRunner.class) // webtau runner to generate reports public class JUnit4ExampleJavaTest { @Test public void myTest() { } } junit5/JUnit-4 Learn more about JUnit4 features"],["getting-started@@configuration@@config-file","Getting Started","Configuration","Config File","WebTau let you specify services url, browser settings, DB url connections, etc in a config file. Depending on getting-started/installation runner you use WebTau will read data from a different place. Groovy When you use the Groovy runner, it will look for webtau.cfg.groovy file (default). url = \"http://localhost:8080\" Note: WebTau treats groovy config file as code Java When you use JUnit like runners, e.g. getting-started/installation#junit5 JUnit5, WebTau expects file named webtau.properties to be present in test classpath, e.g. test resources: url = http://localhost:8080 To change config file location use Groovy webtau --config my.conf.groovy Java -Dwebtau.properties=my.webtau.properties"],["getting-started@@configuration@@environments","Getting Started","Configuration","Environments","WebTau supports environment specific config values, and a way to select which environment to set active during tests run. Groovy url = \"http://localhost:8080\" environments { qa { url = \"http://server.qa:8080\" } } To select an active environment using groovy-standalone-runner/introduction Groovy Standalone Runner you can pass env as cli parameter webtau --env=qa Additionally you can use environment varialbe to set an active environment: WEBTAU_ENV=qa . Java url = http://localhost:8080 environments.qa.url = http://server.qa:8080 To select an active environment you have two options:System property -Denv=qa Environment variable WEBTAU_ENV=qa"],["getting-started@@configuration@@overrides","Getting Started","Configuration","Overrides","WebTau has a list of options you can specify using config file: configuration/options url, browserId, etc.. You can override any value using configuration/options#environment-variable-options environment variables: export WEBTAU_URL=http://another-server export WEBTAU_CHROME_DRIVER_PATH=/path/to/chrome/driver In addition to environment variables, you can use a runner specific way to override: Groovy Standalone Runner In case of Groovy standalone runner, pass --<option>=<value> : webtau --waitTimeout=25000 --url=http://another-server JUnit Like Runners Pass system property via java -D option: -Durl=http://another-server"],["getting-started@@configuration@@disable-ansi-colors","Getting Started","Configuration","Disable ANSI Colors","By default, WebTau renders output using colors. Use noColor option to disable it. export WEBTAU_NO_COLOR=true -DnoColor=true webtau --noColor ..."],["HTTP@@introduction@@","HTTP","Introduction","","WebTau http module lets you exercise and validate HTTP endpoints. It provides a simplified way to make HTTP calls and validate responsesNow with HTTP/data-coverage Data Coverage. Groovy private final def livePrice = http.resource(\"/prices/:ticker\").price ... livePrice.of(\"IBM\").waitToBe > 115 Java private final HttpLazyResponseValue livePrice = http.resource(\"/prices/:ticker\").get(\"price\"); ... livePrice.of(\"IBM\").waitToBe(greaterThan(115))); > waiting for value of /prices/IBM: price to be greater than 115 > [1/3] executing HTTP GET http://localhost:39175/prices/IBM . header.statusCode equals 200 (0ms) response (application/json): { \"price\": **100** } . [1/3] executed HTTP GET http://localhost:39175/prices/IBM (6ms) > [3/3] executing HTTP GET http://localhost:39175/prices/IBM . header.statusCode equals 200 (0ms) response (application/json): { \"price\": ~~120~~ } . [3/3] executed HTTP GET http://localhost:39175/prices/IBM (2ms) . value of /prices/IBM: price greater than 115 (220ms) Groovy package scenarios.rest import static org.testingisdocumenting.webtau.WebTauGroovyDsl.* scenario(\"check weather\") { http.get(\"/weather\") { temperature.shouldBe < 100 } } package com.example.tests.junit5 import org.junit.jupiter.api.Test import org.testingisdocumenting.webtau.junit5.WebTau import static org.testingisdocumenting.webtau.WebTauGroovyDsl.* @WebTau class WeatherGroovyTest { @Test void checkWeather() { http.get(\"/weather\") { temperature.shouldBe < 100 } } } Java package com.example.tests.junit5; import org.junit.jupiter.api.Test; import org.testingisdocumenting.webtau.junit5.WebTau; import static org.testingisdocumenting.webtau.WebTauDsl.*; @WebTau public class WeatherJavaTest { @Test public void checkWeather() { http.get(\"/weather\", (header, body) -> { body.get(\"temperature\").shouldBe(lessThan(100)); }); } } > executing HTTP GET http://localhost:42733/weather . body.temperature less than 100 (0ms) . header.statusCode equals 200 (0ms) response (application/json): { \"temperature\": ~~88~~ } . executed HTTP GET http://localhost:42733/weather (30ms)"],["HTTP@@CRUD-example@@single-test-method","HTTP","CRUD Example","Single Test Method","We have an app that exposes create , read , update , and delete operations for customer records. Records are being served under /customers .Here is an example of a CRUD operations test. Groovy package scenarios.rest.springboot import static org.testingisdocumenting.webtau.WebTauGroovyDsl.* scenario(\"CRUD operations for customer\") { def customerPayload = [firstName: \"FN\", lastName: \"LN\"] // new customer data def id = http.post(\"/customers\", customerPayload) { return id // return id value from response body } http.get(\"/customers/${id}\") { body.should == customerPayload // only specified properties will be asserted against } def changedLastName = \"NLN\" http.put(\"/customers/${id}\", [*:customerPayload, lastName: changedLastName]) { lastName.should == changedLastName // specifying body is optional } http.get(\"/customers/${id}\") { firstName.should == \"FN\" lastName.should == changedLastName } def changedFirstName = \"NFN\" http.patch(\"/customers/${id}\", [firstName: changedFirstName]) http.get(\"/customers/${id}\") { firstName.should == changedFirstName lastName.should == changedLastName } http.delete(\"/customers/${id}\") { statusCode.should == 204 } http.get(\"/customers/${id}\") { statusCode.should == 404 } } Check HTTP/import-and-dependencies Import And Dependencies for prerequisites. Java package com.example.tests.junit5; import org.junit.jupiter.api.Test; import org.testingisdocumenting.webtau.junit5.WebTau; import static org.testingisdocumenting.webtau.WebTauDsl.*; @WebTau public class CustomerCrudJavaTest { @Test public void crud() { var customerPayload = http.json( // new customer data \"firstName\", \"FN\", \"lastName\", \"LN\"); int id = http.post(\"/customers\", customerPayload, ((header, body) -> { return body.get(\"id\"); // return id value from response body })); http.get(\"/customers/\" + id, ((header, body) -> { body.should(equal(customerPayload)); // only specified properties will be asserted against })); String changedLastName = \"NLN\"; var changedCustomerPayload = http.json( \"firstName\", \"FN\", \"lastName\", \"NLN\"); http.put(\"/customers/\" + id, changedCustomerPayload, ((header, body) -> { body.get(\"firstName\").should(equal(\"FN\")); body.get(\"lastName\").should(equal(changedLastName)); })); http.get(\"/customers/\" + id, ((header, body) -> { body.should(equal(changedCustomerPayload)); })); http.delete(\"/customers/\" + id, ((header, body) -> { header.statusCode.should(equal(204)); })); http.get(\"/customers/\" + id, ((header, body) -> { header.statusCode.should(equal(404)); })); } } Check HTTP/import-and-dependencies Import And Dependencies for prerequisites."],["HTTP@@CRUD-example@@generated-report","HTTP","CRUD Example","Generated Report","After test runs, WebTau generates report/introduction HTML report:Note: asserted values are being tracked and highlighted inside the report"],["HTTP@@CRUD-example@@separate-test-methods","HTTP","CRUD Example","Separate Test Methods","Groovy One of the benefits of separating one CRUD scenario into multiple is to be able to run one test at a time. In order to make each test runnable independently we will use createLazyResource . package scenarios.rest.springboot import static org.testingisdocumenting.webtau.WebTauGroovyDsl.* def customerPayload = [firstName: \"FN\", lastName: \"LN\"] def customer = createLazyResource(\"customer\") { // lazy resource to be created on the first access def id = http.post(\"/customers\", customerPayload) { return id } return new Customer(id: id, url: \"/customers/${id}\") // definition is below } scenario(\"customer create\") { customer.id.should != null // accessing resource for the first time will trigger POST (in this example) } scenario(\"customer read\") { http.get(customer.url) { // convenient re-use of url defined above body.should == customerPayload } } scenario(\"customer update\") { def changedLastName = \"NLN\" http.put(customer.url, [*:customerPayload, lastName: changedLastName]) { lastName.should == changedLastName } http.get(customer.url) { lastName.should == changedLastName } } scenario(\"customer delete\") { http.delete(customer.url) { statusCode.should == 204 } http.get(customer.url) { statusCode.should == 404 } } package scenarios.rest.springboot class Customer { Number id String url // store url of the created entity } Note: to run one scenario at a time use sscenario (additional s in front). groovy-standalone-runner/selective-run Read more Java One of the benefits of separating one CRUD @Test into multiple is to be able to run one test at a time. In order to make each test runnable independently we will leverage BeforeAll , AfterAll , and TestMethodOrder . package com.example.tests.junit5; import org.testingisdocumenting.webtau.http.request.HttpRequestBody; import org.testingisdocumenting.webtau.junit5.WebTau; import org.junit.jupiter.api.*; import static org.testingisdocumenting.webtau.WebTauDsl.*; @WebTau // annotation to enable rich console output and html reporting @TestMethodOrder(MethodOrderer.OrderAnnotation.class) // forcing methods execution order @DisplayName(\"customer CRUD\") public class CustomerCrudSeparatedJavaTest { private static final HttpRequestBody customerPayload = http.json( \"firstName\", \"FN\", \"lastName\", \"LN\"); private static final HttpRequestBody changedCustomerPayload = http.json( \"firstName\", \"FN\", \"lastName\", \"NLN\"); private static int id; @BeforeAll @DisplayName(\"create customer\") // optional friendly name for reporting purposes public static void createCustomer() { id = http.post(\"/customers\", customerPayload, ((header, body) -> { return body.get(\"id\"); })); actual(id).shouldNot(equal(0)); } @Test @Order(1) @DisplayName(\"read customer\") public void read() { http.get(\"/customers/\" + id, ((header, body) -> { body.should(equal(customerPayload)); })); } @Test @Order(2) // order dependence saves from creating customer on every test @DisplayName(\"update customer\") public void update() { http.put(\"/customers/\" + id, changedCustomerPayload, ((header, body) -> { body.should(equal(changedCustomerPayload)); })); http.get(\"/customers/\" + id, ((header, body) -> { body.should(equal(changedCustomerPayload)); })); } @Test @Order(3) // but you can still run each method independently @DisplayName(\"delete customer\") public void delete() { http.delete(\"/customers/\" + id, ((header, body) -> { header.statusCode.should(equal(204)); })); http.get(\"/customers/\" + id, ((header, body) -> { header.statusCode.should(equal(404)); })); id = -1; // marking as deleted to let cleanup step know that no delete is required } @AfterAll public static void cleanup() { // optional (since we create new ids all the time) step to keep your environment clean if (id == -1) { return; } http.delete(\"/customers/\" + id); } }"],["HTTP@@CRUD-example@@separate-methods-report","HTTP","CRUD Example","Separate Methods Report","Now report has separate entries for each CRUD operation. Makes it possible to filter tests by create , update , read , delete to streamline investigation."],["HTTP@@data-node@@special-values","HTTP","Data Node","Special Values","Values that you access inside the http call validation block are special values of DataNode type. DataNode has methods to assert and traverse the response.All assertions made on DataNode are tracked and are available as part of the generated report. Groovy http.get(\"/end-point\") { price.should == 100 assert price instanceof DataNode } Check HTTP/import-and-dependencies Import And Dependencies for prerequisites. Java http.get(\"/end-point\", ((header, body) -> { DataNode price = body.get(\"price\"); price.should(equal(100)); })); Check HTTP/import-and-dependencies Import And Dependencies for prerequisites."],["HTTP@@data-node@@extracting-values","HTTP","Data Node","Extracting Values","As you have seen in HTTP/CRUD-example CRUD example you can return values back from a validation block. Groovy def id = http.get(\"/end-point\") { return id } id.should == 10 id.getClass().should == Integer List<Map<String, ?>> complexList = http.get(\"/end-point\") { return complexList } complexList[0].k2.should == 30 Java Integer id = http.get(\"/end-point\", ((header, body) -> { return body.get(\"id\"); })); actual(id).should(equal(10)); List<Map<String, ?>> complexList = http.get(\"/end-point\", ((header, body) -> { return body.get(\"complexList\"); })); Number k2 = (Number) complexList.get(0).get(\"k2\"); actual(k2).should(equal(30)); WebTau automatically converts leaf value to its correspondent primitive. It converts List and object to java.util.List and java.util.Map .Note: WebTau will not be able to associate assertions on returned values with a specific call. Avoid using returned values for validation. Make assertions on DataNode instance to generate useful report information such as data coverage."],["HTTP@@data-node@@properties-on-lists","HTTP","Data Node","Properties On Lists","If you have a list of objects like complexList below, you can access all its children property value with complexList.k2 . Groovy http.get(\"/end-point\") { complexList.k2.should == [30, 40] } Java http.get(\"/end-point\", ((header, body) -> { body.get(\"complexList\").get(\"k2\").should(equal(list(30, 40))); }));"],["HTTP@@data-node@@path-based-properties-access","HTTP","Data Node","Path based properties access","Primarily for Java users, WebTau supports the ability to query properties of a DataNode via a path instead of chaining get(String name) calls. For example, to obtain a simple property: http.get(\"/end-point\", (header, body) -> { body.get(\"object.k1\").should(equal(\"v1\")); }); It is also possible to query arrays, including the ability to query for the Nth element from the end: http.get(\"/end-point\", (header, body) -> { body.get(\"complexList[0].k1\").should(equal(\"v1\")); body.get(\"complexList[-1].k1\").should(equal(\"v11\")); }); Similarly to the Groovy example in HTTP/data-node#properties-on-lists Properties On Lists, it is possible to access all children property values: http.get(\"/end-point\", (header, body) -> { body.get(\"complexList.k1\").should(equal(list(\"v1\", \"v11\"))); });"],["HTTP@@data-node@@if-else-logic","HTTP","Data Node","If-Else Logic","Even though values that you access inside validation block are special values of DataNode type, you can still perform simple if-else like logic checks on them.In case of Groovy, accessing a value during if-else will mark the value as accessed for reporting.In case of Java, use .get() to access underlying value. No marking of the value will during comparison. Groovy def zipCode = http.get(\"/address\") { return addressType == \"complex\" ? address.zipCode : \"NA\" } Warning: Comparison of complex values is not properly implemented due to current Groovy API implementation details Java String zipCode = http.get(\"/address\", ((header, body) -> { return body.get(\"addressType\").get().equals(\"complex\") ? body.get(\"address.zipCode\") : \"NA\"; }));"],["HTTP@@data-node@@iteration","HTTP","Data Node","Iteration","DataNode have convenient methods to iterate over values and make assertions. Groovy http.get(\"/end-point\") { list.each { it.shouldBe > 0 } } http.get(\"/end-point\") { complexList.each { k2.shouldBe > 0 } } Java http.get(\"/end-point\", (header, body) -> { body.get(\"list\").forEach(node -> node.shouldBe(greaterThan(0))); }); http.get(\"/end-point\", (header, body) -> { body.get(\"complexList\").forEach(node -> node.get(\"k2\").shouldBe(greaterThan(0))); });"],["HTTP@@data-node@@find","HTTP","Data Node","Find","Use find to find a DataNode based on a provided predicate Groovy http.get(\"/end-point\") { def found = complexList.find { it.id.get() == \"id1\" } found.k1.should == \"v1\" found.k2.should == 30 } http.doc.capture(\"find-on-list-and-assert\") // doc-exclude def found = http.get(\"/end-point\") { return complexList.find { it.id == \"id1\" } } Java http.get(\"/end-point\", ((header, body) -> { DataNode found = body.get(\"complexList\").find(node -> node.get(\"id\").get().equals(\"id1\")); found.get(\"k1\").should(equal(\"v1\")); found.get(\"k2\").should(equal(30)); })); Map<String, ?> found = http.get(\"/end-point\", ((header, body) -> { return body.get(\"complexList\").find(node -> node.get(\"id\").get().equals(\"id1\")); })); Note: WebTau will not track assertion on returned values and it will not show in reports and will not participate in data coverage. Use returned values for further test logic."],["HTTP@@data-node@@find-all","HTTP","Data Node","Find All","Use findAll to find a list of DataNode s based on a provided predicate Groovy http.get(\"/end-point\") { def found = complexList.findAll { it.k2 > 20 } found.k1.should containAll(\"v1\", \"v11\") } Java http.get(\"/end-point\", ((header, body) -> { DataNode found = body.get(\"complexList\").findAll(node -> { int k2 = node.get(\"k2\").get(); return k2 > 20; }); found.get(\"k1\").should(containAll(\"v1\", \"v11\")); })); Note: The result of findAll is of type DataNode and you can leverage #properties-on-lists Properties On Lists"],["HTTP@@data-node@@collect","HTTP","Data Node","Collect","Use collect to transform a collection of items def transformed = http.get(\"/end-point\") { return list.collect { \"world#${it}\" } } assert transformed == [\"world#1\", \"world#2\", \"world#3\"] assert transformed[0] instanceof GString"],["HTTP@@data-node@@combine","HTTP","Data Node","Combine","Methods find and collect can be chained def sum = http.get(\"/end-point\") { return complexList .findAll { k1.get().startsWith(\"v1\") } .collect { k2.get() } .sum() } assert sum == 70"],["HTTP@@HTTP-resource@@response-lazy-value","HTTP","HTTP Resource","Response Lazy Value","WebTau has a way to define a lazy value associated with HTTP GET response. After that it can be used in multiple tests, should and waitTo on it. Value can be associated with static urls like /info or dynamic urls like /price/:ticker Groovy private final def livePrice = http.resource(\"/prices/:ticker\").price ... livePrice.of(\"IBM\").waitToBe > 115 Check HTTP/import-and-dependencies Import And Dependencies for prerequisites. Java private final HttpLazyResponseValue livePrice = http.resource(\"/prices/:ticker\").get(\"price\"); ... livePrice.of(\"IBM\").waitToBe(greaterThan(115))); Check HTTP/import-and-dependencies Import And Dependencies for prerequisites. > waiting for value of /prices/IBM: price to be greater than 115 > [1/3] executing HTTP GET http://localhost:39175/prices/IBM . header.statusCode equals 200 (0ms) response (application/json): { \"price\": **100** } . [1/3] executed HTTP GET http://localhost:39175/prices/IBM (6ms) > [3/3] executing HTTP GET http://localhost:39175/prices/IBM . header.statusCode equals 200 (0ms) response (application/json): { \"price\": ~~120~~ } . [3/3] executed HTTP GET http://localhost:39175/prices/IBM (2ms) . value of /prices/IBM: price greater than 115 (220ms)"],["HTTP@@HTTP-resource@@full-body","HTTP","HTTP Resource","Full Body","Use .body to define a resource matching the whole response: Groovy private final def livePriceBody = http.resource(\"/prices/:ticker\").body ... livePriceBody.of(\"IBM\").waitTo == [price: greaterThan(115)] Java private final HttpLazyResponseValue livePriceBody = http.resource(\"/prices/:ticker\").body; ... livePriceBody.of(\"IBM\").waitTo(equal(map(\"price\", greaterThan(115))))); > waiting for value of /prices/IBM: to equal {\"price\": <greater than 115>} > [1/3] executing HTTP GET http://localhost:39175/prices/IBM . header.statusCode equals 200 (0ms) response (application/json): { \"price\": **100** } . [1/3] executed HTTP GET http://localhost:39175/prices/IBM (5ms) > [3/3] executing HTTP GET http://localhost:39175/prices/IBM . header.statusCode equals 200 (0ms) response (application/json): { \"price\": __120__ } . [3/3] executed HTTP GET http://localhost:39175/prices/IBM (3ms) . value of /prices/IBM: equals {\"price\": <greater than 115>} (213ms)"],["HTTP@@HTTP-resource@@complex-value-path","HTTP","HTTP Resource","Complex Value Path","Value path supports multiple nesting level and arrays indexing: Groovy private final def complexListFirstId = http.resource(\"/end-point\").complexList[0].id ... complexListFirstId.should == \"id1\" Java private final HttpLazyResponseValue complexListFirstId = http.resource(\"/end-point\").get(\"complexList[0].id\"); ... complexListFirstId.should(equal(\"id1\"))); > expecting value of /end-point: complexList[0].id to equal \"id1\" > executing HTTP GET http://localhost:39175/end-point . header.statusCode equals 200 (0ms) response (application/json): { \"id\": 10, \"price\": 100, \"amount\": 30, \"list\": [1, 2, 3], \"object\": {\"k1\": \"v1\", \"k2\": \"v2\", \"k3\": \"v3\"}, \"complexList\": [{\"id\": __\"id1\"__, \"k1\": \"v1\", \"k2\": 30}, {\"id\": \"id2\", \"k1\": \"v11\", \"k2\": 40}] } . executed HTTP GET http://localhost:39175/end-point (4ms) . value of /end-point: complexList[0].id equals \"id1\" (4ms)"],["HTTP@@HTTP-resource@@multiple-url-parameters","HTTP","HTTP Resource","Multiple URL Parameters","Use vararg, or pass a map to of to provide multiple URL parameters to your resource: Groovy private final def myObj = http.resource(\"/end-point/:param1/:param2\").object ... myObj.of([param1: 10, param2: 20]).should == [k1: \"v1_\", k2: \"v2_\", k3: \"v3_\"] Java private final HttpLazyResponseValue myObj = http.resource(\"/end-point/:param1/:param2\").get(\"object\"); ... myObj.of(\"param1\", \"10\", \"param2\", \"20\").should(equal(map(\"k1\", \"v1_\", \"k2\", \"v2_\", \"k3\", \"v3_\")))); > expecting value of /end-point/10/20: object to equal {\"k1\": \"v1_\", \"k2\": \"v2_\", \"k3\": \"v3_\"} > executing HTTP GET http://localhost:39175/end-point/10/20 . header.statusCode equals 200 (0ms) response (application/json): { \"id\": 10, \"price\": 120, \"amount\": 30, \"list\": [1, 2, 3], \"object\": {\"k1\": __\"v1_\"__, \"k2\": __\"v2_\"__, \"k3\": __\"v3_\"__}, \"complexList\": [{\"id\": \"id1\", \"k1\": \"v1\", \"k2\": 30}, {\"id\": \"id2\", \"k1\": \"v11\", \"k2\": 40}] } . executed HTTP GET http://localhost:39175/end-point/10/20 (4ms) . value of /end-point/10/20: object equals {\"k1\": \"v1_\", \"k2\": \"v2_\", \"k3\": \"v3_\"} (4ms)"],["HTTP@@HTTP-resource@@full-text-response","HTTP","HTTP Resource","Full Text Response","Use to extract full original response: Groovy String responseAsText = http.resource(\"/prices/IBM\").fullTextResponse() responseAsText.should == \"{\\\"price\\\": 100}\" Java String responseAsText = http.resource(\"/prices/IBM\").fullTextResponse(); actual(responseAsText, \"response\").should(equal(\"{\\\"price\\\": 100}\"));"],["HTTP@@HTTP-resource@@http-header","HTTP","HTTP Resource","HTTP Header","Use http.resource optional second parameter to pass HTTP header: Groovy def responseValue = http.resource(\"/end-point\", http.header(\"x-prop\", \"x-value\")).path Java HttpLazyResponseValue responseValue = http.resource(\"/end-point\", http.header(\"path\", \"x-value\")).get(\"path\");"],["HTTP@@header@@standard-header","HTTP","Header","Standard Header","Standard headers like Content-Type and Accept are set on your behalf. When payload content is present then values are based on the content type you are sending. When no payload is present, it defaults to application/json ."],["HTTP@@header@@explicit-header","HTTP","Header","Explicit Header","To explicitly set header pass http.header(values) as an additional parameter. Groovy http.get(\"/end-point\", http.header(\"Accept\", \"application/octet-stream\")) { // assertions go here } http.get(\"/end-point\", [queryParam1: \"queryParamValue1\"], http.header(\"Accept\", \"application/octet-stream\")) { // assertions go here } http.patch(\"/end-point\", http.header(\"Accept\", \"application/octet-stream\"), [fileId: \"myFile\"]) { // assertions go here } http.post(\"/end-point\", http.header(\"Accept\", \"application/octet-stream\"), [fileId: \"myFile\"]) { // assertions go here } http.put(\"/end-point\", http.header(\"Accept\", \"application/octet-stream\"), [fileId: \"myFile\", file: sampleFile]) { // assertions go here } http.delete(\"/end-point\", http.header(\"Custom-Header\", \"special-value\")) Java http.get(\"/end-point\", http.header(\"Accept\", \"application/octet-stream\"), (header, body) -> { // assertions go here }); http.get(\"/end-point\", http.query(\"queryParam1\", \"queryParamValue1\"), http.header(\"Accept\", \"application/octet-stream\"), (header, body) -> { // assertions go here }); http.patch(\"/end-point\", http.header(\"Accept\", \"application/octet-stream\"), http.json(\"fileId\", \"myFile\"), (header, body) -> { // assertions go here }); http.post(\"/end-point\", http.header(\"Accept\", \"application/octet-stream\"), http.json(\"fileId\", \"myFile\"), (header, body) -> { // assertions go here }); http.put(\"/end-point\", http.header(\"Accept\", \"application/octet-stream\"), http.json(\"fileId\", \"myFile\", \"file\", sampleFile), (header, body) -> { // assertions go here }); http.delete(\"/end-point\", http.header(\"Custom-Header\", \"special-value\")); Additionally http.header accepts values as a map. Groovy def varArgHeader = http.header( \"My-Header1\", \"Value1\", \"My-Header2\", \"Value2\") def mapBasedHeader = http.header([ \"My-Header1\": \"Value1\", \"My-Header2\": \"Value2\"]) Java HttpHeader varArgHeader = http.header( \"My-Header1\", \"Value1\", \"My-Header2\", \"Value2\"); Map<CharSequence, CharSequence> headerValues = new HashMap<>(); headerValues.put(\"My-Header1\", \"Value1\"); headerValues.put(\"My-Header2\", \"Value2\"); HttpHeader mapBasedHeader = http.header(headerValues); Use .with to create a new instance of a header based on the existing one plus additional values Groovy def newHeaderVarArg = header.with( \"Additional-1\", \"AdditionalValue1\", \"Additional-2\", \"AdditionalValue2\") def newHeaderMap = header.with([ \"Additional-1\": \"AdditionalValue1\", \"Additional-2\": \"AdditionalValue2\"]) Java HttpHeader newHeaderVarArg = header.with( \"Additional-1\", \"AdditionalValue1\", \"Additional-2\", \"AdditionalValue2\"); Map<CharSequence, CharSequence> additionalValues = new HashMap<>(); additionalValues.put(\"Additional-1\", \"AdditionalValue1\"); additionalValues.put(\"Additional-2\", \"AdditionalValue2\"); HttpHeader newHeaderMap = header.with(additionalValues);"],["HTTP@@header@@implicit-header","HTTP","Header","Implicit Header","Webtau has a way to provide headers for each call implicitly. Use it to provide things like authentication, version, etc. header values.Implicit headers goal is to reduce expose to implementation details and make tests more robust. Groovy package scenarios.rest.headers import scenarios.rest.headers.auth.Auth url = \"http://localhost:8080\" httpHeaderProvider = Auth.&authHeader Where Auth.&authHeader is implemented as follows: package scenarios.rest.headers.auth import org.testingisdocumenting.webtau.http.HttpHeader class Auth { static HttpHeader authHeader(String fullUrl, String url, HttpHeader original) { def token = generateToken() return original.with([Authorization: \"Bearer $token\"]) } private static String generateToken() { return \"jwt-token\" } } Java In case of JUnit like runners, WebTau uses https://docs.oracle.com/javase/8/docs/api/java/util/ServiceLoader.html Service Loaders to locate header providers com.example.tests.junit5.config.HttpAuthHeaderProvider package com.example.tests.junit5.config; import org.testingisdocumenting.webtau.http.HttpHeader; import org.testingisdocumenting.webtau.http.config.WebTauHttpConfiguration; import static org.testingisdocumenting.webtau.WebTauDsl.*; public class HttpAuthHeaderProvider implements WebTauHttpConfiguration { @Override public HttpHeader fullHeader(String fullUrl, String passedUrl, HttpHeader given) { String token = generateToken(); return given.with(\"Authorization\", \"Bearer \" + token); } private String generateToken() { return \"jwt-token\"; } } Note: Read persona/HTTP-persona Persona Auth to learn about ways to streamline authentication"],["HTTP@@header@@content-type-shortcut","HTTP","Header","Content Type Shortcut","Use http.body to combine Content-Type and payload. Groovy def content = binaryFileContent(\"path\") http.post(\"/end-point\", http.body(\"application/octet-stream\", content)) { // assertions go here } Java byte[] content = binaryFileContent(\"path\"); http.post(\"/end-point\", http.body(\"application/octet-stream\", content), (header, body) -> { // assertions go here }); More examples are in HTTP/body#content-type-shortcuts HTTP Body Content-Type Shortcuts"],["HTTP@@header@@response-header","HTTP","Header","Response Header","To validate values from response header use header object. Groovy http.post(\"/end-point\") { header.location.should == \"http://www.example.org/url/23\" header[\"Location\"].should == \"http://www.example.org/url/23\" header.contentLocation.should == \"/url/23\" header[\"Content-Location\"].should == \"/url/23\" header.contentLength.shouldBe > 300 header[\"Content-Length\"].shouldBe > 300 } Java http.post(\"/end-point\", (header, body) -> { header.location.should(equal(\"http://www.example.org/url/23\")); header.get(\"Location\").should(equal(\"http://www.example.org/url/23\")); header.contentLocation.should(equal(\"/url/23\")); header.get(\"Content-Location\").should(equal(\"/url/23\")); header.contentLength.shouldBe(greaterThan(300)); header.get(\"Content-Length\").shouldBe(greaterThan(300)); }); At the moment only location , contentLocation , contentLength have camelCase shortcuts. All the other header values you need to use ['Header-Name'] syntax."],["HTTP@@body@@json-request","HTTP","Body","JSON Request","Methods http.post , http.put , http.delete automatically converts java.util.Map or java.util.List into application/json request Groovy http.post(\"/chat\", [message: \"hello\", priority: \"HIGH\"]) { status.should == \"SUCCESS\" } Java http.post(\"/chat\", http.json(\"message\", \"hello\", \"priority\", \"high\"), (header, body) -> { body.get(\"status\").should(equal(\"SUCCESS\")); }); Note: For Java example uses a http.json shortcut but Map/List also works."],["HTTP@@body@@json-request-from-file","HTTP","Body","JSON Request From File","data/json#read-list Data JSON module has convenient methods to read JSON from resource/file as list/map/object Groovy http.post(\"/chat\", data.json.map(\"chat-message.json\")) { status.should == \"SUCCESS\" } Java http.post(\"/chat\", data.json.map(\"chat-message.json\"), (header, body) -> { body.get(\"status\").should(equal(\"SUCCESS\")); });"],["HTTP@@body@@generic-request","HTTP","Body","Generic Request","Use http.body to create generic body request. Groovy def content = binaryFileContent(\"path\") http.post(\"/end-point\", http.body(\"application/octet-stream\", content)) { // assertions go here } Java byte[] content = binaryFileContent(\"path\"); http.post(\"/end-point\", http.body(\"application/octet-stream\", content), (header, body) -> { // assertions go here });"],["HTTP@@body@@content-type-shortcuts","HTTP","Body","Content-Type Shortcuts","WebTau provides shortcuts for Standard MIME types Groovy http.post(\"/end-point\", http.application.json( \"key1\", \"value1\", \"key2\", \"value2\")) { // assertions go here } http.post(\"/end-point\", http.application.json('{\"key1\": \"value1\", \"key2\": \"value2\"}')) { // assertions go here } def content = binaryFileContent(\"path\") http.post(\"/end-point\", http.application.octetStream(content)) { // assertions go here } def content = \"text content\" http.post(\"/end-point\", http.text.plain(content)) { // assertions go here } Java http.post(\"/end-point\", http.application.json( \"key1\", \"value1\", \"key2\", \"value2\"), (header, body) -> { // assertions go here }); http.post(\"/end-point\", http.application.json(\"{\\\"key1\\\": \\\"value1\\\", \\\"key2\\\": \\\"value2\\\"}\"), (header, body) -> { // assertions go here }); byte[] content = binaryFileContent(\"path\"); http.post(\"/end-point\", http.application.octetStream(content), (header, body) -> { // assertions go here }); String content = \"text content\"; http.post(\"/end-point\", http.text.plain(content), (header, body) -> { // assertions go here }); Note: is a long form of and is there for completeness purpose. There is no behavior difference between passing an instance of java.util.Map and http.json"],["HTTP@@body@@form-url-encoded-data","HTTP","Body","Form URL Encoded Data","Use http.formDataUrlEncoded to send application/x-www-form-urlencoded Groovy http.post(\"/submit\", http.formDataUrlEncoded([firstName: \"F Name\", lastName: \"L Name\"])) { // ... } Java http.post(\"/submit\", http.formDataUrlEncoded(\"firstName\", \"F Name\", \"lastName\", \"L Name\"), (header, body) -> { // ... });"],["HTTP@@body@@form-file-data","HTTP","Body","Form File Data","Consider example where backend expects a file as multipart/form-data . Field file defines content. Backend responds with file name and file description it received.Use http.formData to build a request body to send multipart/form-data , Groovy def imagePath = testResourcePath(\"src/test/resources/image.png\") http.post(\"/file-upload\", http.formData(file: imagePath)) { fileName.should == \"image.png\" } Java Path imagePath = testResourcePath(\"src/test/resources/image.png\"); http.post(\"/file-upload\", http.formData(map(\"file\", imagePath)), (header, body) -> { body.get(\"fileName\").should(equal(\"image.png\")); }); Use http.formFile to override file name. Groovy def imagePath = testResourcePath(\"src/test/resources/image.png\") http.post(\"/file-upload\", http.formData(file: http.formFile(\"myFileName.png\", imagePath))) { fileName.should == \"myFileName.png\" } Java Path imagePath = testResourcePath(\"src/test/resources/image.png\"); http.post(\"/file-upload\", http.formData(map( \"file\", http.formFile(\"myFileName.png\", imagePath))), (header, body) -> { body.get(\"fileName\").should(equal(\"myFileName.png\")); }); Multiple form fields can be specified: Groovy def imagePath = testResourcePath(\"src/test/resources/image.png\") http.post(\"/file-upload\", http.formData(file: imagePath, fileDescription: \"new report\")) { fileName.should == \"image.png\" description.should == \"new report\" } Java Path imagePath = testResourcePath(\"src/test/resources/image.png\"); http.post(\"/file-upload\", http.formData(map( \"file\", imagePath, \"fileDescription\", \"new report\")), (header, body) -> { body.get(\"fileName\").should(equal(\"image.png\")); body.get(\"description\").should(equal(\"new report\")); }); To pass a file content directly, use Groovy byte[] fileContent = [1, 2, 3, 4] as byte[] http.post(\"/file-upload\", http.formData(file: fileContent)) { fileName.should == \"backend-generated-name-as-no-name-provided\" } Java byte[] fileContent = new byte[] {1, 2, 3, 4}; http.post(\"/file-upload\", http.formData(map(\"file\", fileContent)), (header, body) -> { body.get(\"fileName\").should(equal(\"backend-generated-name-as-no-name-provided\")); }); Note: no file name is passed and this particular backend generated file name on your behalf.Use http.formFile to provide a file name Groovy byte[] fileContent = [1, 2, 3, 4] as byte[] http.post(\"/file-upload\", http.formData( file: http.formFile(\"myFileName.dat\", fileContent))) { fileName.should == \"myFileName.dat\" } Java byte[] fileContent = new byte[] {1, 2, 3, 4}; http.post(\"/file-upload\", http.formData(map( \"file\", http.formFile(\"myFileName.dat\", fileContent))), (header, body) -> { body.get(\"fileName\").should(equal(\"myFileName.dat\")); });"],["HTTP@@body@@parsed-response","HTTP","Body","Parsed Response","Special HTTP/data-node Data Node body represents parsed response. Use it to validate response values. Groovy http.get(\"/query\") { body.price.should == 100 } Note: For Groovy body is optional and when not specified, will be used implicitly http.get(\"/query\") { price.should == 100 } Java http.get(\"/query\", ((header, body) -> { body.get(\"price\").should(equal(100)); }));"],["HTTP@@body@@pdf-response","HTTP","Body","PDF Response","Use data.pdf.parse(body) to parse and assert PDF content from binary response. Groovy http.get(\"/report\") { data.pdf.read(body).pageText(0).should contain(\"Quarterly earnings:\") } Java http.get(\"/report\", ((header, body) -> { data.pdf.read(body).pageText(0).should(contain(\"Quarterly earnings:\")); })); Assign parse result to a local variable to make multiple assertions Groovy http.get(\"/report\") { def pdf = data.pdf.read(body) pdf.pageText(0).should contain(\"Quarterly earnings:\") pdf.pageText(1).should == \"Intentional blank page\\n\" } Java http.get(\"/report\", ((header, body) -> { Pdf pdf = data.pdf.read(body); pdf.pageText(0).should(contain(\"Quarterly earnings:\")); pdf.pageText(1).should(equal(\"Intentional blank page\\n\")); })); Note: Use pdf assertions for sanity checks, i.e. presence of a correct client name or an account number. Implement comprehensive PDF generation logic tests as unit tests."],["HTTP@@body@@raw-response","HTTP","Body","Raw Response","Use to access original text content Groovy def rawContent = http.post(\"/chat\", [message: \"hello world\"]) { return body.getTextContent() } Java String rawContent = http.post(\"/chat\", http.json(\"message\", \"hello world\"), (header, body) -> { return body.getTextContent(); });"],["HTTP@@query-parameters@@passing-query-parameters","HTTP","Query Parameters","Passing Query Parameters","WebTau offers a number of ways of specifying query parameters: Groovy http.get(\"/path?a=1&b=text\") { // assertions go here } Java http.get(\"/path?a=1&b=text\", ((header, body) -> { // assertions go here })); Use Map as a second parameter to pass query parameters. Suitable for languages that support in-line creation of Map . Groovy http.get(\"/path\", [a: 1, b: \"text\"]) { // assertions go here } Java http.get(\"/path\", map(\"a\", 1, \"b\", \"text\"), ((header, body) -> { // assertions go here })); Only http.get has a Map variant, for http.put , http.post , etc you need to pass http.query . Groovy http.post(\"/chat\", http.query([a: 1, b: \"text\"]), http.header([\"x-param\": \"value\"]), [message: \"hello\"]) { // assertions go here } Java http.post(\"/chat\", http.query(\"a\", 1, \"b\", \"text\"), http.header(\"x-param\", \"value\"), http.json(\"message\", \"hello\"), (header, body) -> { // assertions go here });"],["HTTP@@query-parameters@@parameters-encoding","HTTP","Query Parameters","Parameters Encoding","All query parameters are encoded automatically. Groovy http.get(\"/path\", http.query([message: \"hello world !\"])) { // assertions go here } Java http.get(\"/path\", http.query(\"message\", \"hello world !\"), (header, body) -> { // assertions go here }); /path?message=hello+world+%21"],["HTTP@@HTTP-calls@@overloaded-calls","HTTP","HTTP Calls","Overloaded Calls","http.get|post|put|delete methods have overloads to let you supply additional data in addition to URL:Query parameters Request header Payload (where applicable) Validation block Overloads maintain relative order, but you can omit any additional data.Here is http.get quick example: Groovy http.get(\"/query\", http.header([h1: \"v1\"])) { price.should == 100 } Check HTTP/import-and-dependencies Import And Dependencies for prerequisites. Java http.get(\"/query\", http.header(\"h1\", \"v1\"), ((header, body) -> { body.get(\"price\").should(equal(100)); })); Check HTTP/import-and-dependencies Import And Dependencies for prerequisites."],["HTTP@@HTTP-calls@@implicit-statuscode-check","HTTP","HTTP Calls","Implicit statusCode Check","By default, WebTau automatically assert statusCode based on method. Method Implicitly Expected Code [{text=GET, type=SimpleText}] [{text=200, type=SimpleText}] [{text=POST, type=SimpleText}] [{text=201, type=SimpleText}] [{text=PUT, type=SimpleText}] [{text=200, type=SimpleText}] [{text=PUT (no response), type=SimpleText}] [{text=204, type=SimpleText}] [{text=DELETE, type=SimpleText}] [{text=200, type=SimpleText}] [{text=DELETE (no response), type=SimpleText}] [{text=204, type=SimpleText}] To turn it off, provide an explicit statusCode assertion. Groovy http.post(\"/resource\") { statusCode.should == 200 // explicit check that override default 201 (for POST) implicit check } Java http.post(\"/resource\", (header, body) -> { header.statusCode.should(equal(200)); // explicit check that override default 201 (for POST) implicit check });"],["HTTP@@HTTP-calls@@get","HTTP","HTTP Calls","GET","java http.get(url, [queryParams], [header], [validationBlock]) url String getting-started/configuration#config-file relative or absolute URL to send GET request to queryParams HttpQueryParams | Map HTTP/query-parameters query parameters to attach to URL header HttpHeader HTTP/header request header to send validationBlock HttpResponseValidator validation block of code to HTTP/matchers assert and access response body and header Groovy def id = http.get(\"/query\", [q1: \"v1\"], http.header([h1: \"v1\"])) { price.should == 100 // validation return id // optional return } http.get(\"/query\", [q1: \"v1\"]) { price.should == 100 } http.get(\"/query\", http.header([h1: \"v1\"])) { price.should == 100 } http.get(\"/query\") { price.should == 100 } http.get(\"/query\") Java String id = http.get(\"/query\", http.query(\"q1\", \"v1\"), http.header(\"h1\", \"v1\"), ((header, body) -> { body.get(\"price\").should(equal(100)); // validation return body.get(\"id\"); // optional return })); http.get(\"/query\", http.query(\"q1\", \"v1\"), ((header, body) -> { body.get(\"price\").should(equal(100)); })); http.get(\"/query\", http.header(\"h1\", \"v1\"), ((header, body) -> { body.get(\"price\").should(equal(100)); })); http.get(\"/query\", ((header, body) -> { body.get(\"price\").should(equal(100)); })); http.get(\"/query\");"],["HTTP@@HTTP-calls@@post","HTTP","HTTP Calls","POST","java http.post(url, [queryParams], [header], [body], [validationBlock]) url String getting-started/configuration#config-file relative or absolute URL to send GET request to queryParams HttpQueryParams | Map HTTP/query-parameters query parameters to attach to URL header HttpHeader HTTP/header request header to send body HttpRequestBody | Map | List HTTP/body request body to send with a request validationBlock HttpResponseValidator validation block of code to HTTP/matchers assert and access response body and header Groovy def id = http.post(\"/chat\", http.query([q1: \"v1\"]), http.header([h1: \"v1\"]), [message: \"hello\"]) { status.should == \"SUCCESS\" // validation return id // optional return } http.post(\"/chat\", http.query([q1: \"v1\"]), [message: \"hello\"]) { status.should == \"SUCCESS\" } http.post(\"/chat\", http.header([h1: \"v1\"]), [message: \"hello\"]) { status.should == \"SUCCESS\" } http.post(\"/chat\", [message: \"hello\", priority: \"HIGH\"]) { status.should == \"SUCCESS\" } http.post(\"/chat\") { status.should == \"SUCCESS\" } http.post(\"/chat\") Java String id = http.post(\"/chat\", http.query(\"q1\", \"v1\"), http.header(\"h1\", \"v1\"), http.json(\"message\", \"hello\"), (header, body) -> { body.get(\"status\").should(equal(\"SUCCESS\")); // validation return body.get(\"id\"); // optional return }); http.post(\"/chat\", http.query(\"q1\", \"v1\"), http.json(\"message\", \"hello\"), (header, body) -> { body.get(\"status\").should(equal(\"SUCCESS\")); }); http.post(\"/chat\", http.header(\"h1\", \"v1\"), http.json(\"message\", \"hello\"), (header, body) -> { body.get(\"status\").should(equal(\"SUCCESS\")); }); http.post(\"/chat\", http.json(\"message\", \"hello\", \"priority\", \"high\"), (header, body) -> { body.get(\"status\").should(equal(\"SUCCESS\")); }); http.post(\"/chat\", (header, body) -> { body.get(\"status\").should(equal(\"SUCCESS\")); }); http.post(\"/chat\");"],["HTTP@@HTTP-calls@@put","HTTP","HTTP Calls","PUT","java http.put(url, [queryParams], [header], [body], [validationBlock]) url String getting-started/configuration#config-file relative or absolute URL to send GET request to queryParams HttpQueryParams | Map HTTP/query-parameters query parameters to attach to URL header HttpHeader HTTP/header request header to send body HttpRequestBody | Map | List HTTP/body request body to send with a request validationBlock HttpResponseValidator validation block of code to HTTP/matchers assert and access response body and header Groovy def id = http.put(\"/chat/id1\", http.query([q1: \"v1\"]), http.header([h1: \"v1\"]), [message: \"hello\"]) { status.should == \"SUCCESS\" // validation return id // optional return } http.put(\"/chat/id1\", http.query([q1: \"v1\"]), [message: \"hello\"]) { status.should == \"SUCCESS\" } http.put(\"/chat/id1\", http.header([h1: \"v1\"]), [message: \"hello\"]) { status.should == \"SUCCESS\" } http.put(\"/chat/id1\", [message: \"hello\"]) { status.should == \"SUCCESS\" } http.put(\"/chat/id1\") { status.should == \"SUCCESS\" } http.put(\"/chat/id1\") Java String id = http.put(\"/chat/id1\", http.query(\"q1\", \"v1\"), http.header(\"h1\", \"v1\"), http.json(\"message\", \"hello\"), (header, body) -> { body.get(\"status\").should(equal(\"SUCCESS\")); // validation return body.get(\"id\"); // optional return }); http.put(\"/chat/id1\", http.query(\"q1\", \"v1\"), http.json(\"message\", \"hello\"), (header, body) -> { body.get(\"status\").should(equal(\"SUCCESS\")); }); http.put(\"/chat/id1\", http.header(\"h1\", \"v1\"), http.json(\"message\", \"hello\"), (header, body) -> { body.get(\"status\").should(equal(\"SUCCESS\")); }); http.put(\"/chat/id1\", http.json(\"message\", \"hello\"), (header, body) -> { body.get(\"status\").should(equal(\"SUCCESS\")); }); http.put(\"/chat/id1\", (header, body) -> { body.get(\"status\").should(equal(\"SUCCESS\")); }); http.put(\"/chat/id1\");"],["HTTP@@HTTP-calls@@delete","HTTP","HTTP Calls","DELETE","java http.delete(url, [queryParams], [header], [validationBlock]) url String getting-started/configuration#config-file relative or absolute URL to send GET request to queryParams HttpQueryParams | Map HTTP/query-parameters query parameters to attach to URL header HttpHeader HTTP/header request header to send validationBlock HttpResponseValidator validation block of code to HTTP/matchers assert and access response body and header Groovy def id = http.delete(\"/chat/id1\", [q1: \"v1\"], http.header([h1: \"v1\"])) { status.should == \"SUCCESS\" // validation return id // optional return } http.delete(\"/chat/id1\", [q1: \"v1\"]) { status.should == \"SUCCESS\" } http.delete(\"/chat/id1\", http.header([h1: \"v1\"])) { status.should == \"SUCCESS\" } http.delete(\"/chat/id1\") { status.should == \"SUCCESS\" } http.delete(\"/chat/id1\") Java String id = http.delete(\"/chat/id1\", http.query(\"q1\", \"v1\"), http.header(\"h1\", \"v1\"), ((header, body) -> { body.get(\"status\").should(equal(\"SUCCESS\")); // validation return body.get(\"id\"); // optional return })); http.delete(\"/chat/id1\", http.query(\"q1\", \"v1\"), ((header, body) -> { body.get(\"status\").should(equal(\"SUCCESS\")); })); http.delete(\"/chat/id1\", http.header(\"h1\", \"v1\"), ((header, body) -> { body.get(\"status\").should(equal(\"SUCCESS\")); })); http.delete(\"/chat/id1\", ((header, body) -> { body.get(\"status\").should(equal(\"SUCCESS\")); })); http.delete(\"/chat/id1\");"],["HTTP@@HTTP-calls@@patch","HTTP","HTTP Calls","PATCH","java http.patch(url, [queryParams], [header], [body], [validationBlock]) url String getting-started/configuration#config-file relative or absolute URL to send GET request to queryParams HttpQueryParams | Map HTTP/query-parameters query parameters to attach to URL header HttpHeader HTTP/header request header to send body HttpRequestBody | Map | List HTTP/body request body to send with a request validationBlock HttpResponseValidator validation block of code to HTTP/matchers assert and access response body and header Groovy def id = http.patch(\"/chat/id1\", http.query([q1: \"v1\"]), http.header([h1: \"v1\"]), [message: \"hello\"]) { status.should == \"SUCCESS\" // validation return id // optional return } http.patch(\"/chat/id1\", http.query([q1: \"v1\"]), [message: \"hello\"]) { status.should == \"SUCCESS\" } http.patch(\"/chat/id1\", http.header([h1: \"v1\"]), [message: \"hello\"]) { status.should == \"SUCCESS\" } http.patch(\"/chat/id1\", [message: \"hello\"]) { status.should == \"SUCCESS\" } http.patch(\"/chat/id1\") { status.should == \"SUCCESS\" } http.patch(\"/chat/id1\") Java String id = http.patch(\"/chat/id1\", http.query(\"q1\", \"v1\"), http.header(\"h1\", \"v1\"), http.json(\"message\", \"hello\"), (header, body) -> { body.get(\"status\").should(equal(\"SUCCESS\")); // validation return body.get(\"id\"); // optional return }); http.patch(\"/chat/id1\", http.query(\"q1\", \"v1\"), http.json(\"message\", \"hello\"), (header, body) -> { body.get(\"status\").should(equal(\"SUCCESS\")); }); http.patch(\"/chat/id1\", http.header(\"h1\", \"v1\"), http.json(\"message\", \"hello\"), (header, body) -> { body.get(\"status\").should(equal(\"SUCCESS\")); }); http.patch(\"/chat/id1\", http.json(\"message\", \"hello\"), (header, body) -> { body.get(\"status\").should(equal(\"SUCCESS\")); }); http.patch(\"/chat/id1\", (header, body) -> { body.get(\"status\").should(equal(\"SUCCESS\")); }); http.patch(\"/chat/id1\");"],["HTTP@@HTTP-calls@@ping","HTTP","HTTP Calls","PING","Use ping to check if an end point responds 200 to GET method Groovy if (!http.ping(\"/end-point\")) { http.post(\"/cluster-master\", [restart: \"server-one\"]) } Java if (!http.ping(\"/end-point\")) { http.post(\"/cluster-master\", http.json(\"restart\", \"server-one\")); } java boolean http.ping(url, [queryParams], [header]) url String getting-started/configuration#config-file relative or absolute URL to send GET request to queryParams HttpQueryParams | Map HTTP/query-parameters query parameters to attach to URL header HttpHeader HTTP/header request header to send Groovy http.ping(\"/end-point\", [queryParam1: \"queryParamValue1\"], http.header([\"X-flag\": \"test\"])) http.ping(\"/end-point\", [queryParam1: \"queryParamValue1\"]) http.ping(\"/end-point\", http.header([\"X-flag\": \"test\"])) http.ping(\"/end-point\") Java http.ping(\"/end-point\", http.query(\"queryParam1\", \"queryParamValue1\"), http.header(\"X-flag\", \"test\")); http.ping(\"/end-point\", http.query(\"queryParam1\", \"queryParamValue1\")); http.ping(\"/end-point\", http.header(\"X-flag\", \"test\")); http.ping(\"/end-point\");"],["HTTP@@documentation-artifacts@@happy-paths","HTTP","Documentation Artifacts","Happy Paths","Use happy paths test scenarios to document your API. Capture requests performed and response received. Use it as part of your documentation. Benefits:No manual copy-pasting of requests/responses Documentation is up-to-date Happy paths API is working as intended"],["HTTP@@documentation-artifacts@@capturing-test-artifacts","HTTP","Documentation Artifacts","Capturing Test Artifacts","Use http.doc.capture to capture REST API artifacts Groovy package scenarios.rest import static org.testingisdocumenting.webtau.WebTauGroovyDsl.* scenario(\"extracting id after POST to use inside GET request\") { def id = http.post(\"/employee\", [firstName: 'FN', lastName: 'LN']) { id.shouldNot == \"\" return id } http.doc.capture('employee-post') // capture previous HTTP call into <docDir>/employee-post http.get(\"/employee/$id\") { firstName.should == 'FN' lastName.should == 'LN' } http.doc.capture('employee-get') // capture previous HTTP call into <docDir>/employee-get } Java package com.example.tests.junit5; import org.junit.jupiter.api.Test; import org.testingisdocumenting.webtau.junit5.WebTau; import static org.testingisdocumenting.webtau.WebTauDsl.*; @WebTau public class CustomerDocCaptureTest { @Test public void extractIdAfterPostToUseInsideGetRequest() { var customerPayload = http.json( \"firstName\", \"FN\", \"lastName\", \"LN\"); int id = http.post(\"/customers\", customerPayload, ((header, body) -> { body.get(\"id\").shouldNot(equal(\"\")); return body.get(\"id\"); })); http.doc.capture(\"employee-post\"); // capture previous HTTP call into <docDir>/employee-post http.get(\"/customers/\" + id, ((header, body) -> { body.get(\"firstName\").should(equal(\"FN\")); body.get(\"lastName\").should(equal(\"LN\")); })); http.doc.capture(\"employee-get\"); // capture previous HTTP call into <docDir>/employee-get } } An employee-get directory will be created containing a number of test artifacts."],["HTTP@@documentation-artifacts@@documentation-pipeline","HTTP","Documentation Artifacts","Documentation Pipeline","Documentation pipeline can look likeExample of using captured artifacts using https://github.com/testingisdocumenting/znai Znai markdown # Create Employee :include-open-api: openapi/api-spec.json {operationId: \"createEmployee\" } ```columns left: :include-json: doc-artifacts/employee-post/request.json { title: \"request payload\" } right: :include-json: doc-artifacts/employee-post/response.json { title: \"response payload\", pathsFile: \"doc-artifacts/employee-post/paths.json\" } ```"],["HTTP@@documentation-artifacts@@create-employee","HTTP","Documentation Artifacts","Create Employee","Request Responses 200 201"],["HTTP@@documentation-artifacts@@test-artifacts-location","HTTP","Documentation Artifacts","Test Artifacts Location","By default, the directory will be created in the current working directory. To change it add docPath to your webtau.cfg.groovy file. url = \"http://localhost:8180\" docPath = \"doc-artifacts\""],["HTTP@@documentation-artifacts@@test-artifacts","HTTP","Documentation Artifacts","Test Artifacts","A number of artifacts will be created depending on the exact call being captured. Request and response payloads Request bodies are captured in either request.json , request.pdf or request.data depending on the type.Similarly, response bodies are captured in either response.json , response.pdf or response.data . Request and response headers Just like payloads, request and response headers are captured in request.header.txt and response.header.txt respectively. These files contain a header per line with the name and values colon separated. The values are redacted for any potentially sensitive headers. Response body assertions Any assertions you perform on the response body in your scenarios are captured in a paths.json file. This contains an array with the list of paths within the body whose values were asserted. Request URLs The actual request URL is captured in two forms into two different files: request.fullurl.txt - contains the full URL request.url.txt - contains only the part specified in the http call in the scenario /path?a=1&b=text http://localhost:32781/path?a=1&b=text"],["HTTP@@openAPI-spec@@validation","HTTP","OpenAPI Spec","Validation","WebTau supports validation of responses against an https://www.openapis.org/ OpenAPI specification. This feature can be enabled by specifying the openApiSpecUrl configuration option. This should be the URL to the specification against which to validate. url = \"http://localhost:8080\" openApiSpecUrl = \"scenarios/rest/springboot/api-spec.json\""],["HTTP@@openAPI-spec@@current-limitations","HTTP","OpenAPI Spec","Current limitations","OpenAPI specification support is still in its early stage. It is fully functional but there are a few limitations to be aware of:WebTau currently only supports OpenAPI specification v2 specification matching is currently done based on the path and method any HTTP requests which do not match any operation in the specification will not fail tests but will produce a warning on the console"],["HTTP@@openAPI-spec@@validations-report","HTTP","OpenAPI Spec","Validations report","The validation errors are reported in the same manner as assertion errors. They are available in the output from the command line WebTau runner: bash > executing HTTP POST http://localhost:8080/customers { \"id\": 1, \"firstName\": \"FN\", \"lastName\": \"LN\", \"_links\": { \"self\": { \"href\": \"http://localhost:8080/customers/1\" }, \"customer\": { \"href\": \"http://localhost:8080/customers/1\" } } } X failed executing HTTP POST http://localhost:8080/customers : API spec validation failure: ERROR - Response status 201 not defined for path ''.: [] [x] failed java.lang.AssertionError: API spec validation failure: ERROR - Response status 201 not defined for path ''.: [] at scenarios.rest.springboot.customerCrud$_run_closure1.doCall(customerCrud.groovy:8) at scenarios.rest.springboot.customerCrud$_run_closure1.doCall(customerCrud.groovy) Total: 1, Passed: 0, Skipped: 0, Failed: 1, Errored: 0 They are also available in the HTML report:"],["HTTP@@openAPI-spec@@validation-configuration","HTTP","OpenAPI Spec","Validation Configuration","To ignore additional properties in responses set openApiIgnoreAdditionalProperties to true . As any other config value it can be done via command line, config file or system properties."],["HTTP@@openAPI-spec@@disable-validation","HTTP","OpenAPI Spec","Disable Validation","import org.testingisdocumenting.webtau.openapi.OpenApi OpenApi.withoutValidation { http.post(\"/employee\", [firstName: 'First']) { // ... } } OpenApi.responseOnlyValidation() { http.post(\"/employee\", [firstName: 'First']) { // ... } } OpenApi.requestOnlyValidation() { http.post(\"/employee\", [firstName: 'First', lastName: 'Second']) { // ... } }"],["HTTP@@JSON-schema@@validation","HTTP","JSON Schema","Validation","WebTau supports validation of objects against https://json-schema.org/ JSON Schema. It is possible to validate either the entire body or just a specific field with the complyWithSchema matcher as shown in the two examples below: http.get(\"/weather\") { body.should complyWithSchema('valid-schema.json') } http.get(\"/city/London\") { weather.should complyWithSchema('valid-schema.json') } Both examples above validate against the following schema:"],["HTTP@@JSON-schema@@error-messages","HTTP","JSON Schema","Error messages","Using the first example above, an invalid schema will generate an error similar to: invalid schema (examples/scenarios/rest/jsonSchema/validateSchema.groovy) > executing HTTP GET http://localhost:8080/weather X failed expecting body to comply with schema invalid-schema.json : body expected to comply with schema invalid-schema.json [#: required key [anotherField] not found, #/temperature: expected type: Boolean, found: Integer] { \"temperature\": 88 } The schema used in validation to generate this error is as follows:"],["HTTP@@JSON-schema@@configuration","HTTP","JSON Schema","Configuration","The path to the schema file specified in complyWithSchema can be relative or absolute. If it's relative, it'll be relative to the jsonSchemasDir specified in configuration and if not specified then relative to working directory. For example: url = \"http://localhost:8180\" jsonSchemasDir = 'schemas'"],["HTTP@@data-coverage@@code-coverage-vs-data-coverage","HTTP","Data Coverage","Code Coverage VS Data Coverage","Code Coverage helps to reveal what paths of business logic you forgot to exercise. But it doesn't help as much with HTTP API testing: a single call to an API may exercise the entire code path.One of the main artifacts of HTTP API testing is a response. Does response have correct data? Are there data paths that we never asserted on?WebTau looks across all the executed tests and called HTTP API methods to track what calls have response fields that were never observed. At the end report provides Data Coverage you can act on:Remove fields from the response Add an extra assertion"],["HTTP@@data-coverage@@detect-fields-that-were-skipped","HTTP","Data Coverage","Detect Fields That Were Skipped","Let's consider an end-point that returns a weather temperature in Fahrenheit and Celsius. And Later we decided to add time field to the response.Our tests were asserting on both temperature fields, but we have no assertions on time field. Groovy package scenarios.rest.coverage import static org.testingisdocumenting.webtau.WebTauGroovyDsl.* scenario(\"check fahrenheit temperature\") { http.get(\"/city/NewYork\") { weather.temperatureF.shouldBe > 80 } } scenario(\"check celsius temperature\") { http.get(\"/city/NewYork\") { weather.temperatureC.shouldBe > 26 } } Java package com.example.tests.junit5; import org.junit.jupiter.api.Test; import org.testingisdocumenting.webtau.junit5.WebTau; import static org.testingisdocumenting.webtau.WebTauDsl.*; @WebTau public class NewYorkWeatherJavaTest { @Test public void checkFahrenheitTemperature() { http.get(\"/city/NewYork\", (header, body) -> { body.get(\"weather.temperatureF\").shouldBe(greaterThan(80)); }); } @Test public void checkCelsiusTemperature() { http.get(\"/city/NewYork\", (header, body) -> { body.get(\"weather.temperatureC\").shouldBe(greaterThan(26)); }); } } When we run our test suite, we will see in the output that both temperatures were asserted ( ~~ in the response). But since we didn't touch time field, at the end of test run, WebTau will print a warning about missing validation scenario checkFahrenheitTemperature (NewYorkWeatherJavaTest) > executing HTTP GET http://localhost:42733/city/NewYork > reading HTTP routes definition from class path resource data/http-routes.txt . read HTTP routes definition from class path resource data/http-routes.txt (2ms) > mapping operation id . mapped operation id as \"GET /city/:cityId\" (1ms) . body.weather.temperatureF greater than 80 (0ms) . header.statusCode equals 200 (0ms) response (application/json): { \"time\": \"2018-11-27 13:05:00\", \"weather\": {\"temperatureF\": ~~88~~, \"temperatureC\": 31} } . executed HTTP GET http://localhost:42733/city/NewYork (10ms) [.] checkFahrenheitTemperature (NewYorkWeatherJavaTest) scenario checkCelsiusTemperature (NewYorkWeatherJavaTest) > executing HTTP GET http://localhost:42733/city/NewYork > mapping operation id . mapped operation id as \"GET /city/:cityId\" (0ms) . body.weather.temperatureC greater than 26 (0ms) . header.statusCode equals 200 (0ms) response (application/json): { \"time\": \"2018-11-27 13:05:00\", \"weather\": {\"temperatureF\": 88, \"temperatureC\": ~~31~~} } . executed HTTP GET http://localhost:42733/city/NewYork (5ms) [.] checkCelsiusTemperature (NewYorkWeatherJavaTest) scenario after all tests (Teardown) [.] after all tests (Teardown) Data Coverage HTTP routes that have non validated response fields GET /city/:cityId root.time WebTau prints only the first three routes with the skipped fields, and only first three fields. More details is available in the produced HTML report.HTTP Data Coverage leads to more details on Routes that have fields that were skipped Expanding a Route will list all the ignored fields"],["HTTP@@data-coverage@@routing","HTTP","Data Coverage","Routing","WebTau needs to know how to group URLs you call. In the example above /city/NewYork and /city/London belongs to the same group. And if you validate Celsius field when calling NewYork and Fahrenheit when calling London, fields will be considered as covered.This is because WebTau identifies both URLs as /city/:id scenario checkFahrenheitTemperature (NewYorkWeatherJavaTest) > executing HTTP GET http://localhost:42733/city/NewYork > reading HTTP routes definition from class path resource data/http-routes.txt . read HTTP routes definition from class path resource data/http-routes.txt (2ms) > mapping operation id . mapped operation id as \"GET /city/:cityId\" (1ms) . body.weather.temperatureF greater than 80 (0ms) There are two ways to provide routing information:Provide HTTP/openAPI-spec Open API spec Provide http routes text files"],["HTTP@@data-coverage@@text-routes","HTTP","Data Coverage","Text Routes","If you don't have HTTP/openAPI-spec Open API spec, you can define a plain text files that enumerates your API routes like this GET /city/:cityId Note: variant with curly brackets for parameters also works /city/{id} Specify file path (or resource for java) in your config file to enable it Groovy httpRoutesPath = \"data/http-routes.txt\" Java httpRoutesPath = data/http-routes.txt"],["HTTP@@data-coverage@@json-output","HTTP","Data Coverage","JSON Output","Use config option to output Data Coverage in a separate JSON file for further processing. Groovy httpDataCoverageOutput = \"generated/data-coverage.json\" Java httpDataCoverageOutput = generated/data-coverage.json Data Coverage HTTP routes that have non validated response fields GET /city/:cityId root.time . generated HTTP Data Coverage: /home/runner/work/webtau/webtau/webtau-junit5-examples/generated/data-coverage.json (1ms) [ { \"touchedPathsCount\" : 2, \"untouchedPathsCount\" : 1, \"untouchedPaths\" : [ \"root.time\" ], \"id\" : \"GET /city/:cityId\", \"untouchedPercent\" : 33 } ]"],["HTTP@@matchers@@response-mapping","HTTP","Matchers","Response Mapping","Check HTTP/import-and-dependencies Import And Dependencies for prerequisites. Identifiers inside validation closure are automatically mapped to a response body. Groovy http.get(\"/end-point-simple-object\") { k1.should == \"v1\" } Java http.get(\"/end-point-simple-object\", (header, body) -> { body.get(\"k1\").should(equal(\"v1\")); }); List responses are handled by using index chain Groovy http.get(\"/end-point-simple-list\") { body[0].k1.should == \"v1\" } Note: Groovy API implicitly assumes body , but if you need to deal with array response you need to access values using body explicitly. Java http.get(\"/end-point-simple-list\", (header, body) -> { body.get(0).get(\"k1\").should(equal(\"v1\")); });"],["HTTP@@matchers@@should-and-should-not","HTTP","Matchers","Should and Should Not","Matchers in WebTau are triggered with should and shouldNot keywords. Additionally shouldBe and shouldNotBe alias keywords are available to make certain matcher combinations easier to read. Groovy http.get(\"/example\") { year.shouldNot == 2000 year.should != 2000 // alternative shortcut genres.should contain(\"RPG\") rating.shouldBe > 7 } Java http.get(\"/example\", (header, body) -> { body.get(\"year\").shouldNot(equal(2000)); body.get(\"genres\").should(contain(\"RPG\")); body.get(\"rating\").shouldBe(greaterThan(7)); });"],["HTTP@@matchers@@equality","HTTP","Matchers","Equality","WebTau defines its own set of equality rules to simplify testing. Groovy http.get(\"/end-point\") { id.should != 0 amount.should == 30 list.should == [1, 2, 3] object.k1.should == ~/v\\d/ // regular expression matching object.should == [k1: \"v1\", k3: \"v3\"] // matching only specified fields and can be nested multiple times complexList.should == [\"k1\" | \"k2\"] { // matching only specified fields, but number of entries must be exact ________________ \"v1\" | 30 \"v11\" | 40 } } Java http.get(\"/end-point\", (header, body) -> { body.get(\"id\").shouldNot(equal(0)); body.get(\"amount\").should(equal(30)); body.get(\"list\").should(equal(list(1, 2, 3))); body.get(\"object\").get(\"k1\").should(equal( Pattern.compile(\"v\\\\d\"))); // regular expression matching body.get(\"object\").should(equal(map( \"k1\", \"v1\", \"k3\", \"v3\"))); // matching only specified fields and can be nested multiple times body.get(\"complexList\").should(equal(table(\"k1\" , \"k2\", // matching only specified fields, but number of entries must be exact ________________, \"v1\" , 30, \"v11\", 40))); }); Groovy http.get(\"/end-point\") { complexList.should == [ \"*id\" | \"k1\" | \"k2\"] { // order agnostic key based match ________________________ \"id2\" | \"v11\" | 40 \"id1\" | \"v1\" | 30 } } Java http.get(\"/end-point\", (header, body) -> { body.get(\"complexList\").should(equal(table(\"*id\", \"k1\" , \"k2\", // order agnostic key based match ________________, \"id2\", \"v11\", 40, \"id1\", \"v1\" , 30))); });"],["HTTP@@matchers@@greater-less-equal","HTTP","Matchers","Greater/Less/Equal","Use greaterThan , greaterThanOrEqual , lessThan , and lessThanOrEqual to assert numeric values. Groovy http.get(\"/end-point-numbers\") { id.shouldBe > 0 price.shouldBe >= 100 amount.shouldBe < 150 list[1].shouldBe <= 2 id.shouldNotBe <= 0 price.shouldNotBe < 100 amount.shouldNotBe >= 150 list[1].shouldNotBe > 2 } Note: Groovy can use shortcuts > , >= , < , <= . Java http.get(\"/end-point-numbers\", (header, body) -> { body.get(\"id\").shouldBe(greaterThan(0)); body.get(\"price\").shouldBe(greaterThanOrEqual(100)); body.get(\"amount\").shouldBe(lessThan(150)); body.get(\"list\").get(1).shouldBe(lessThanOrEqual(2)); body.get(\"id\").shouldNotBe(lessThanOrEqual(0)); body.get(\"price\").shouldNotBe(lessThan(100)); body.get(\"amount\").shouldNotBe(greaterThanOrEqual(150)); body.get(\"list\").get(1).shouldNotBe(greaterThan(2)); });"],["HTTP@@matchers@@contain","HTTP","Matchers","Contain","Use contain when you cannot rely on order of values in a response. Groovy http.get(\"/end-point-list\") { body.should contain([k1: \"v1\", k2: \"v2\"]) body[1].k2.shouldNot contain(22) } Java http.get(\"/end-point-list\", (header, body) -> { body.should(contain(map( \"k1\", \"v1\", \"k2\", \"v2\"))); body.get(1).get(\"k2\").shouldNot(contain(22)); });"],["HTTP@@matchers@@contain-table","HTTP","Matchers","Contain Table","Use contain and TableData to assert that a list contains multiple entries of interest Groovy http.get(\"/end-point-large-list\") { body.should contain([\"id\" | \"k1\" | \"k2\"] { ________________________ \"id1\" | \"v11\" | \"v12\" \"id3\" | \"v31\" | \"v32\" }) } Java http.get(\"/end-point-large-list\", (header, body) -> { body.should(contain(table(\"id\", \"k1\" , \"k2\", ______________________, \"id1\", \"v11\", \"v12\", \"id3\", \"v31\", \"v32\" ))); });"],["HTTP@@matchers@@contain-all","HTTP","Matchers","Contain All","Use containAll when you cannot rely on order of values in a response and need to check more than one value. Groovy http.get(\"/end-point-list\") { body[1].k2.should containAll(10, 30) body[1].k2.shouldNot containAll(40, 60, 80) } Java http.get(\"/end-point-list\", (header, body) -> { body.get(1).get(\"k2\").should(containAll(10, 30)); body.get(1).get(\"k2\").shouldNot(containAll(40, 60, 80)); });"],["HTTP@@matchers@@nested-contain-all","HTTP","Matchers","Nested Contain All","Use containingAll alias to make it easier to read containAll matcher nested inside contain . Groovy http.get(\"/prices\") { body.prices.should contain(containingAll(10, 30)) } Java http.get(\"/prices\", (header, body) -> { body.get(\"prices\").should(contain(containingAll(10, 30))); });"],["HTTP@@matchers@@contain-exactly","HTTP","Matchers","Contain Exactly","Use containExactly when you cannot rely on order of values in a response and want to make sure that there are no extra values. Groovy http.get(\"/end-point-list\") { body[1].k2.should containExactly(30, 10, 20) } Java http.get(\"/end-point-list\", (header, body) -> { body.get(1).get(\"k2\").should(containExactly(30, 10, 20)); });"],["HTTP@@matchers@@date-and-time","HTTP","Matchers","Date and Time","You can assert actual string against LocalDate and ZonedDateTime . String will be automatically converted using ISO formatter. Groovy http.get(\"/end-point-dates\") { def expectedDate = LocalDate.of(2018, 6, 12) def expectedTime = ZonedDateTime.of(expectedDate, LocalTime.of(9, 0, 0), ZoneId.of(\"UTC\")) tradeDate.should == expectedDate transactionTime.should == expectedTime transactionTime.shouldBe >= expectedDate paymentSchedule.should contain(expectedDate) } Java http.get(\"/end-point-dates\", (header, body) -> { LocalDate expectedDate = LocalDate.of(2018, 6, 12); ZonedDateTime expectedTime = ZonedDateTime.of(expectedDate, LocalTime.of(9, 0, 0), ZoneId.of(\"UTC\")); body.get(\"tradeDate\").should(equal(expectedDate)); body.get(\"transactionTime\").should(equal(expectedTime)); body.get(\"transactionTime\").shouldBe(greaterThanOrEqual(expectedDate)); body.get(\"paymentSchedule\").should(contain(expectedDate)); });"],["HTTP@@matchers@@mixing-matchers","HTTP","Matchers","Mixing Matchers","You can use matchers in place of expected values to build a more complex expectation. Groovy http.get(\"/end-point-mixed\") { list.should contain(lessThanOrEqual(2)) // lessThanOrEqual will be matched against each value object.should == [k1: \"v1\", k3: ~/v\\d/] // regular expression match against k3 complexList[0].should == [k1: \"v1\", k2: lessThan(120)] // lessThen match against k2 complexList[1].should == [ k1: notEqual(\"v1\"), // any value but v1 k2: greaterThanOrEqual(120)] complexList.should == [\"k1\" | \"k2\"] { ___________________________ ~/v\\d/ | lessThan(120) \"v11\" | greaterThan(150) } // using matchers as cell values } Java Pattern withNumber = Pattern.compile(\"v\\\\d\"); http.get(\"/end-point-mixed\", (header, body) -> { body.get(\"list\").should(contain(lessThanOrEqual(2))); // lessThanOrEqual will be matched against each value body.get(\"object\").should(equal(map( \"k1\", \"v1\", \"k3\", withNumber))); // regular expression match against k3 body.get(\"complexList\").get(0).should(equal(map( \"k1\", \"v1\", \"k2\", lessThan(120)))); // lessThen match against k2 body.get(\"complexList\").get(1).should(equal(map( \"k1\", notEqual(\"v1\"), // any value but v1 \"k2\", greaterThanOrEqual(120)))); TableData expected = table(\"k1\" , \"k2\", // matching only specified fields, but number of entries must be exact ________________________________, withNumber , lessThan(120), \"v11\" , greaterThan(150)); body.get(\"complexList\").should(equal(expected)); });"],["HTTP@@configuration@@base-url","HTTP","Configuration","Base URL","Here we cover essential configuration for HTTP testing.To learn basics about configuration, head over to getting-started/configuration Configuration Getting Started. To learn about all configuration capabilities, head over to configuration/groovy-config-file Configuration page. Groovy url = \"http://localhost:8080\" Note: WebTau treats groovy config file as codeAlternatively pass url as a command line argument --url=http://... Java url = http://localhost:8080 When you use JUnit like runners, e.g. getting-started/installation#junit5 JUnit5, WebTau expects file named webtau.properties to be present in test classpath, e.g. test resources:Alternatively pass url as a system property -Durl=http://... To set base url using environment variables use export WEBTAU_URL=http://another-server"],["HTTP@@configuration@@proxy","HTTP","Configuration","Proxy","Use httpProxy to set proxy for the HTTP calls performed through http.get , http.post , etc Groovy httpProxy = 'my-proxy-server-to-use.com:3873' Java java httpProxy = my_proxy_server_to_use.com:3873"],["HTTP@@import-and-dependencies@@http-specific-import","HTTP","Import And Dependencies","HTTP Specific Import","When you use multiple WebTau features you can single static import to have all core features available for autocomplete. It also requires a single dependency to bring all the WebTau modules. Groovy import static org.testingisdocumenting.webtau.WebTauGroovyDsl.* <dependency> <groupId>org.testingisdocumenting.webtau</groupId> <artifactId>webtau-groovy</artifactId> <version>2.3</version> </dependency> If you use groovy-standalone-runner/introduction Groovy Runner then all the dependencies are already present. Java import static org.testingisdocumenting.webtau.WebTauDsl.*; <dependency> <groupId>org.testingisdocumenting.webtau</groupId> <artifactId>webtau</artifactId> <version>2.3</version> </dependency> To only import http module use Groovy import static org.testingisdocumenting.webtau.http.Http.http <dependency> <groupId>org.testingisdocumenting.webtau</groupId> <artifactId>webtau-http</artifactId> <version>2.3</version> </dependency> Java import static org.testingisdocumenting.webtau.http.Http.http; <dependency> <groupId>org.testingisdocumenting.webtau</groupId> <artifactId>webtau-http</artifactId> <version>2.3</version> </dependency>"],["GraphQL@@introduction@@","GraphQL","Introduction","","WebTau graphql module lets you exercise and validate a GraphQL API. It provides a simplified way to access the JSON response of an end-point and provides a DSL to execute queries and mutations. Groovy package scenarios.rest import static org.testingisdocumenting.webtau.WebTauGroovyDsl.* scenario(\"check weather\") { def query = \"{ weather { temperature } }\"; graphql.execute(query) { weather.temperature.shouldBe < 100 } } package com.example.tests.junit4 import org.junit.Test import org.junit.runner.RunWith import org.testingisdocumenting.webtau.junit4.WebTauRunner import static org.testingisdocumenting.webtau.WebTauDsl.graphql @RunWith(WebTauRunner.class) class GraphQLWeatherGroovyIT { @Test void checkWeather() { def query = \"{ weather { temperature } }\"; graphql.execute(query) { weather.temperature.shouldBe < 100 } } } Java package com.example.tests.junit4; import org.junit.Test; import org.junit.runner.RunWith; import org.testingisdocumenting.webtau.junit4.WebTauRunner; import static org.testingisdocumenting.webtau.WebTauDsl.*; @RunWith(WebTauRunner.class) public class GraphQLWeatherJavaIT { @Test public void checkWeather() { String query = \"{ weather { temperature } }\"; graphql.execute(query, (header, body) -> { body.get(\"data.weather.temperature\").shouldBe(lessThan(100)); }); } }"],["GraphQL@@queries-and-mutations@@executing-queries-and-mutations","GraphQL","Queries And Mutations","Executing Queries and Mutations","Before diving further into writing tests for your GraphQL server, please read through the HTTP testing documentation starting with the HTTP/data-node Data node page as much of the same core principles apply to GraphQL also.The main GraphQL specific features are covered in the subsequent pages: GraphQL/queries-and-mutations Queries and Mutations GraphQL/customized-graphql-urls Customized GraphQL URLs GraphQL/report Report WebTau follows GraphQL's https://graphql.org/learn/serving-over-http/ Serving over HTTP best practices when invoking GraphQL servers over HTTP.It therefore assumes the server responds to requests to /graphql so you do not need to specify that in the URL in your configuration. Requests allow providing:a query/mutation string variables an operation name WebTau will default to issuing POST requests according to the https://graphql.org/learn/serving-over-http/#post-request best practices and will expect a 200 status code and a response with a data or errors field.The following example demonstrates most of these query features: package scenarios.graphql import static org.testingisdocumenting.webtau.WebTauGroovyDsl.* def listAllQuery = ''' { allTasks(uncompletedOnly: false) { id description } } ''' def taskByIdQuery = ''' query taskById($id: ID!) { taskById(id: $id) { id description completed } } ''' def completeMutation = ''' mutation complete($id: ID!) { complete(id: $id) } ''' scenario(\"list all tasks\") { graphql.execute(listAllQuery) { // Execute a simple query with no variables errors.should == null // Validate there were no errors body.data.allTasks.id.should == [\"a\", \"b\", \"c\"] // Access response data with the full path allTasks.id.should == [\"a\", \"b\", \"c\"] // Access response data via a shortcut allowing omitting of `body.data` id.should == [\"a\", \"b\", \"c\"] // For single query requests, access response data via a shortcut allowing omitting of `body.data` and the query name } } scenario(\"complete a task\") { graphql.execute(completeMutation, [id: \"a\"]) { // Execute a mutation with a variables map errors.should == null complete.should == true } graphql.execute(taskByIdQuery, [id: \"a\"]) { errors.should == null taskById.id.should == \"a\" taskById.completed.should == true } } scenario(\"cannot complete a completed task\") { graphql.execute(completeMutation, [id: \"b\"]) { // Execute a mutation with a variables map errors.should == null complete.should == true } graphql.execute(completeMutation, [id: \"b\"]) { // force an error errors[0].message.shouldNot == null complete.should == null } }"],["GraphQL@@queries-and-mutations@@response-assertions","GraphQL","Queries And Mutations","Response Assertions","Response assertions follow a similar pattern to REST APIs.For Groovy specifically, there are shortcuts for accessing data in the response directly as demonstrated in the example above. You may access errors directly via errors or fields in the response directly with the field names, omitting the data field."],["GraphQL@@customized-graphql-urls@@customizing-the-graphql-endpoint","GraphQL","Customized Graphql Urls","Customizing the GraphQL Endpoint","By default, WebTau assumes that all requests are made to a /graphql endpoint. The config value graphQLEndpoint can be set to use a non-standard endpoint, e.g. graphQLEndpoint=/api/graphql .WebTau also decorates the query with a (typically ignored) query parameter that contains the request's operationName , e.g. /graphql?operation=myOperation . This makes execution logs as well as WebTau's step reports easier to read and debug, especially since the operation's name is part of the request's payload and is usually not logged by request loggers. If you want to turn this feature off, set the config value for graphQLShowOperationAsQueryParam to false .In order to customize the graphQL URL in different ways, you need to implement a GraphQLHttpConfiguration and ensure it gets loaded at runtime via the Java ServiceLoader.Here is an example in groovy: package org.testingisdocumenting.webtau.graphql import org.testingisdocumenting.webtau.graphql.config.GraphQLHttpConfiguration import org.testingisdocumenting.webtau.graphql.model.GraphQLRequest class CustomGraphQLHttpConfiguration implements GraphQLHttpConfiguration { // Note: our test server requires the graphql endpoint to start with \"graphql\" public static final CUSTOM_GRAPHQL_ENDPOINT = 'graphql-custom' @Override String requestUrl(String url, GraphQLRequest graphQLRequest) { if (null != graphQLRequest.operationName && !graphQLRequest.operationName.isEmpty()) { return \"${CUSTOM_GRAPHQL_ENDPOINT}?operation=${graphQLRequest.operationName}\" } return url } }"],["GraphQL@@report@@additional-reports","GraphQL","Report","Additional Reports","To generate a report/custom-reports custom report or upload report data to your server, specify a reportGenerator config property. package scenarios.graphql url = \"http://localhost:8180\" graphQLIgnoreIntrospectionFailures = false reportGenerator = Report.&generateReport Where Report.&generateReport is implemented as follows: package scenarios.graphql import org.testingisdocumenting.webtau.console.ConsoleOutputs import org.testingisdocumenting.webtau.console.ansi.Color import org.testingisdocumenting.webtau.reporter.WebTauReport import org.testingisdocumenting.webtau.utils.JsonUtils import static org.testingisdocumenting.webtau.WebTauDsl.cfg class Report { static void generateReport(WebTauReport report) { def additionalData = [:] report.customDataStream.each { additionalData.putAll(it.toMap()) } def reportData = [:] reportData.graphQLSkippedQueries = additionalData.graphQLSkippedQueries // All queries present in the GraphQL schema but not tested reportData.graphQLCoveredQueries = additionalData.graphQLCoveredQueries // All queries present in the GraphQL schema and tested reportData.graphQLCoverageSummary = additionalData.graphQLCoverageSummary // Summary of test coverage compared to the GraphQL schema reportData.graphQLQueryTimeStatistics = additionalData.graphQLQueryTimeStatistics // Summary of timing by query reportData.graphQLCoveredSuccessBranches = additionalData.graphQLCoveredSuccessBranches // All queries present in the GraphQL schema that were hit with a success result reportData.graphQLSkippedSuccessBranches = additionalData.graphQLSkippedSuccessBranches // All queries present in the GraphQL schema but not hit with a success result reportData.graphQLCoveredErrorBranches = additionalData.graphQLCoveredErrorBranches // All queries present in the GraphQL schema that were hit with an error result reportData.graphQLSkippedErrorBranches = additionalData.graphQLSkippedErrorBranches // All queries present in the GraphQL schema but not hit with an error result def reportPath = cfg.workingDir.resolve('webtau.graphql-report.json') ConsoleOutputs.out('generating report: ', Color.PURPLE, reportPath) reportPath.toFile().text = JsonUtils.serializePrettyPrint(reportData) } } The output looks as follows: { \"graphQLSkippedQueries\" : [ { \"name\" : \"uncomplete\", \"type\" : \"mutation\" }, { \"name\" : \"complete\", \"type\" : \"mutation\" }, { \"name\" : \"taskById\", \"type\" : \"query\" }, { \"name\" : \"allTasks\", \"type\" : \"query\" } ], \"graphQLCoveredQueries\" : [ { \"name\" : \"weather\", \"type\" : \"query\" } ], \"graphQLCoverageSummary\" : { \"coverage\" : 0.2, \"branchCoverage\" : 0.1, \"types\" : { \"mutation\" : { \"coverage\" : 0.0, \"declaredQueries\" : 2, \"coveredQueries\" : 0.0 }, \"query\" : { \"coverage\" : 0.3333333333333333, \"declaredQueries\" : 3, \"coveredQueries\" : 1.0 } }, \"successBranchCoverage\" : 0.2, \"errorBranchCoverage\" : 0.0, \"totalDeclaredQueries\" : 5.0, \"totalCoveredQueries\" : 1.0 }, \"graphQLQueryTimeStatistics\" : [ { \"name\" : \"weather\", \"type\" : \"query\", \"statistics\" : { \"mean\" : 5.0, \"min\" : 5, \"max\" : 5, \"count\" : 1, \"p95\" : 5.0, \"p99\" : 5.0 } } ], \"graphQLCoveredSuccessBranches\" : [ { \"name\" : \"weather\", \"type\" : \"query\" } ], \"graphQLSkippedSuccessBranches\" : [ { \"name\" : \"uncomplete\", \"type\" : \"mutation\" }, { \"name\" : \"complete\", \"type\" : \"mutation\" }, { \"name\" : \"taskById\", \"type\" : \"query\" }, { \"name\" : \"allTasks\", \"type\" : \"query\" } ], \"graphQLCoveredErrorBranches\" : [ ], \"graphQLSkippedErrorBranches\" : [ { \"name\" : \"uncomplete\", \"type\" : \"mutation\" }, { \"name\" : \"complete\", \"type\" : \"mutation\" }, { \"name\" : \"taskById\", \"type\" : \"query\" }, { \"name\" : \"allTasks\", \"type\" : \"query\" }, { \"name\" : \"weather\", \"type\" : \"query\" } ] } Coverage and Timing Statistics WebTau will implicitly invoke your GraphQL server's introspection queries in order to fetch a subset of the schema. It uses this schema in conjunction with the requests in tests to compute:query coverage - which queries were invoked by tests and which were not as well as an overall summary of coverage timing information - http call timing statistics by query"],["web-socket@@introduction@@","Web Socket","Introduction","","WebTau websocket module lets your send, receive and validate websocket messages in a convenient synchronous manner. Groovy def wsSession = websocket.connect(\"/prices\") wsSession.send([symbol: \"IBM\"]) wsSession.received.waitTo == [ price: greaterThan(100), symbol: \"IBM\"] wsSession.close() Java var wsSession = websocket.connect(\"/prices\"); wsSession.send(map(\"symbol\", \"IBM\")); wsSession.received.waitTo(equal(map( \"price\", greaterThan(100), \"symbol\", \"IBM\"))); wsSession.close(); > connecting to websocket /prices . connected to websocket ws://localhost:34197/prices (10ms) > sending text message to ws://localhost:34197/prices {\"symbol\": \"IBM\"} . sent text message to ws://localhost:34197/prices (1ms) > waiting for received from ws://localhost:34197/prices to equal {\"price\": <greater than 100>, \"symbol\": \"IBM\"} > [1/25] polling websocket message {\"symbol\": \"IBM\", \"price\": 77} . [1/25] polled new message (1ms) > [25/25] polling websocket message {\"symbol\": \"IBM\", \"price\": 101} . [25/25] polled new message (0ms) . received from ws://localhost:34197/prices equals {\"price\": <greater than 100>, \"symbol\": \"IBM\"} (207ms) > closing websocket ws://localhost:34197/prices . closed websocket ws://localhost:34197/prices (0ms)"],["web-socket@@received-messages@@asynchronous-to-synchronous","Web Socket","Received Messages","Asynchronous To Synchronous","WebSocket messages are asynchronous in nature. To make writing tests easier, WebTau receives and stores all messages behind the scene. Messages are exposed via session.received special value. You can validate, wait on or poll from in a synchronous manner."],["web-socket@@received-messages@@wait-for-a-specific-message","Web Socket","Received Messages","Wait For A Specific Message","Use and waitTo to make sure a specific message was received. WebTau will comb through and discard all the received messages that do not match a criteria. Messages are processed in receive order. Groovy def wsSession = websocket.connect(\"/prices\") wsSession.received.waitTo == [ price: greaterThan(100), symbol: \"IBM\"] Check web-socket/import-and-dependencies Import And Dependencies for prerequisites. Java var wsSession = websocket.connect(\"/prices\"); wsSession.received.waitTo(equal(map( \"price\", greaterThan(100), \"symbol\", \"IBM\"))); Check web-socket/import-and-dependencies Import And Dependencies for prerequisites. > waiting for received from ws://localhost:44361/prices to equal {\"price\": <greater than 100>, \"symbol\": \"IBM\"} > [1/25] polling websocket message {\"symbol\": \"IBM\", \"price\": 77} . [1/25] polled new message (25ms) > [25/25] polling websocket message {\"symbol\": \"IBM\", \"price\": 101} . [25/25] polled new message (0ms) . received from ws://localhost:44361/prices equals {\"price\": <greater than 100>, \"symbol\": \"IBM\"} (1s 29ms)"],["web-socket@@received-messages@@wait-for-a-specific-message-using-value-path","Web Socket","Received Messages","Wait For A Specific Message Using Value Path","Use get(path) to narrow to a specific response value Groovy wsSession.received.price.waitToBe > 100 Note: Groovy dynamic nature allows you bypass explicit get Java wsSession.received.get(\"price\").waitToBe(greaterThan(100)); > waiting for received.price from ws://localhost:44361/prices to be greater than 100 > [1/25] polling websocket message {\"symbol\": \"IBM\", \"price\": 77} . [1/25] polled new message (0ms) > [25/25] polling websocket message {\"symbol\": \"IBM\", \"price\": 101} . [25/25] polled new message (0ms) . received.price from ws://localhost:44361/prices greater than 100 (1s 1ms) Use [idx] To deal with a list response: Groovy wsSession.received[2].price.waitToBe > 30 Java wsSession.received.get(\"[2].price\").waitToBe(greaterThan(30)); > waiting for received[2].price from ws://localhost:44361/prices to be greater than 30 > polling websocket message [{\"symbol\": \"IBM\", \"price\": 20}, {\"symbol\": \"IBM\", \"price\": 30}, {\"symbol\": \"IBM\", \"price\": 33}] . polled new message (0ms) . received[2].price from ws://localhost:44361/prices greater than 30 (0ms)"],["web-socket@@received-messages@@poll-message-as-text","Web Socket","Received Messages","Poll Message As Text","WebTau receives and stores asynchronous messages behind the scene. Use pollAsText to access messages in a synchronous manner. If message is not yet received, pollAsText will wait for a configured ( webSocketPollTimeout ) milliseconds (default 5 seconds). In example above, we wait until the price becomes greater than 100. All the messages including the matched one are discarded after waitTo . returns next received message or wait for the message to come: Groovy def nextMessage = wsSession.received.pollAsText() nextMessage.should == \"{\\\"symbol\\\":\\\"IBM\\\",\\\"price\\\":102}\" def nextNextMessage = wsSession.received.pollAsText(100) // explicit timeout in milliseconds for new message to arrive nextNextMessage.should == \"{\\\"symbol\\\":\\\"IBM\\\",\\\"price\\\":103}\" Java String nextMessage = wsSession.received.pollAsText(); actual(nextMessage).should(equal(\"{\\\"symbol\\\":\\\"IBM\\\",\\\"price\\\":102}\")); String nextNextMessage = wsSession.received.pollAsText(100); // explicit timeout in milliseconds for new message to arrive actual(nextNextMessage).should(equal(\"{\\\"symbol\\\":\\\"IBM\\\",\\\"price\\\":103}\")); Note: if there are no already received messages, and no new message arrives within a wait time, null will be returned."],["web-socket@@received-messages@@poll-message-as-object","Web Socket","Received Messages","Poll Message As Object","Use to convert JSON message to a list or a map. Groovy def message = wsSession.received.poll() message.symbol.should == \"IBM\" Java Map<String, ?> message = wsSession.received.poll(); actual(message.get(\"symbol\")).should(equal(\"IBM\"));"],["web-socket@@received-messages@@max-number-of-messages","Web Socket","Received Messages","Max Number Of Messages","By default, WebTau keeps only 1000 messages. If new messages arrive, the old ones get discarded. Use config value to change number of messages to keep."],["web-socket@@received-messages@@number-of-received-messages","Web Socket","Received Messages","Number Of Received Messages","Use to wait for a certain number of messages: Groovy wsSession.received.count.waitTo == 53 Java wsSession.received.count.waitTo(equal(53)); > waiting for count of messages received from ws://localhost:34197/prices to equal 53 . count of messages received from ws://localhost:34197/prices equals 53 (143ms)"],["web-socket@@received-messages@@discard-messages","Web Socket","Received Messages","Discard Messages","Use to remove all already received messages. Next will wait for a new message to arrive as all the received messages will be discarded. Groovy wsSession.received.discard() def nextMessage = wsSession.received.pollAsText(1) nextMessage.should == null Java wsSession.received.discard(); String nextMessage = wsSession.received.pollAsText(1); actual(nextMessage).should(equal(null)); . discarded all messages received from ws://localhost:34197/prices (0ms) > polling websocket message . no new message is polled (1ms)"],["web-socket@@header@@connection-header","Web Socket","Header","Connection Header","Use as a parameter to to pass connection header: Groovy def wsSession = websocket.connect(\"/prices\", websocket.header([\"x-extra\": \"1\"])) Check web-socket/import-and-dependencies Import And Dependencies for prerequisites. Java var wsSession = websocket.connect(\"/prices\", websocket.header(\"x-extra\", \"1\")); Check web-socket/import-and-dependencies Import And Dependencies for prerequisites."],["web-socket@@import-and-dependencies@@websocket-specific-import","Web Socket","Import And Dependencies","WebSocket Specific Import","When you use multiple WebTau features you can single static import to have all core features available for autocomplete. It also requires a single dependency to bring all the WebTau modules. Groovy import static org.testingisdocumenting.webtau.WebTauGroovyDsl.* <dependency> <groupId>org.testingisdocumenting.webtau</groupId> <artifactId>webtau-groovy</artifactId> <version>2.3</version> </dependency> If you use groovy-standalone-runner/introduction Groovy Runner then all the dependencies are already present. Java import static org.testingisdocumenting.webtau.WebTauDsl.*; <dependency> <groupId>org.testingisdocumenting.webtau</groupId> <artifactId>webtau</artifactId> <version>2.3</version> </dependency> To only import websocket module use Groovy import static org.testingisdocumenting.webtau.websocket.WebSocket.websocket <!-- ~ Copyright 2023 webtau maintainers ~ ~ Licensed under the Apache License, Version 2.0 (the \"License\"); ~ you may not use this file except in compliance with the License. ~ You may obtain a copy of the License at ~ ~ http://www.apache.org/licenses/LICENSE-2.0 ~ ~ Unless required by applicable law or agreed to in writing, software ~ distributed under the License is distributed on an \"AS IS\" BASIS, ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. ~ See the License for the specific language governing permissions and ~ limitations under the License. --> <dependency> <groupId>org.testingisdocumenting.webtau</groupId> <artifactId>webtau-websocket</artifactId> <version>2.3</version> </dependency> Java import static org.testingisdocumenting.webtau.websocket.WebSocket.websocket; <!-- ~ Copyright 2023 webtau maintainers ~ ~ Licensed under the Apache License, Version 2.0 (the \"License\"); ~ you may not use this file except in compliance with the License. ~ You may obtain a copy of the License at ~ ~ http://www.apache.org/licenses/LICENSE-2.0 ~ ~ Unless required by applicable law or agreed to in writing, software ~ distributed under the License is distributed on an \"AS IS\" BASIS, ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. ~ See the License for the specific language governing permissions and ~ limitations under the License. --> <dependency> <groupId>org.testingisdocumenting.webtau</groupId> <artifactId>webtau-websocket</artifactId> <version>2.3</version> </dependency>"],["browser@@introduction@@","Browser","Introduction","","WebTau browser module lets you interact with a browser.High level abstractions streamline location, assertion and async logic.WebTau leverages https://www.selenium.dev Selenium WebDriver to do the heavy lifting. Groovy package scenarios.ui import static org.testingisdocumenting.webtau.WebTauGroovyDsl.* import static pages.Pages.* scenario(\"search by specific query\") { search.submit(\"search this\") search.numberOfResults.waitToBe > 1 } package pages import static org.testingisdocumenting.webtau.WebTauDsl.* class SearchPage { def header = $(\"#header\") def welcomeMessage = $(\"#welcome\") def searchMessage = $(\"#message\") def box = $(\"#search-box\") def resultsArea = $(\"#results\") def results = $(\"#results .result\") def numberOfResults = results.count def submit(query) { browser.open(\"/search\") box.setValue(query) box.sendKeys(browser.keys.enter) } } package pages class Pages { static final def search = new SearchPage() } Java package com.example.tests.junit5; import org.junit.jupiter.api.Test; import org.testingisdocumenting.webtau.junit5.WebTau; import static com.example.tests.junit5.pages.Pages.*; import static org.testingisdocumenting.webtau.WebTauDsl.*; @WebTau public class WebSearchJavaTest { @Test public void searchByQuery() { search.submit(\"search this\"); search.numberOfResults.waitToBe(greaterThan(1)); } } package com.example.tests.junit5.pages; import org.testingisdocumenting.webtau.browser.page.PageElement; import org.testingisdocumenting.webtau.browser.page.PageElementValue; import static org.testingisdocumenting.webtau.WebTauDsl.*; public class SearchPage { private final PageElement box = $(\"#search-box\"); private final PageElement results = $(\"#results .result\"); public final PageElementValue<Integer> numberOfResults = results.count; public void submit(String query) { browser.open(\"/search\"); box.setValue(query); box.sendKeys(browser.keys.enter); } } package com.example.tests.junit5.pages; public class Pages { public static SearchPage search = new SearchPage(); } > initializing webdriver for chrome . initialized webdriver for chrome (501ms) > opening http://localhost:42733/search . opened http://localhost:42733/search (48ms) > setting value search this to by css #search-box > clearing by css #search-box . cleared by css #search-box (42ms) > sending keys search this to by css #search-box . sent keys search this to by css #search-box (58ms) . set value search this to by css #search-box (131ms) > sending keys <enter> to by css #search-box . sent keys <enter> to by css #search-box (30ms) > waiting for count of by css #results .result to be greater than 1 . count of by css #results .result greater than 1 (12ms)"],["browser@@basic-configuration@@base-url","Browser","Basic Configuration","Base URL","Groovy url = \"http://localhost:8080\" Note: WebTau treats groovy config file as codeAlternatively pass url as a command line argument --url=http://... Java url = http://localhost:8080 When you use JUnit like runners, e.g. getting-started/installation#junit5 JUnit5, WebTau expects file named webtau.properties to be present in test classpath, e.g. test resources:Alternatively pass url as a system property -Durl=http://... To set base url using environment variables use export WEBTAU_URL=http://another-server"],["browser@@basic-configuration@@browser-only-base-url","Browser","Basic Configuration","Browser Only Base URL","When you use url parameter you set base url for both REST and UI testing.Use browserUrl to specify UI only base url. This can be handy when your backend and frontend live separately."],["browser@@basic-configuration@@browser-id","Browser","Basic Configuration","Browser Id","Use browserId via command line, system property, env variable or config file parameter to specify which browser to use. Groovy webtau --browserId=firefox export WEBTAU_BROWSER_ID=firefox Java ... -DbrowserId=firefox export WEBTAU_BROWSER_ID=firefox Note: Default browserId is chrome"],["browser@@basic-configuration@@access-to-base-url","Browser","Basic Configuration","Access To Base Url","To access base url or port use: browser.getBaseUrl() browser.getBaseUrlPort()"],["browser@@page-element-and-value@@page-element-declaration","Browser","Page Element And Value","Page Element Declaration","Use $(\"css-selector\") or browser.element(\"css-selector\") to lazily declare a page element: groovy $(\"#element-id\") groovy $(\".label\") groovy $(\"[data-test-id='my-id']\") browser/finders-and-filters Read Finders And Filters to learn how to select elements using more advanced techniques. https://www.w3schools.com/cssref/css_selectors.asp Read W3Schools CSS selectors to learn all kind of CSS selection techniques."],["browser@@page-element-and-value@@lazy-element","Browser","Page Element And Value","Lazy Element","When you use $(\"css-selector\") you create an instance of PageElement . PageElement encapsulates actions that can be performed on a web page. It also represents values on a page. It is safe to declare PageElement before element is actually present on a page.WebTau will try to locate element only when you query or action on it: package scenarios.ui import static org.testingisdocumenting.webtau.WebTauGroovyDsl.* def welcomeMessage = $(\"#welcome\") scenario(\"simple open\") { browser.open(\"/search\") welcomeMessage.should == \"welcome to super search\" }"],["browser@@page-element-and-value@@lazy-value","Browser","Page Element And Value","Lazy Value","Consider a simple search page. Enter value, hit enter, see results: package scenarios.ui import static org.testingisdocumenting.webtau.WebTauGroovyDsl.* scenario('search by specific query') { browser.open('/search') $('#search-box').setValue('search this') $('#search-box').sendKeys(\"\\n\") $('#results .result').count.shouldBe > 1 } In the example $(\"#results .result\").count represents the number of elements matching the css selector. Let's extract it. package scenarios.ui import static org.testingisdocumenting.webtau.WebTauGroovyDsl.* def searchBox = $(\"#search-box\") def numberOfResults = searchBox.count scenario(\"search by specific query\") { browser.open(\"/search\") searchBox.setValue(\"search this\") searchBox.sendKeys(\"\\n\") numberOfResults.shouldBe > 1 }"],["browser@@page-object@@test-encapsulation","Browser","Page Object","Test Encapsulation","Robust tests should not depend on implementation details. UI has plenty of those:UI Elements placement Actions UI test should not depend on any of them. Move elements placement and available actions outside of UI test. Multiple tests can then reuse that information. And more importantly you will have only one place to change if UI changes."],["browser@@page-object@@definition","Browser","Page Object","Definition","To define PageObject create a class. package pages import static org.testingisdocumenting.webtau.WebTauDsl.* class SearchPage { def header = $(\"#header\") def welcomeMessage = $(\"#welcome\") def searchMessage = $(\"#message\") def box = $(\"#search-box\") def resultsArea = $(\"#results\") def results = $(\"#results .result\") def numberOfResults = results.count def submit(query) { browser.open(\"/search\") box.setValue(query) box.sendKeys(browser.keys.enter) } }"],["browser@@page-object@@grouping","Browser","Page Object","Grouping","To make it easier to refer PageObjects from different tests combine them in one file package pages class Pages { static final def search = new SearchPage() static final def calculation = new CalculationPage() static final def form = new FormPage() static final def payments = new PaymentsPage() } Use static import to have seamless access to all of them package scenarios.ui import static org.testingisdocumenting.webtau.WebTauGroovyDsl.* import static pages.Pages.* scenario(\"search by specific query\") { search.submit(\"search this\") search.numberOfResults.should == 2 }"],["browser@@element-actions-reference@@clicks","Browser","Element Actions Reference","Clicks","payments.confirmation.click() expandArea.doubleClick() paymentsTable.rightClick() payments.confirmation.shiftClick() payments.confirmation.altClick() payments.confirmation.controlClick() payments.confirmation.commandOrControlClick() payments.confirmation.commandOrControlClick()"],["browser@@element-actions-reference@@modifications","Browser","Element Actions Reference","Modifications","payments.dollarAmount.clear() payments.dollarAmount.sendKeys(\"104.5\") Generic way to set a form element value. Will be covered more in browser/forms forms payments.dollarAmount.setValue(\"104.5\")"],["browser@@element-actions-reference@@modifications-no-log","Browser","Element Actions Reference","Modifications No Log","payments.secret.sendKeysNoLog(\"my secret token\") payments.secret.setValueNoLog(\"my secret token\")"],["browser@@element-actions-reference@@move-over","Browser","Element Actions Reference","Move over","menu.hover()"],["browser@@element-actions-reference@@drag-and-drop","Browser","Element Actions Reference","Drag And Drop","def draggable = $(\"#draggable\") def dropZone = $(\"#drop-zone\") draggable.dragAndDropOver(dropZone) def draggable = $(\"#draggable\") draggable.dragAndDropBy(50, 50)"],["browser@@element-actions-reference@@scrolling","Browser","Element Actions Reference","Scrolling","sectionTwo.scrollIntoView() container.scrollToBottom() container.scrollToTop() container.scrollToRight() container.scrollToRight() container.scrollToLeft() container.scrollTo(100, 50)"],["browser@@element-values-reference@@wait-and-should","Browser","Element Values Reference","Wait And Should","Use waitTo to wait on a condition, and should to assert right away. All the code below you can freely swap between should and waitTo ."],["browser@@element-values-reference@@text-value","Browser","Element Values Reference","Text Value","header.should(equal(\"super search\")) > expecting by css #header to equal \"super search\" . by css #header equals \"super search\" (80ms)"],["browser@@element-values-reference@@attribute-value","Browser","Element Values Reference","Attribute Value","pageElement.attribute(\"class\").waitTo(equal(~/\\bfancy\\b/)) > waiting for attribute \"class\" of by css #table-wrapper to equal ~/\\bfancy\\b/ . attribute \"class\" of by css #table-wrapper equals ~/\\bfancy\\b/ (18ms)"],["browser@@forms@@universal-set-value","Browser","Forms","Universal Set Value","Use setValue on a declared page element to set its value. It will work on all the standard input types out of the box.Define all the input fields inside a page object. In combination with universal setValue it will make your tests robust.Given a html snippet <html> <body> <div id=\"form\"> <input id=\"name\" /> <input id=\"startDate\" type=\"date\" /> <input id=\"confirmation\" type=\"checkbox\" /> <div id=\"choice-group\" class=\"radio-group\"> <div> <input type=\"radio\" id=\"one\" name=\"choice\" value=\"value-one\"/> <label for=\"one\">one</label> </div> <div> <input type=\"radio\" id=\"two\" name=\"choice\" value=\"value-two\"/> <label for=\"two\">two</label> </div> <div> <input type=\"radio\" id=\"three\" name=\"choice\" value=\"value-three\"/> <label for=\"three\">three</label> </div> </div> <select id=\"rank\"> <option /> <option value=\"A\">Full A</option> <option value=\"B\">Full B</option> <option value=\"C\">Full C</option> <option value=\"D\">Full D</option> <option value=\"E\">Full E</option> </select> </div> </body> </html> Page object can be defined as package pages import static org.testingisdocumenting.webtau.WebTauDsl.* class FormPage { def name = $('#name') def rank = $('#rank') def confirmation = $('#confirmation') def choice = $('[name=\"choice\"]') def startDate = $('#startDate') }"],["browser@@forms@@default-input","Browser","Forms","Default Input","form.name.setValue('Full Automation')"],["browser@@forms@@date-input","Browser","Forms","Date Input","form.startDate.setValue('2016-06-21')"],["browser@@forms@@select","Browser","Forms","Select","form.rank.setValue('B') form.rank.setValue('Full B')"],["browser@@forms@@checkbox","Browser","Forms","CheckBox","form.confirmation.setValue(true)"],["browser@@forms@@radio-button","Browser","Forms","Radio Button","form.choice.setValue('value-two')"],["browser@@forms@@universal-assert","Browser","Forms","Universal Assert","Form element value can be asserted the same way as any regular element. Underlying value will be extracted based on the element type form.name.should == 'Full Automation' form.rank.should == 'Full B' form.confirmation.should == true form.choice.should == 'value-two' form.startDate.should == '2016-06-21'"],["browser@@forms@@custom-form-elements","Browser","Forms","Custom Form Elements","One of the benefits of universal set and assert is that your test is focused on the data and not implementation details. But what if you decided to use a custom component to enter the data?To hide implementation details from your test you should define a custom input handler for your UI component.Let's consider a form component that you can start interacting with only after you clicked it. And after the value is entered, the input box disappears again. <div id=\"answer\" class=\"special-selector\" onclick=\"activate('answer')\"> <div class=\"current-value\"> current value </div><input class=\"value-input\" value=\"\" onblur=\"valueEntered('answer')\"> </div> Our test should still be written in terms of data entering and validation. def customFormElement = $('#answer') customFormElement.setValue('hello') customFormElement.should == 'hello' In order to achieve this we need to register a custom handler. package scenarios.ui import static org.testingisdocumenting.webtau.WebTauGroovyDsl.* scenario('open forms') { browser.open('/special-forms') } scenario('get set custom based on registered handler') { def customFormElement = $('#answer') customFormElement.setValue('hello') customFormElement.should == 'hello' } package formHandlers import org.testingisdocumenting.webtau.browser.page.HtmlNodeAndWebElementList import org.testingisdocumenting.webtau.browser.page.PageElement import org.testingisdocumenting.webtau.browser.page.PageElementStepExecutor import org.testingisdocumenting.webtau.browser.handlers.PageElementGetSetValueHandler import org.testingisdocumenting.webtau.reporter.TokenizedMessage import static org.testingisdocumenting.webtau.WebTauDsl.browser class CustomInput implements PageElementGetSetValueHandler { @Override boolean handles(HtmlNodeAndWebElementList htmlNodeAndWebElements, PageElement pageElement) { def htmlNode = htmlNodeAndWebElements.firstHtmlNode() return htmlNode.attributes().class =~ /special-selector/ } @Override void setValue(PageElementStepExecutor stepExecutor, TokenizedMessage pathDescription, HtmlNodeAndWebElementList htmlNodeAndWebElements, PageElement pageElement, Object value, boolean noLog) { pageElement.click() pageElement.find('input').sendKeys(\"${value}\" + browser.keys.tab) } @Override Object getValue(HtmlNodeAndWebElementList htmlNodeAndWebElements, PageElement pageElement, int idx) { return pageElement.find('.current-value').extractSingleValue() } }"],["browser@@tables@@validating-table-data","Browser","Tables","Validating Table Data","Use to define a table on your page that you want to interact with. Once table is defined, you can validate it using should and waitTo . Groovy def summaryTable = browser.table(\"#summary\") summaryTable.should == [ \"column A\" | \"column B\" | \"column C\"] { _______________________________________ \"A-1\" | \"B-1\" | \"C-1\" \"A-2\" | \"B-2\" | \"C-2\" } Java var summaryTable = browser.table(\"#summary\"); summaryTable.should(equal(table(\"column A\", \"column B\", \"column C\", ____________________________________, \"A-1\" , \"B-1\", \"C-1\", \"A-2\" , \"B-2\", \"C-2\" ))); More details in matchers/tables Matchers"],["browser@@tables@@extracting-table-data","Browser","Tables","Extracting Table Data","Use to extract TableData for further processing, e.g. saving to a disk: Groovy def summaryTable = browser.table(\"#summary\") def tableData = summaryTable.extractTableData() data.csv.write(\"table-data.csv\", tableData) Java var summaryTable = browser.table(\"#summary\"); var tableData = summaryTable.extractTableData(); data.csv.write(\"table-data.csv\", tableData); Use to extract TableData from multiple tables matching the selector: Groovy def tablesList = browser.table(\"table\") def combinedTableData = tablesList.extractAndMergeTableData() data.csv.write(\"combined-table-data.csv\", combinedTableData) Java var tablesList = browser.table(\"table\"); var combinedTableData = tablesList.extractAndMergeTableData(); data.csv.write(\"combined-table-data.csv\", combinedTableData); Note: Only first table columns will be used"],["browser@@tables@@supported-tables-flavor","Browser","Tables","Supported Tables Flavor","WebTau supports standard HTML tables and https://www.ag-grid.com AG Grid.There is a mechanism to register new parsers. If you are interested in contributing a parser or learn how to do it, please https://github.com/testingisdocumenting/webtau/issues create a ticket"],["browser@@asynchronous-page@@synchronization","Browser","Asynchronous Page","Synchronization","Many actions in a modern web page are asynchronous. User presses a button and a moment later a result appears. In modern web pages there is no full page reload and only a portion of a page will be changed.If a test will try to assert a value after a user action, chances are assertion will fail since it will take time for a result to appear on a page.Question: How do users know that their action is done and they can move on?"],["browser@@asynchronous-page@@visible-hidden-element","Browser","Asynchronous Page","Visible/Hidden Element","One way to deal with asynchronous pages is to wait for a feedback to appear or disappear. calculation.start() calculation.feedback.waitToBe visible calculation.results.should == [100, 230]"],["browser@@asynchronous-page@@enabled-disabled-element","Browser","Asynchronous Page","Enabled/Disabled Element","Disabled input box and buttons can be used as a user feedback as well. calculation.open() calculation.input.waitToBe enabled calculation.input.setValue(100)"],["browser@@asynchronous-page@@wait-to-match","Browser","Asynchronous Page","Wait to match","If presence/absence of an element is not important, you can directly to wait for a matcher to match. calculation.start() calculation.results.waitTo == [100, 230] Note: any matcher that you can use with should and shouldNot can be used with waitTo and waitToNot"],["browser@@asynchronous-page@@wait-to-change","Browser","Asynchronous Page","Wait to change","Use change matcher when you want to wait for any change of a value without knowing the specifics. def number = $(\"#number-to-change\") def trigger = $(\"#change-number\") number.takeSnapshot() trigger.click() number.waitTo change > taking value snapshot by css #number-to-change . value snapshot is taken for by css #number-to-change (25ms) > clicking by css #change-number . clicked by css #change-number (232ms) > waiting for by css #number-to-change to change . by css #number-to-change changed (23ms)"],["browser@@asynchronous-page@@wait-on-url","Browser","Asynchronous Page","Wait on url","Another cue to use could be a url change after an action. browser.open('/resource-creation') $('#new').click() browser.url.ref.waitTo == 'created-id' Note: url exposes other parts that you can browser/navigation#assert-url read more about here"],["browser@@documentation-artifacts@@usage-scenarios","Browser","Documentation Artifacts","Usage Scenarios","To document how to use a User Interface we often take screenshots and annotate them. At the same time we need to make sure that the documented scenario works as advertised.With UI testing we can validate scenarios and at the same time capture screenshots with automatically placed annotations."],["browser@@documentation-artifacts@@capturing-screenshots-with-annotations","Browser","Documentation Artifacts","Capturing Screenshots With Annotations","To capture screenshots use browser.doc[.withAnnotations][.withRoot].capture : search.submit(\"search this\") browser.doc.withAnnotations( browser.doc.badge(search.box), browser.doc.badge(search.results)).capture(\"search\") The result of the capture command is two files:captured screenshot search.json { \"shapes\" : [ { \"type\" : \"badge\", \"text\" : \"1\", \"x\" : 111, \"y\" : 78, \"align\" : \"Center\" }, { \"type\" : \"badge\", \"text\" : \"2\", \"x\" : 450, \"y\" : 166, \"align\" : \"Center\" } ], \"pixelRatio\" : 1 } https://testingisdocumenting.org/webtau WebTau documentation site is generated using https://github.com/testingisdocumenting/znai Znai. It has include-image plugin that supports annotations format generated by capture command. :include-image: doc-artifacts/search.png {fit: true, annotate: true}"],["browser@@documentation-artifacts@@badge-shortcut","Browser","Documentation Artifacts","Badge Shortcut","Badge annotation is an easy-to-use one to tell a story. Numeric values help to bring the focus and explain a user a sequence of events.When annotation type is not specified, badge is used as the default. search.submit(\"search this\") browser.doc.withAnnotations(search.box, search.results).capture(\"search-with-shortcut\")"],["browser@@documentation-artifacts@@annotation-types","Browser","Documentation Artifacts","Annotation Types","search.submit(\"search this\") browser.doc.withAnnotations( browser.doc.badge(search.box), browser.doc.badge(search.results)).capture(\"search\") browser.doc.withAnnotations( browser.doc.rect(search.box), browser.doc.rect(search.results, \"covering text\")).capture(\"search-rectangles\") browser.doc.withAnnotations( browser.doc.arrow(search.box, search.results, \"search result\")).capture(\"search-arrow\")"],["browser@@documentation-artifacts@@annotation-placement","Browser","Documentation Artifacts","Annotation Placement","Use above , below , toTheLeft and toTheRight to put an annotation outside of element center. browser.doc.withAnnotations( browser.doc.badge(search.box).toTheRight(), browser.doc.badge(search.results).above()).capture(\"search-diff-placement\")"],["browser@@documentation-artifacts@@screenshot-of-a-specific-element","Browser","Documentation Artifacts","Screenshot Of A Specific Element","Use to limit screenshot to a specific element search.submit(\"search this\") browser.doc.withRoot(search.resultsArea) .withAnnotations(browser.doc.badge(search.results)) .capture(\"search-results-area\")"],["browser@@advanced-configuration@@timeouts","Browser","Advanced Configuration","Timeouts","Default timeout in milliseconds for waitTo and waitToNot waitTimeout = 25000 --waitTimeout=25000"],["browser@@advanced-configuration@@browser-size","Browser","Advanced Configuration","Browser Size","Browser window size can be set using browserWidth and browserHeight url = \"http://localhost:8180\" browserWidth = 1280 browserHeight = 800"],["browser@@advanced-configuration@@documentation-artifacts","Browser","Advanced Configuration","Documentation Artifacts","By default, all generated documentation artifacts (e.g. screenshots) are created in the current directory. To override url = \"http://localhost:8180\" docPath = \"screenshots\""],["browser@@test-containers@@default-webdriver-creation","Browser","Test Containers","Default WebDriver Creation","By default, WebTau creates https://www.selenium.dev Selenium WebDriver by pointing to a local browser. WebTau also downloads a driver using https://github.com/bonigarcia/webdrivermanager WebDriver Manager.To handle scenarios where local browsers are not an option, WebTau provides an integration with https://www.testcontainers.org Test Containers."],["browser@@test-containers@@explicit-selenium-test-containers","Browser","Test Containers","Explicit Selenium Test Containers","To support https://www.testcontainers.org Test Containers explicitly, WebTau expose browser.setDriver to force a specific driver to use: @WebTau public class BrowserTestContainerJavaTest { private final PageElement box = $(\"#search-box\"); private final PageElement results = $(\"#results .result\"); private final PageElementValue<Integer> numberOfResults = results.count; private static BrowserWebDriverContainer<?> seleniumContainer; @BeforeAll public static void setupDriverUsingTestContainer() { step(\"preparing selenium test container\", () -> { Testcontainers.exposeHostPorts(browser.getBaseUrlPort()); FirefoxOptions firefox = new FirefoxOptions(); seleniumContainer = new BrowserWebDriverContainer<>() .withCapabilities(firefox); seleniumContainer.start(); browser.setDriver(new RemoteWebDriver(seleniumContainer.getSeleniumAddress(), firefox)); }); } @AfterAll public static void shutdownContainer() { seleniumContainer.stop(); } @Test public void search() { browser.open(\"/search\"); box.setValue(\"search this\"); box.sendKeys(browser.keys.enter); numberOfResults.waitToBe(greaterThan(1)); } }"],["browser@@test-containers@@implicit-selenium-test-container","Browser","Test Containers","Implicit Selenium Test Container","WebTau provides an option to simplify running tests using both local and https://www.testcontainers.org Test Containers based browser: browserId=firefox browserUrl=http://host.testcontainers.internal:8080 browserTestcontainersEnabled=true @WebTau public class BrowserImplicitTestContainerJavaTest { private final PageElement box = $(\"#search-box\"); private final PageElement results = $(\"#results .result\"); private final PageElementValue<Integer> numberOfResults = results.count; @Test public void search() { browser.open(\"/search\"); box.setValue(\"search this\"); box.sendKeys(browser.keys.enter); numberOfResults.waitToBe(greaterThan(1)); } } Read getting-started/configuration Configuration page to learn about how to override config values using different environments, system properties or environment variables."],["browser@@test-containers@@dependency","Browser","Test Containers","Dependency","By default, WebTau includes https://www.testcontainers.org Test Containers into groovy-standalone-runner/introduction Groovy Runner and into single catch-all dependency Groovy <dependency> <groupId>org.testingisdocumenting.webtau</groupId> <artifactId>webtau-groovy</artifactId> <version>2.3</version> </dependency> Java <dependency> <groupId>org.testingisdocumenting.webtau</groupId> <artifactId>webtau</artifactId> <version>2.3</version> </dependency> If you cherry-pick WebTau dependencies, then you need to add this to your list: <dependency> <groupId>org.testingisdocumenting.webtau</groupId> <artifactId>webtau-browser-testcontainers</artifactId> <version>2.3</version> </dependency>"],["browser@@local-storage@@access-local-storage","Browser","Local Storage","Access Local Storage","To access local storage use browser.localStorage .Lets consider a simple web page that displays a value from a local storage. <div id=\"favorite-color\"> </div> <script> const element = document.getElementById('favorite-color'); element.innerHTML = localStorage.getItem('favoriteColor'); </script> package scenarios.ui import static org.testingisdocumenting.webtau.WebTauGroovyDsl.* scenario(\"local storage api\") { browser.open('/local-storage') browser.localStorage.setItem('favoriteColor', 'clean') def color = $('#favorite-color') browser.reopen('/local-storage') color.should == 'clean' browser.localStorage.clear() browser.reopen('/local-storage') color.should == '' } public String getItem(String key) public void setItem(String key, String value) public void removeItem(String key) public void clear() public int size()"],["browser@@cookies@@add-cookies","Browser","Cookies","Add Cookies","browser.cookies.add(\"cookie-a\", \"hello\") browser.cookies.add(\"cookie-b\", \"world\")"],["browser@@cookies@@get-cookies","Browser","Cookies","Get Cookies","browser.cookies.get(\"cookie-a\").should == \"hello\" browser.cookies.get(\"cookie-b\").should == \"world\" browser.cookies.getAll().should == [\"cookie-a\": \"hello\", \"cookie-b\": \"world\"]"],["browser@@cookies@@delete-cookies","Browser","Cookies","Delete Cookies","browser.cookies.delete(\"cookie-b\") browser.cookies.deleteAll()"],["browser@@navigation@@open","Browser","Navigation","Open","To open a page use browser.open . Browser will load a page only if the current url doesn't match the passed one. search.submit('query') browser.open(\"/search\") // page is not be ing refreshed search.searchMessage.should == 'searching for query' Note: relative url will be automatically expanded to the full url based on the browser/basic-configuration configuration"],["browser@@navigation@@reopen","Browser","Navigation","Reopen","Use brower.reopen to force open the page even if the page url already matches the passed one. search.submit('name') browser.reopen(\"/search\") // page is going to be refreshed search.searchMessage.should == ''"],["browser@@navigation@@refresh","Browser","Navigation","Refresh","Use browser.refresh to refresh current page. search.submit('name') browser.reopen(\"/search\") // page is going to be refreshed search.searchMessage.should == ''"],["browser@@navigation@@restart","Browser","Navigation","Restart","Use browser.restart to restart a browser and open last opened url. browser.open('/local-storage') browser.localStorage.setItem('favoriteColor', 'pretty') browser.refresh() $('#favorite-color').should == 'pretty' browser.restart() $('#favorite-color').should == '' Note: restarting creates a clean instance of a browser. Local storage is going to be reset."],["browser@@navigation@@assert-url","Browser","Navigation","Assert URL","Use browser.url to assert on or wait for url changes. http://example.com/resource/id?type=full&debug=true#subId browser.url.path.should == '/resource/id' browser.url.path.should contain('/id') browser.url.query.should == 'type=full&debug=true' browser.url.ref.should == 'subId' browser.url.should == 'http://example.com/resource/id?type=full&debug=true#subId' browser.url.should contain('resource/id?type=') browser.url.path.waitTo == '/resource/id' browser.url.query.waitTo == 'type=full&debug=true' browser.url.ref.waitTo == 'subId'"],["browser@@navigation@@persist-url","Browser","Navigation","Persist URL","Use browser.saveCurrentUrl to save url in a local cache and browser.openSavedUrl to open a page later.It can be handy in multipart tests where first part creates an entity and the second part updates the created entity. browser.open('/resource-creation') $('#new').click() browser.saveCurrentUrl() In order to simplify tests development of a second part you can run first part once, save URL, and iterate on a second part by opening a page using saved URL. browser.openSavedUrl() // continue resource related manipulations Note: url is stored in a local cache file and will survive tests restart."],["browser@@navigation@@assert-title","Browser","Navigation","Assert Title","browser.title.should == \"Super Search\" browser.title.waitTo == \"Super Search\""],["browser@@navigation@@back-and-forward","Browser","Navigation","Back And Forward","Use and to simulate browser history Back and Forward buttons browser.back() browser.forward()"],["browser@@alerts@@dismiss-alert","Browser","Alerts","Dismiss Alert","Use browser.alert to manipulate browser alerts.To dismiss alert use: browser.alert.dismiss() > dismissing alert dismissed alert text: _____ hello alert _____ . dismissed alert (24ms)"],["browser@@alerts@@accept-alert","Browser","Alerts","Accept Alert","To accept alert use: browser.alert.accept() > accepting alert accepted alert text: _______ hello confirm _______ . accepted alert (22ms)"],["browser@@alerts@@alert-text","Browser","Alerts","Alert Text","To wait on or validate alert text use: browser.alert.text.waitTo == \"hello delayed\\nalert\" browser.alert.accept() > waiting for text of browser alert to equal _____________ hello delayed alert _____________ . text of browser alert equals _____________ hello delayed alert _____________ (129ms)"],["browser@@page-open-handlers@@implicit-page-open-logic","Browser","Page Open Handlers","Implicit Page Open Logic","You can register a custom callback that will be called implicitly every time a web page is opened. One of the typical use cases is to inject cookies or values into a local storage before tests logic begins."],["browser@@page-open-handlers@@auto-login","Browser","Page Open Handlers","Auto Login","To register an open handler you need to define browserPageNavigationHandlerProvider config value. url = \"http://localhost:8180\" def userNameKey = 'userName' browserPageNavigationHandler = { passedUrl, fullUrl, currentUrl -> if (browser.localStorage.getItem(userNameKey)) { return } browser.localStorage.setItem(userNameKey, 'LoggedIn User') browser.reopen(fullUrl) } package scenarios.ui import static org.testingisdocumenting.webtau.WebTauGroovyDsl.* scenario(\"page open handlers\") { browser.open('/logged-in-user') $('#welcome').should == 'Welcome LoggedIn User' } scenario(\"page open handlers during re-open\") { browser.localStorage.clear() browser.reopen('/logged-in-user') $('#welcome').should == 'Welcome LoggedIn User' } Note: usage of localStorage is just an example. You can use cookies , call external services using http. or load credentials from a file system."],["browser@@finders-and-filters@@finders","Browser","Finders And Filters","Finders","Finders in WebTau is the initial web element selection that could select one or more elements."],["browser@@finders-and-filters@@css-finder","Browser","Finders And Filters","CSS Finder","Use $ or browser.element to select an element by a given css selector ( https://www.w3schools.com/cssref/css_selectors.asp Read W3Schools CSS selectors to learn all kind of CSS selection techniques). def welcomeMessage = $(\"#welcome\") welcomeMessage.should == \"hello\" If more than one element is matched, the first one will be used for actions and assertions. def menu = $(\"ul li a\") menu.should == \"book\" While click and sendKeys will always work on a first element only, the matchers can work with a list of things. def menu = $(\"ul li a\") menu.should == [\"book\", \"orders\", \"help\"] Note: declaring element this way will not trigger element search right away."],["browser@@finders-and-filters@@basic-filters","Browser","Finders And Filters","Basic Filters","You can use filters to narrow down elements selected by finders.Use get method to filter found elements byElement number Element text Element regexp def ordersMenu = $(\"ul li a\").get(2) ordersMenu.should == \"orders\" def ordersMenu = $(\"ul li a\").get(\"orders\") ordersMenu.should == \"orders\" def ordersMenu = $(\"ul li a\").get(~/ord/) ordersMenu.should == \"orders\""],["browser@@finders-and-filters@@filter-by-distance","Browser","Finders And Filters","Filter By Distance","def button = $(\"button\") def helloMessage = $(\"#hello-message\") button.nearby(helloMessage).should == \"World2\""],["browser@@finders-and-filters@@chaining","Browser","Finders And Filters","Chaining","After you filtered, you can use finders again to find nested elements. def ordersMenu = $(\"ul li\").get(2).find(\"a\") ordersMenu.should == \"orders\""],["browser@@finders-and-filters@@parent-finder","Browser","Finders And Filters","Parent Finder","def welcomeMessage = $(\"#welcome\") def wrapper = welcomeMessage.parent() wrapper.attribute(\"class\").should == \"wrapper-class\""],["browser@@finders-and-filters@@parent-finder-by-css","Browser","Finders And Filters","Parent Finder By CSS","def welcomeMessage = $(\"#welcome\") def mainWrapper = welcomeMessage.parent(\".top-section\") mainWrapper.attribute(\"class\").should == \"top-section\""],["browser@@matchers@@text","Browser","Matchers","Text","def message = $(\"#message\") message.should == \"Select option\" def message = $(\"#message\") message.should == ~/option/ def menu = $(\"#menu ul li\") menu.should == [\"Hello\", \"Text\", \"World\"] def message = $(\"#message\") message.should contain(\"option\") def menu = $(\"#menu ul li\").all() menu.should contain(\"Text\") Note: all() is used at element declaration time to disambiguate between contain text in the first element and in the list of elements. It is not required when you do an explicit comparison with the list on the right, since then WebTau can deduce the desired outcome. def menu = $(\"#menu ul li\") menu.should == [\"Hello\", ~/T..t/, \"World\"]"],["browser@@matchers@@numbers","Browser","Matchers","Numbers","def total = $(\"#total\") total.should == 300.6 def total = $(\"#total\") total.shouldBe > 200 def total = $(\"#total\") total.shouldBe >= 300 def split = $(\"#split ul li\") split.should == [100, 28, 172.6] def split = $(\"#split ul li\") split.should == [100, lessThan(100), greaterThanOrEqual(150)]"],["browser@@matchers@@state","Browser","Matchers","State","<div><button id=\"action\" disabled>Click me</button> <div id=\"feedback\" style=\"display: none;\"></div> </div> def button = $(\"#action\") button.shouldBe disabled button.shouldNotBe enabled def feedback = $(\"#feedback\") feedback.shouldBe hidden feedback.shouldNotBe visible"],["browser@@matchers@@snapshot-and-change","Browser","Matchers","Snapshot And Change","def number = $(\"#number-to-change\") def trigger = $(\"#change-number\") number.takeSnapshot() trigger.click() number.waitTo change > taking value snapshot by css #number-to-change . value snapshot is taken for by css #number-to-change (25ms) > clicking by css #change-number . clicked by css #change-number (232ms) > waiting for by css #number-to-change to change . by css #number-to-change changed (23ms)"],["servers@@introduction@@","Servers","Introduction","","WebTau server module lets you create and control static, fake and proxy servers:Static servers to quickly host HTML, JSON, and similar content Fake servers to control response based request Proxy servers to simulate outages and record interactions for failures investigation def myServer = server.serve(\"my-server\", \"data/staticcontent\") def router = server.router() .get(\"/hello/:name\") { request -> server.response([message: \"hello ${request.param(\"name\")}\"]) } .get(\"/bye/:name\") { request -> server.response([message: \"bye ${request.param(\"name\")}\"]) } def proxyServer = server.proxy(\"test-proxy-server\", targetServer.baseUrl) You can apply overrides to any created server. You can also put servers into a \"bad\" state. proxyServer.markUnresponsive() def router = server.router() .get(\"/hello/:name\") {request -> server.response([message: \"hello ${request.param(\"name\")}\"]) } myServer.addOverride(router)"],["servers@@static-server@@serve-static-content","Servers","Static Server","Serve Static Content","Use to start a server on random port that will host static content from the specified directory. Groovy def myServer = server.serve(\"my-server\", \"data/staticcontent\") Check servers/import-and-dependencies Import And Dependencies for prerequisites. Java WebTauServer myServer = server.serve(\"my-server\", \"src/test/resources/staticcontent\"); Check servers/import-and-dependencies Import And Dependencies for prerequisites. { \"id\": \"user-one\", \"type\": \"person\" } Groovy http.get(\"${myServer.baseUrl}/data.json\") { body.type == \"person\" } Java http.get(myServer.getBaseUrl() + \"/data.json\", ((header, body) -> { body.get(\"type\").should(equal(\"person\")); }));"],["servers@@static-server@@set-server-as-base-url","Servers","Static Server","Set Server As Base Url","Use to use the server's host and port as base url Groovy myServer.setAsBaseUrl() Java myServer.setAsBaseUrl();"],["servers@@static-server@@host-html-for-browser","Servers","Static Server","Host Html For Browser","Use static server to host html files and then open them using a browser. <body> <p>hello</p> </body> Groovy http.get(\"/hello.html\") { body.should == expectedHtml } Java browser.open(\"/hello.html\"); $(\"p\").should(equal(\"hello\"));"],["servers@@static-server@@override-response","Servers","Static Server","Override Response","Use to modify response of a proxied server Groovy def router = server.router() .get(\"/hello/:name\") {request -> server.response([message: \"hello ${request.param(\"name\")}\"]) } myServer.addOverride(router) Java WebTauRouter router = server.router() .get(\"/hello/:name\", (request) -> server.response(map(\"message\", \"hello \" + request.param(\"name\")))); myServer.addOverride(router);"],["servers@@static-server@@server-slowdown","Servers","Static Server","Server Slowdown","Use to mark server as unresponsive Groovy myServer.markUnresponsive() code { http.get(\"/hello.html\") } should throwException(~/request timed out/) Java myServer.markUnresponsive(); code(() -> { http.get(\"/hello.html\"); }).should(throwException(Pattern.compile(\"request timed out\")));"],["servers@@static-server@@server-break","Servers","Static Server","Server Break","Use to mark server as broken Groovy myServer.markBroken() http.get(\"/hello.html\") { statusCode.should == 500 body.should == null } Java myServer.markBroken(); http.get(\"/hello.html\", (header, body) -> { header.statusCode.should(equal(500)); });"],["servers@@static-server@@server-fix","Servers","Static Server","Server Fix","Use to remove broken and/or slowdown state myServer.fix()"],["servers@@proxy-server@@proxy-servers-creation","Servers","Proxy Server","Proxy Servers Creation","Use to create a proxy server by specifying target url def proxyServer = server.proxy(\"test-proxy-server\", targetServer.baseUrl)"],["servers@@proxy-server@@override-calls","Servers","Proxy Server","Override Calls","Use to modify response of a proxied server def router = server.router(\"optional-router-id\") router.get(\"/another/{id}\", (request) -> server.response([anotherId: request.param(\"id\")])) proxyServer.addOverride(router) Note: override will not call proxied server, and will return a provided response"],["servers@@proxy-server@@preserve-original-call","Servers","Proxy Server","Preserve Original Call","Use HTTP/introduction HTTP Module to issue a call to a destination server with a possibility to change a request and provide a modified response.Example of a proxy server that makes original call, but returns an error def router = server.router().post(\"/hello\", { request -> def message = http.post(http.concatUrl(proxyServer.urlToProxy, request.path), http.header(request.header), request.contentAsMap) { return body.message } // optional logic with original response return server.statusCode(500) }) proxyServer.addOverride(router)"],["servers@@proxy-server@@server-slowdown","Servers","Proxy Server","Server Slowdown","Use to mark server as unresponsive proxyServer.markUnresponsive() code { http.get(\"${proxyServer.baseUrl}/another/hello\") { body.should == [anotherId: \"hello\"] } } should throwException(~/request timed out/)"],["servers@@proxy-server@@server-break","Servers","Proxy Server","Server Break","Use to mark server as broken proxyServer.markBroken() http.get(\"${proxyServer.baseUrl}/hello.html\") { statusCode.should == 500 body.should == null }"],["servers@@proxy-server@@server-fix","Servers","Proxy Server","Server Fix","Use to remove broken and/or slowdown state proxyServer.fix()"],["servers@@proxy-server@@max-threads","Servers","Proxy Server","Max Threads","Use serverProxyMaxThreads to change max number of threads available for proxy server"],["servers@@fake-server@@router-creation","Servers","Fake Server","Router Creation","Use to defined end points responses. Groovy def router = server.router() .get(\"/hello/:name\") { request -> server.response([message: \"hello ${request.param(\"name\")}\"]) } .get(\"/bye/:name\") { request -> server.response([message: \"bye ${request.param(\"name\")}\"]) } Check servers/import-and-dependencies Import And Dependencies for prerequisites. Java WebTauRouter router = server.router() .get(\"/hello/:name\", (request) -> server.response(map(\"message\", \"hello \" + request.param(\"name\")))) .get(\"/bye/:name\", (request) -> server.response(map(\"message\", \"bye \" + request.param(\"name\")))); Check servers/import-and-dependencies Import And Dependencies for prerequisites."],["servers@@fake-server@@fake-server-creation","Servers","Fake Server","Fake Server Creation","Use and a router to create a server with controlled responses Groovy def myServer = server.fake(\"my-rest-server\", router) http.get(\"${myServer.baseUrl}/hello/person\") { message.should == \"hello person\" } http.get(\"${myServer.baseUrl}/bye/person\") { message.should == \"bye person\" } Java myServer = server.fake(\"my-rest-server\", router); http.get(myServer.getBaseUrl() + \"/hello/person\", ((header, body) -> { body.get(\"message\").should(equal(\"hello person\")); })); http.get(myServer.getBaseUrl() + \"/bye/person?politeFactor=2\", ((header, body) -> { body.get(\"message\").should(equal(\"bye person\")); })); Note: If you omit serverId parameter, an auto generated one will be used instead. It affects what you see in the generated report"],["servers@@server-router@@router-creation","Servers","Server Router","Router Creation","Use to defined or override end-point responses for servers. Groovy def router = server.router() .get(\"/hello/:name\") { request -> server.response([message: \"hello ${request.param(\"name\")}\"]) } .get(\"/bye/:name\") { request -> server.response([message: \"bye ${request.param(\"name\")}\"]) } Check servers/import-and-dependencies Import And Dependencies for prerequisites. Java WebTauRouter router = server.router() .get(\"/hello/:name\", (request) -> server.response(map(\"message\", \"hello \" + request.param(\"name\")))) .get(\"/bye/:name\", (request) -> server.response(map(\"message\", \"bye \" + request.param(\"name\")))); Check servers/import-and-dependencies Import And Dependencies for prerequisites."],["servers@@server-router@@request-properties","Servers","Server Router","Request Properties","Path Parameters Use to access a path parameter value Groovy .get(\"/hello/:name\") { request -> server.response([message: \"hello \" + request.param(\"name\")]) } Java .get(\"/hello/:name\", (request) -> server.response(map(\"message\", \"hello \" + request.param(\"name\")))) Query Parameters Use to access a path parameter value Groovy .get(\"/bye/:name\") { request -> server.response([message: \"bye \" + request.queryParam(\"title\") + \" \" + request.param(\"name\")]) } Java .get(\"/bye/:name\", (request) -> server.response(map(\"message\", \"bye \" + request.queryParam(\"title\") + \" \" + request.param(\"name\"))));"],["servers@@import-and-dependencies@@server-specific-import","Servers","Import And Dependencies","Server Specific Import","When you use multiple WebTau features you can single static import to have all core features available for autocomplete. It also requires a single dependency to bring all the WebTau modules. Groovy import static org.testingisdocumenting.webtau.WebTauGroovyDsl.* <dependency> <groupId>org.testingisdocumenting.webtau</groupId> <artifactId>webtau-groovy</artifactId> <version>2.3</version> </dependency> If you use groovy-standalone-runner/introduction Groovy Runner then all the dependencies are already present. Java import static org.testingisdocumenting.webtau.WebTauDsl.*; <dependency> <groupId>org.testingisdocumenting.webtau</groupId> <artifactId>webtau</artifactId> <version>2.3</version> </dependency> To only import server module use Groovy import static org.testingisdocumenting.webtau.server.WebTauServerFacade.server <dependency> <groupId>org.testingisdocumenting.webtau</groupId> <artifactId>webtau-server</artifactId> <version>2.3</version> </dependency> Java import static org.testingisdocumenting.webtau.server.WebTauServerFacade.server; <dependency> <groupId>org.testingisdocumenting.webtau</groupId> <artifactId>webtau-server</artifactId> <version>2.3</version> </dependency>"],["cli@@introduction@@","Cli","Introduction","","WebTau provides cli. module to run and validate command line tools. Combine it with other modules to create powerful tests: use cli to run a tool, and http , graphql , browser , or db to validate the outcome. scenario(\"example of ls run\") { cli.run('ls') { output.should contain('scripts') } } webtau basicLs.groovy data dbproviders doc-artifacts formHandlers listeners pages personas scenarios schemas scripts use-cases.csv"],["cli@@foreground-command@@run","Cli","Foreground Command","Run","WebTau can run commands in foreground and in background . When command is ran in foreground WebTau will wait for the command to finish.To run a command use cli.run with a single string parameter that includes a command and all its arguments: cli.run('echo hello world')"],["cli@@foreground-command@@run-with-validation","Cli","Foreground Command","Run With Validation","cli.run('echo hello world') { output.should contain('hello') output.should contain('world') } cli.run('scripts/error-output') { error.should == 'error B892T' } cli.run('scripts/exit-code 8') { exitCode.should == 8 exitCode.shouldNot == 0 }"],["cli@@foreground-command@@implicit-exit-code-validation","Cli","Foreground Command","Implicit Exit Code Validation","WebTau performs implicit exit code validation and adds exitCode equals zero when you don't specify explicit exitCode validation. cli.run('echo hello world') Example above is equivalent to cli.run('echo hello world') { exitCode.should == 0 }"],["cli@@foreground-command@@run-result","Cli","Foreground Command","Run Result","Use the result of cli.run if you need to process the output of the command. def result = cli.run('scripts/my-script') { exitCode.shouldNot == 0 } println result.output println result.error if (result.exitCode == 1) { // ... } Warning: Perform validation inside validation block so WebTau can track what was checked. def result = cli.run('scripts/generate-id') def id = result.extractFromOutputByRegexp(\"id=(\\\\d+)\") def result = cli.run('scripts/generate-id') def id = result.extractFromErrorByRegexp(\"id=(\\\\d+)\")"],["cli@@foreground-command@@working-dir","Cli","Foreground Command","Working Dir","Use cli.workingDir as a second parameter to cli.run to set a working dir: cli.run('./listing', cli.workingDir('scripts')) { output.should contain('listing files') output.should contain('sleeps') }"],["cli@@foreground-command@@environment-variables","Cli","Foreground Command","Environment Variables","Use cli.env as a second parameter to cli.run to set the environment variables: #!/bin/bash echo \"hello $MY_VAR\" cli.run('scripts/hello-env-var', cli.env([MY_VAR: 'webtau'])) { output.should == 'hello webtau' }"],["cli@@foreground-command@@common-environment-variables","Cli","Foreground Command","Common Environment Variables","Set cliEnv config value with environment values that needs to be passed to each cli.run : cliEnv { MY_VAR = \"webtau\" PREFIX_VAR = \"__\" } cli.run('scripts/hello-env-var') { output.should == 'hello webtau' }"],["cli@@foreground-command@@chain-cli-run-config","Cli","Foreground Command","Chain Cli Run Config","Combine configs by using cli.env(...).workingDir(...) in any order to set both: cli.run('./hello-env-var', cli.workingDir('scripts').env([MY_VAR: 'webtau'])) { output.should == 'hello webtau' }"],["cli@@foreground-command@@path","Cli","Foreground Command","Path","To specify PATH to use for CLI commands lookup use cliPath = ['scripts/more']"],["cli@@foreground-command@@timeout","Cli","Foreground Command","Timeout","cli.run command fails if it doesn't complete in 30 seconds.To override default timeout use cliTimeout config value: cliTimeout = 400 To override timeout for a specific cli.run use cli.run(\"scripts/sleeps\", cli.timeout(300)) Note: Timeout value is specified in milliseconds"],["cli@@background-command@@run-in-background","Cli","Background Command","Run In Background","WebTau can run commands in foreground and in background . When command is ran in background WebTau will continue execution, leaving command to run its course.To run a command in a background use cli.runInBackground with a single string parameter that includes a command and all its arguments: cli.runInBackground('scripts/sleeps') println \"process above may still be running\""],["cli@@background-command@@stop-command","Cli","Background Command","Stop Command","Use .stop to explicitly terminate the running background command def command = cli.runInBackground('scripts/sleeps') println \"some commands that assume running process\" command.stop()"],["cli@@background-command@@interacting-with-command","Cli","Background Command","Interacting With Command","We are going to test a \"hello world\" script that asks you for a name and greet you: #!/bin/bash echo \"enter your name\" read name echo \"hello $name\" Use .send to send input to a running command. Use .output.waitTo to wait for command to rich a certain state: def helloWorld = cli.runInBackground(\"scripts/hello-world\") helloWorld.output.waitTo contain(\"enter your name\") helloWorld.send(\"webtau\\n\") helloWorld.output.waitTo contain(\"hello webtau\") helloWorld.stop() You can use << instead of .send for extra syntax sugar: def helloWorld = cli.runInBackground(\"scripts/hello-world\") helloWorld.output.waitTo contain(\"enter your name\") helloWorld << \"webtau\\n\" helloWorld.output.waitTo contain(\"hello webtau\") helloWorld.stop()"],["cli@@background-command@@wait-timeout","Cli","Background Command","Wait Timeout","By default, WebTau waitTo waits 5 seconds for a condition to become true. This value can be changed either globally by using config value groovy waitTimeout = 20000 To override wait timeout locally, use command.output.waitTo(contain(\"line two\"), 20_000)"],["cli@@background-command@@working-dir","Cli","Background Command","Working Dir","Use cli.workingDir as a second parameter to cli.runInBackground to set a working dir: def command = cli.runInBackground('./listing', cli.workingDir('scripts')) command.output.waitTo contain('listing files') command.output.waitTo contain('sleeps') command.stop()"],["cli@@background-command@@environment-variables","Cli","Background Command","Environment Variables","Use cli.env as a second parameter to cli.runInBackground to set the environment variables: #!/bin/bash echo \"hello $MY_VAR\" def command = cli.runInBackground('scripts/hello-env-var', cli.env([MY_VAR: 'webtau'])) command.output.waitTo contain('hello webtau') command.stop()"],["cli@@background-command@@common-environment-variables","Cli","Background Command","Common Environment Variables","Set cliEnv config value with environment values that needs to be passed to each cli.runInBackground : cliEnv { MY_VAR = \"webtau\" PREFIX_VAR = \"__\" } def command = cli.runInBackground('scripts/hello-env-var') command.output.waitTo contain('hello webtau') command.stop()"],["cli@@background-command@@chain-cli-run-config","Cli","Background Command","Chain Cli Run Config","Combine configs by using cli.env(...).workingDir(...) in any order to set both: def command = cli.runInBackground('./hello-env-var', cli.workingDir('scripts').env([MY_VAR: 'webtau'])) command.output.waitTo contain('hello webtau') command.stop()"],["cli@@background-command@@path","Cli","Background Command","Path","To specify PATH to use for CLI commands lookup use cliPath = ['scripts/more']"],["file-system@@introduction@@","File System","Introduction","","WebTau provides files system access layer fs. to help with files content access, validation and manipulation: file-content Access and validate file content copy Copy files archive Archive and Un-archive temporary-files-dirs Managing temporary files and directories"],["file-system@@file-content@@validation","File System","File Content","Validation","fs.textContent('my-test-file.txt').should == 'hello world\\nid=15'"],["file-system@@file-content@@content-extraction","File System","File Content","Content Extraction","Use .data to access actual file content for further processing def actualFileContent = fileTextContent.data Use extractByRegexp to extract content from a file by regular expression def id = fileTextContent.extractByRegexp(\"id=(\\\\d+)\") http.get(\"/customers/${id}\") { // ... }"],["file-system@@file-content@@write-to-file","File System","File Content","Write To File","def path = fs.writeText('my-test-file.txt', 'hello world')"],["file-system@@file-content@@replace-file-content","File System","File Content","Replace File Content","Use replaceText to replace text in place fs.replaceText(path, ~/(\\d+)/, '\"$1\"') a=1 b=2 a=\"1\" b=\"2\""],["file-system@@file-content@@wait-for-content","File System","File Content","Wait For Content","fs.textContent declares file content, but doesn't access it right away. WebTau reads file content when validation happens. Here is an example of waiting on file content: def fileTextContent = fs.textContent('my-test-file.txt') fileTextContent.waitTo contain('id=15') Use takeSnapshot and waitTo change to wait for any file change: def textContent = fs.textContent(path) textContent.takeSnapshot() ... textContent.waitTo change"],["file-system@@copy@@copy-to-a-directory","File System","Copy","Copy To A Directory","def dir = fs.createDir(\"my-dir\") fs.copy(\"data/message.txt\", dir) def dir = fs.tempDir(\"fs-copy\") fs.copy(\"data/message.txt\", dir)"],["file-system@@copy@@replace-file","File System","Copy","Replace File","fs.copy(\"data/message.txt\", \"data/new-message.txt\")"],["file-system@@archive@@archive","File System","Archive","Archive","def dest = fs.tempDir(\"for-zip\").resolve(\"content.zip\") fs.zip('data/staticcontent', dest)"],["file-system@@archive@@un-archive","File System","Archive","Un-archive","def dir = fs.tempDir('for-unzip') fs.unzip('data/data.zip', dir) def dir = fs.tempDir('for-untar') fs.untar('data/data.tar', dir)"],["file-system@@temporary-files-dirs@@temporary-dirs","File System","Temporary Files Dirs","Temporary Dirs","def dir = fs.tempDir(\"my-dir-prefix\") def path = dir.resolve(\"my-file\") fs.writeText(path, \"hello world\") def parentDir = fs.tempDir(\"my-dir-prefix\") def dir = fs.tempDir(parentDir, \"nested-temp-dir\")"],["file-system@@temporary-files-dirs@@temporary-files","File System","Temporary Files Dirs","Temporary Files","def file = fs.tempFile(\"my-file-prefix\", \".txt\") fs.writeText(file, \"hello world\") def dir = fs.tempDir(\"temp-dir-prefix\") def file = fs.tempFile(dir, \"my-file-prefix\", \".txt\") /tmp/temp-dir-prefix8084802582128730047/my-file-prefix3941553833767398593.txt"],["file-system@@temporary-files-dirs@@automatic-deletion","File System","Temporary Files Dirs","Automatic Deletion","Note: temp files and temp directories will be automatically deleted at the end of run"],["data@@introduction@@","Data","Introduction","","WebTau data module streamlines access to test data.Data access generates report/steps Report Steps to help with tests investigation. data/json json - access JSON test data data/csv csv - access CSV test data data/pdf pdf - access PDF data to validate data/base64 base64 - encode and decode base64 TableData table = data.csv.table(\"data/table.csv\") > reading csv from file or resource data/table.csv . read 3 lines of csv from file /home/runner/work/webtau/webtau/webtau-feature-testing/examples/data/table.csv (0ms)"],["data@@json@@read-list","Data","Json","Read List","Use data.json.list to read data as java.util.List from JSON file. Passed path is either relative based on working dir or absolute file path. Or it can be a resource class path. Groovy def list = data.json.list(\"data/flat-list.json\") list[0].name.should == \"hello\" list[1].payload.should == [info: ~/id2 payload/] Check data/import-and-dependencies Import And Dependencies for prerequisites. Java List<Map<String, ?>> list = data.json.list(\"data/flat-list.json\"); actual(list.get(0).get(\"name\")).should(equal(\"hello\")); actual(list.get(1).get(\"payload\")).should( equal(map(\"info\", Pattern.compile(\"id2 payload\")))); Check data/import-and-dependencies Import And Dependencies for prerequisites. read methods produce additional report to help with tests investigation > reading json from file or resource data/flat-list.json . read 16 lines of json from file /home/runner/work/webtau/webtau/webtau-feature-testing/examples/data/flat-list.json (0ms)"],["data@@json@@read-map","Data","Json","Read Map","Use data.json.map to read data as java.util.Map from JSON file. Passed path is either relative based on working dir or absolute path. Or it can be a resource class path. Groovy def map = data.json.map(\"data/root-map.json\") map.payload.should == [info: \"additional id1 payload\"] Java Map<String, ?> map = data.json.map(\"data/root-map.json\"); actual(map.get(\"payload\")).should(equal(map(\"info\", \"additional id1 payload\")));"],["data@@json@@read-tabledata","Data","Json","Read TableData","Use data.json.table to read data as TableData from JSON file. JSON must be a list. Passed path is either relative based on working dir or absolute file path. Or it can be a resource class path. Groovy def table = data.json.table(\"data/flat-list.json\") table.should == [ \"id\" | \"name\" | \"payload\"] { _________________________________________ \"id1\" | \"hello\" | [info: ~/id1 payload/] \"id2\" | \"world\" | [info: ~/id2 payload/] } Java TableData jsonTable = data.json.table(\"data/flat-list.json\"); TableData expected = table(\"id\" , \"name\" , \"payload\", ________________________________________________________________, \"id1\", \"hello\" , map(\"info\", Pattern.compile(\"id1 payload\")), \"id2\", \"world\" , map(\"info\", Pattern.compile(\"id2 payload\"))); actual(jsonTable).should(equal(expected));"],["data@@json@@read-object","Data","Json","Read Object","Use data.json.object to read data as either java.util.List or java.util.Map or a single value from JSON file. Passed path is either relative based on working dir or absolute file path. Or it can be a resource class path. Groovy def object = data.json.object(\"data/single.json\") object.should == \"hello world\" Java Object object = data.json.object(\"data/single.json\"); actual(object).should(equal(\"hello world\"));"],["data@@json@@parse-map","Data","Json","Parse Map","Use data.json.mapFromString to parse given JSON string as java.util.Map Groovy def map = data.json.mapFromString(\"\"\"{\"key\": \"value\"}\"\"\") map.should == [key: \"value\"] Java Map<String, ?> map = data.json.mapFromString(\"{\\\"key\\\": \\\"value\\\"})\"); actual(map).should(equal(map(\"key\", \"value\")));"],["data@@json@@parse-list","Data","Json","Parse List","Use data.json.listFromString to parse given JSON string as java.util.List Groovy def list = data.json.listFromString(\"\"\"[{\"key1\": \"value1\"}, {\"key2\": \"value2\"}]\"\"\") list.should == [ [key1: \"value1\"], [key2: \"value2\"]] Java List<Map<String, ?>> list = data.json.listFromString(\"[{\\\"key1\\\": \\\"value1\\\"}, {\\\"key2\\\": \\\"value2\\\"}]\"); actual(list).should(equal(list( map(\"key1\", \"value1\"), map(\"key2\", \"value2\"))));"],["data@@json@@parse-tabledata","Data","Json","Parse TableData","Use data.json.tableFromString to parse given JSON string as TableData Groovy def table = data.json.tableFromString(\"\"\" [ { \"id\": \"id1\", \"name\": \"hello\", \"payload\": { \"info\": \"additional id1 payload\" } }, { \"id\": \"id2\", \"name\": \"world\", \"payload\": { \"info\": \"additional id2 payload\" } } ] \"\"\") table.should == [ \"id\" | \"name\" | \"payload\"] { _________________________________________ \"id1\" | \"hello\" | [info: ~/id1 payload/] \"id2\" | \"world\" | [info: ~/id2 payload/] } Java TableData jsonTable = data.json.tableFromString(\"[\\n\" + \" {\\n\" + \" \\\"id\\\": \\\"id1\\\",\\n\" + \" \\\"name\\\": \\\"hello\\\",\\n\" + \" \\\"payload\\\": {\\n\" + \" \\\"info\\\": \\\"additional id1 payload\\\"\\n\" + \" }\\n\" + \" },\\n\" + \" {\\n\" + \" \\\"id\\\": \\\"id2\\\",\\n\" + \" \\\"name\\\": \\\"world\\\",\\n\" + \" \\\"payload\\\": {\\n\" + \" \\\"info\\\": \\\"additional id2 payload\\\"\\n\" + \" }\\n\" + \" }\\n\" + \"]\"); TableData expected = table(\"id\" , \"name\" , \"payload\", __________________________________________________________________, \"id1\", \"hello\" , map(\"info\", Pattern.compile(\"id1 payload\")), \"id2\", \"world\" , map(\"info\", Pattern.compile(\"id2 payload\"))); actual(jsonTable).should(equal(expected));"],["data@@json@@parse-object","Data","Json","Parse Object","Use data.json.objectFromString to parse given JSON string as either java.util.List or java.util.Map or a single value from JSON file. Groovy def object = data.json.objectFromString(\"\\\"hello world\\\"\") object.should == \"hello world\" Java Object list = data.json.objectFromString(\"\\\"hello world\\\"\"); actual(list).should(equal(\"hello world\"));"],["data@@json@@write-list","Data","Json","Write List","Use data.json.write to write data to JSON file. Groovy def list = [ [\"colA\": 1, \"colB\": \"R1\"], [\"colA\": 2, \"colB\": \"R2\"]] def path = data.json.write(\"generated/from-list-maps.json\", list) Java List<Map<String, ?>> list = list( map(\"colA\", 1, \"colB\", \"R1\"), map(\"colA\", 2, \"colB\", \"R2\")); Path path = data.json.write(\"generated/from-list-maps.json\", list); write methods produce additional information that helps with tests investigation > writing json to file generated/from-list-maps.json . wrote 7 lines to json /home/runner/work/webtau/webtau/webtau-feature-testing/examples/generated/from-list-maps.json (0ms) [ { \"colA\" : 1, \"colB\" : \"R1\" }, { \"colA\" : 2, \"colB\" : \"R2\" } ]"],["data@@json@@write-map","Data","Json","Write Map","Groovy def map = [\"colA\": 1, \"colB\": \"R1\"] def path = data.json.write(\"generated/from-map.json\", map) Java Map<String, ?> map = map(\"colA\", 1, \"colB\", \"R1\"); Path path = data.json.write(\"generated/from-list-maps.json\", map); { \"colA\" : 1, \"colB\" : \"R1\" }"],["data@@json@@write-table-data","Data","Json","Write Table Data","Groovy TableData table = [\"id\" | \"value\"] { ________________ \"id1\" | \"value1\" \"id2\" | \"value2\" } def path = data.json.write(\"generated/from-table-data.json\", table) Java TableData csvTable = table(\"id\" , \"value\", ________________, \"id1\" , \"value1\", \"id2\" , \"value2\"); Path path = data.json.write(\"generated/from-table-data.json\", csvTable); write methods produce additional information that helps with tests investigation > writing json to file generated/from-table-data.json . wrote 7 lines to json /home/runner/work/webtau/webtau/webtau-feature-testing/examples/generated/from-table-data.json (0ms) [ { \"id\" : \"id1\", \"value\" : \"value1\" }, { \"id\" : \"id2\", \"value\" : \"value2\" } ]"],["data@@csv@@table-data","Data","Csv","Table Data","Use data.csv.table to read data as TableData from CSV file. Passed path is either relative based on working dir or absolute file path. Or it can be a resource class path. A B C 1 2 3 a b c Groovy TableData table = data.csv.table(\"data/table.csv\") Check data/import-and-dependencies Import And Dependencies for prerequisites. Java TableData table = data.csv.table(\"data/table.csv\"); Check data/import-and-dependencies Import And Dependencies for prerequisites. read methods produce additional report to help with tests investigation > reading csv from file or resource data/table.csv . read 3 lines of csv from file /home/runner/work/webtau/webtau/webtau-feature-testing/examples/data/table.csv (0ms)"],["data@@csv@@table-data-conversion","Data","Csv","Table Data Conversion","By default, data.csv treats numeric values as strings and does not distinct between strings and dates. Pass valueConverter function to convert values according to your business logic. Groovy def valueConverter = { columnName, value -> columnName == \"date\" ? LocalDate.parse(value): value } def table = data.csv.table(\"data/with-dates.csv\", valueConverter) table.row(0).date.should == LocalDate.of(2022, 11, 26) table.row(0).date.class.canonicalName.should == \"java.time.LocalDate\" Java DataCsvValueConverter valueConverter = (columnName, value) -> columnName.equals(\"date\") ? LocalDate.parse(value): value; TableData table = data.csv.table(\"data/with-dates.csv\", valueConverter); actual(table.row(0).get(\"date\")).should(equal(LocalDate.of(2022, 11, 26))); actual(table.row(0).get(\"date\").getClass().getCanonicalName()).should(equal(\"java.time.LocalDate\")); If you only need to deal with numbers, use tableAutoConverted variant that automatically convert numeric values into Number Groovy def table = data.csv.tableAutoConverted(\"data/table.csv\") table.row(0).B.should == 2 table.row(0).B.class.canonicalName.should == \"java.lang.Long\" Java TableData table = data.csv.tableAutoConverted(\"data/table.csv\"); actual(table.row(0).get(\"B\")).should(equal(2)); actual(table.row(0).get(\"B\").getClass().getCanonicalName()).should(equal(\"java.lang.Long\"));"],["data@@csv@@list-of-map","Data","Csv","List Of Map","A B C 1 2 3 a b c Use data.csv.listOfMaps to read data as java.util.List of java.util.Map from CSV file. Passed path is either relative based on working dir or absolute file path. Or it can be a resource class path. Groovy def list = data.csv.listOfMaps(\"data/table.csv\") list.get(0).B.should == \"2\" list.get(0).B.class.canonicalName.should == \"java.lang.String\" Java List<Map<String, String>> list = data.csv.listOfMaps(\"data/table.csv\"); actual(list.get(0).get(\"B\")).should(equal(\"2\")); actual(list.get(0).get(\"B\").getClass().getCanonicalName()).should(equal(\"java.lang.String\")); Note: by default numeric values are read as strings, to auto convert numeric values to actual numbers use tableAutoConverted method Use data.csv.listOfMapsAutoConverted to read data as java.util.List of java.util.Map from CSV file. Numeric values become values of Numeric type instead of String type. Passed path is either relative based on working dir or absolute file path. Or it can be a resource class path. Groovy def list = data.csv.listOfMapsAutoConverted(\"data/table.csv\") list.get(0).B.should == 2 list.get(0).B.class.canonicalName.should == \"java.lang.Long\" Java List<Map<String, ?>> list = data.csv.listOfMapsAutoConverted(\"data/table.csv\"); actual(list.get(0).get(\"B\")).should(equal(2)); actual(list.get(0).get(\"B\").getClass().getCanonicalName()).should(equal(\"java.lang.Long\"));"],["data@@csv@@specify-header","Data","Csv","Specify Header","1, 2, 3 a, b, c Use data.csv.listOfMapsAutoConverted(header, path) to read data as java.util.List of java.util.Map from CSV file. Header will be taken from first parameter and first row of CSV file will not be treated as header. Numeric values become values of Numeric type instead of String type. Passed path is either relative based on working dir or absolute file path. Or it can be a resource class path. Groovy def list = data.csv.listOfMapsAutoConverted([\"C1\", \"C2\", \"C3\"], \"data/table-no-header.csv\") list.get(0).C2.should == 2 list.get(0).C2.class.canonicalName.should == \"java.lang.Long\" Java List<Map<String, ?>> list = data.csv.listOfMapsAutoConverted(list(\"C1\", \"C2\", \"C3\"), \"data/table-no-header.csv\"); actual(list.get(0).get(\"C2\")).should(equal(2)); actual(list.get(0).get(\"C2\").getClass().getCanonicalName()).should(equal(\"java.lang.Long\"));"],["data@@csv@@write-list","Data","Csv","Write List","Use data.csv.write to write data to CSV file. Groovy def list = [ [\"colA\": 1, \"colB\": \"R1\"], [\"colA\": 2, \"colB\": \"R2\"]] def path = data.csv.write(\"generated/from-list-maps.csv\", list) Java List<Map<String, ?>> list = list( map(\"colA\", 1, \"colB\", \"R1\"), map(\"colA\", 2, \"colB\", \"R2\")); Path path = data.csv.write(\"generated/from-list-maps.csv\", list); write methods produce additional information that helps with tests investigation > writing csv to file generated/from-list-maps.csv . wrote 4 lines to csv /home/runner/work/webtau/webtau/webtau-feature-testing/examples/generated/from-list-maps.csv (0ms) colA,colB 1,R1 2,R2"],["data@@csv@@write-table-data","Data","Csv","Write Table Data","Groovy TableData table = [\"id\" | \"value\"] { ________________ \"id1\" | \"value1\" \"id2\" | \"value2\" } def path = data.csv.write(\"generated/from-table-data.csv\", table) Java TableData csvTable = table(\"id\" , \"value\", ________________, \"id1\" , \"value1\", \"id2\" , \"value2\"); Path path = data.csv.write(\"generated/from-table-data.csv\", csvTable); write methods produce additional information that helps with tests investigation > writing csv to file generated/from-table-data.csv . wrote 4 lines to csv /home/runner/work/webtau/webtau/webtau-feature-testing/examples/generated/from-table-data.csv (1ms) id,value id1,value1 id2,value2"],["data@@pdf@@read-file-or-resource","Data","Pdf","Read File Or Resource","Use data.pdf.read(String) to read and parse PDF from a path. Passed path is either relative based on working dir or absolute path. Or it can be a resource class path. Pdf pdf = data.pdf.read(\"sample.pdf\") pdf.pageText(0).should contain('Test text paragraph Test') Check data/import-and-dependencies Import And Dependencies for prerequisites."],["data@@pdf@@http-response","Data","Pdf","HTTP response","Use data.pdf.parse(body) to parse and assert PDF content from binary response. Groovy http.get(\"/report\") { data.pdf.read(body).pageText(0).should contain(\"Quarterly earnings:\") } Java http.get(\"/report\", ((header, body) -> { data.pdf.read(body).pageText(0).should(contain(\"Quarterly earnings:\")); })); Learn More about HTTP/body#pdf-response HTTP response"],["data@@pdf@@read-bytes","Data","Pdf","Read Bytes","byte[] pdfContent = pdfBinaryContent() Pdf pdf = data.pdf.read(pdfContent) pdf.pageText(0).should contain('Test text paragraph Test')"],["data@@base64@@encode","Data","Base64","Encode","Check data/import-and-dependencies Import And Dependencies for prerequisites. String encoded = data.base64.encode(\"hello world\") encoded.should == \"aGVsbG8gd29ybGQ=\""],["data@@base64@@decode","Data","Base64","Decode","String decoded = data.base64.decode(\"aGVsbG8gd29ybGQ=\") decoded.should == \"hello world\""],["data@@import-and-dependencies@@data-specific-import","Data","Import And Dependencies","Data Specific Import","When you use multiple WebTau features you can single static import to have all core features available for autocomplete. It also requires a single dependency to bring all the WebTau modules. Groovy import static org.testingisdocumenting.webtau.WebTauGroovyDsl.* <dependency> <groupId>org.testingisdocumenting.webtau</groupId> <artifactId>webtau-groovy</artifactId> <version>2.3</version> </dependency> If you use groovy-standalone-runner/introduction Groovy Runner then all the dependencies are already present. Java import static org.testingisdocumenting.webtau.WebTauDsl.*; <dependency> <groupId>org.testingisdocumenting.webtau</groupId> <artifactId>webtau</artifactId> <version>2.3</version> </dependency> To only import data module use Groovy import static org.testingisdocumenting.webtau.data.Data.data <dependency> <groupId>org.testingisdocumenting.webtau</groupId> <artifactId>webtau-data</artifactId> <version>2.3</version> </dependency> Java import static org.testingisdocumenting.webtau.data.Data.data; <dependency> <groupId>org.testingisdocumenting.webtau</groupId> <artifactId>webtau-data</artifactId> <version>2.3</version> </dependency>"],["persona@@introduction@@persona-context","Persona","Introduction","Persona Context","WebTau persona defines a user of your system with a context associated with that user. Example of context: authentication credentials, browser, custom config parameters. scenario('context example') { Alice { step(\"do something in context of Alice\") { customAction() } } Bob { step(\"do same thing in context of Bob\") { customAction() } } } Alice and Bob execute the same action. Within the action we can access who is the current persona and what is the payload of the persona. def customAction() { def id = Persona.currentPersona.id def authId = Persona.currentPersona.payload.authId // from persona payload def email = cfg.email // from persona associated config override step(\"custom action\", [authId: authId, email: email]) { println \"authenticating $id\" } }"],["persona@@introduction@@context-definition","Persona","Introduction","Context Definition","Persona is defined with persona . Persona can be created in place or in centralized place package personas import static org.testingisdocumenting.webtau.WebTauCore.persona class Personas { public static def Alice = persona(\"Alice\", [authId: \"alice-user-id\"]) public static def Bob = persona(\"Bob\", [authId: \"bob-user-id\"]) } Per persona config section let you define or override any config value, including timeouts, browser preferences, etc email = \"default@email.send\" customValue = 100 personas { Alice { email = \"alice@email.send\" customValue = 105 } Bob { email = \"bob@email.send\" customValue = 110 } } Snippet from above example to show how to access config values and payload def authId = Persona.currentPersona.payload.authId // from persona payload def email = cfg.email // from persona associated config override"],["persona@@introduction@@report","Persona","Introduction","Report","Report captures what step was performed by what persona"],["persona@@HTTP-persona@@authorization","Persona","HTTP Persona","Authorization","In HTTP/header#implicit-header http headers section we defined how to use an implicit header provider to enable authentication/authorization Groovy package scenarios.rest.headers import scenarios.rest.headers.auth.Auth url = \"http://localhost:8080\" httpHeaderProvider = Auth.&authHeader package scenarios.rest.headers.auth import org.testingisdocumenting.webtau.http.HttpHeader class Auth { static HttpHeader authHeader(String fullUrl, String url, HttpHeader original) { def token = generateToken() return original.with([Authorization: \"Bearer $token\"]) } private static String generateToken() { return \"jwt-token\" } } Java In case of JUnit like runners, WebTau uses https://docs.oracle.com/javase/8/docs/api/java/util/ServiceLoader.html Service Loaders to locate header providers com.example.tests.junit5.config.HttpAuthHeaderProvider package com.example.tests.junit5.config; import org.testingisdocumenting.webtau.http.HttpHeader; import org.testingisdocumenting.webtau.http.config.WebTauHttpConfiguration; import static org.testingisdocumenting.webtau.WebTauDsl.*; public class HttpAuthHeaderProvider implements WebTauHttpConfiguration { @Override public HttpHeader fullHeader(String fullUrl, String passedUrl, HttpHeader given) { String token = generateToken(); return given.with(\"Authorization\", \"Bearer \" + token); } private String generateToken() { return \"jwt-token\"; } }"],["persona@@HTTP-persona@@persona-authorization","Persona","HTTP Persona","Persona Authorization","Let's define authorization based on persona context. persona/introduction#context-definition Previously we defined two personas Groovy package personas import static org.testingisdocumenting.webtau.WebTauCore.persona class Personas { public static def Alice = persona(\"Alice\", [authId: \"alice-user-id\"]) public static def Bob = persona(\"Bob\", [authId: \"bob-user-id\"]) } Java package com.example.tests.junit5; import org.testingisdocumenting.webtau.persona.Persona; public class Personas { public static final Persona Alice = Persona.persona(\"Alice\", \"authId\", \"alice-user-id\"); public static final Persona Bob = Persona.persona(\"Bob\", \"authId\", \"bob-user-id\"); } Authorization test using persona concept looks like this Groovy package scenarios.rest.headers import static personas.Personas.* import static org.testingisdocumenting.webtau.WebTauGroovyDsl.* scenario(\"my bank balance\") { Alice { http.get(\"/statement\") { balance.shouldBe > 100 } } Bob { http.get(\"/statement\") { balance.shouldBe < 50 } } } Java package com.example.tests.junit5; import org.junit.jupiter.api.Test; import org.testingisdocumenting.webtau.junit5.WebTau; import static com.example.tests.junit5.Personas.*; import static org.testingisdocumenting.webtau.WebTauDsl.*; @WebTau public class PersonaHttpJavaTest { @Test public void checkBalance() { Alice.execute(() -> http.get(\"/statement\", (header, body) -> { body.get(\"balance\").shouldBe(greaterThan(100)); })); Bob.execute(() -> http.get(\"/statement\", (header, body) -> { body.get(\"balance\").shouldBe(lessThan(50)); })); } } To make this example work, let's update implicit header provider above to take into account persona context Groovy package scenarios.rest.headers.auth import org.testingisdocumenting.webtau.http.HttpHeader import static org.testingisdocumenting.webtau.WebTauDsl.* class PersonaAuth { static HttpHeader authHeader(String fullUrl, String url, HttpHeader original) { def token = generateTokenBasedOnPersona() return original.with([Authorization: \"Bearer $token\"]) } static String generateTokenBasedOnPersona() { if (currentPersona.isDefault()) { // check if we are inside persona context or outside return generateDefaultToken() } return generateTokenForSystemUserId(currentPersona.payload.authId) // use persona payload to generate required token } static String generateTokenForSystemUserId(String systemUserId) { return \"dummy:$systemUserId\" // this is where you generate specific user auth token } static String generateDefaultToken() { return \"dummy:default-user\" // this is where you generate default user auth token } } Java package com.example.tests.junit5.config; import org.testingisdocumenting.webtau.http.HttpHeader; import org.testingisdocumenting.webtau.http.config.WebTauHttpConfiguration; import static org.testingisdocumenting.webtau.WebTauDsl.*; public class HttpPersonaAuthHeaderProvider implements WebTauHttpConfiguration { @Override public HttpHeader fullHeader(String fullUrl, String passedUrl, HttpHeader given) { String token = generateTokenBasedOnPersona(); return given.with(\"Authorization\", \"Bearer \" + token); } private String generateTokenBasedOnPersona() { if (getCurrentPersona().isDefault()) { // check if we are inside persona context or outside return generateDefaultToken(); } return generateTokenForSystemUserId( getCurrentPersona().getPayload().getOrDefault(\"authId\", \"\").toString()); // use persona payload to generate required token } private String generateTokenForSystemUserId(String systemUserId) { return \"dummy:\" + systemUserId; // this is where you generate specific user auth token } private String generateDefaultToken() { return \"dummy:default-user\"; // this is where you generate default user auth token } }"],["persona@@CLI-persona@@environment-variables","Persona","CLI Persona","Environment Variables","Each persona can have their own cli.run environment variable overridesCommon variables definition: cliEnv { MY_VAR = \"webtau\" PREFIX_VAR = \"__\" } Persona overrides personas { Alice { cliEnv.MY_VAR = \"Alice!\" } Bob { cliEnv.MY_VAR = \"Bob!\" } } Script that prints env variable value #!/bin/bash echo \"hello $MY_VAR\" Different value will be printed depending on the active persona Alice { cli.run('scripts/hello-env-var') { output.should == 'hello Alice!' } } Bob { cli.run('scripts/hello-env-var') { output.should == 'hello Bob!' } }"],["database@@introduction@@","Database","Introduction","","WebTau provides database access layer db. to help with data setup, validation and manipulation. Use it in conjunction with other layers like http. to write more powerful tests. database/data-setup Data Setup database/data-query Data Query PRICES << [ \"id\" | \"description\" | \"price\"] { ___________________________________ \"id1\" | \"nice set\" | 1000 \"id2\" | \"another set\" | 2000 } def prices = db.query(\"select * from PRICES where id=:id\", [id: \"id1\"]) prices.should == [\"ID\" | \"DESCRIPTION\" | \"PRICE\"] { ___________________________________ \"id1\" | \"nice set\" | 1000 }"],["database@@data-setup@@handcrafted-data","Database","Data Setup","Handcrafted Data","One way to set up a DB state is to use handcrafted reference/table-data TableData. def PRICES = db.table(\"PRICES\") // declare PRICES table PRICES << [ \"id\" | \"description\" | \"price\"] { // append two rows to PRICES ___________________________________ \"id1\" | \"nice set\" | 1000 \"id2\" | \"another set\" | 2000 } Alternatively use list of maps as the parameter to perform multiple rows insertion def PRICES = db.table(\"PRICES\") PRICES << [ [id: \"id1\", description: \"nice set\", price: 1000], [id: \"id2\", description: \"warm set\", price: 2000]] Use map as the parameter to perform a single row insertion def PRICES = db.table(\"PRICES\") PRICES << [id: \"id1\", description: \"nice set\", price: 1000]"],["database@@data-setup@@semi-auto-generated-tabledata","Database","Data Setup","Semi-Auto Generated TableData","reference/table-data TableData has features like reference/table-data#permutations permute and reference/table-data#guid cell.guid among others. Using them can reduce the effort required to maintain data setup. def PRICES = db.table(\"PRICES\") PRICES << [ \"id\" | \"description\" | \"available\" | \"type\" | \"price\" ] { _____________________________________________________________________________________________ cell.guid | \"nice set\" | true | \"card\" | 1000 // cell.guid generates random guid that can be used for ids cell.guid | \"nice set\" | true | \"card\" | cell.above + 10 // cell.above refers values above and can be modified with simple math operations cell.guid | \"another set\" | permute(true, false) | permute(\"rts\", \"fps\") | cell.above + 20 } // permute generates additional rows generating new rows with all the permutations Note: code above assumes WebTauCore.* static import or WebTauGroovyDsl.* static import import static org.testingisdocumenting.webtau.WebTauCore.* ID EXTERNAL_ID DESCRIPTION AVAILABLE TYPE PRICE 7d0ce0b8-47a5-4c4c-81b3-054fce1eb9f8 nice set true card 1000 358daaa7-f167-48c0-a8b4-22d89088cf7f nice set true card 1010 f16c6f53-ea39-4ca7-9ab2-2835df705f5e another set true rts 1030 8cea4d70-63f3-4d0f-8737-d2f60f302b88 another set false rts 1050 07016318-ab8c-4b54-9c3b-a2ee3d771d06 another set true fps 1070 e7628d82-5626-41f4-8a30-9a78ff7ba9fa another set false fps 1090"],["database@@data-setup@@external-file-tabledata","Database","Data Setup","External File TableData","def PRICES = db.table(\"PRICES\") PRICES << data.csv.table('prices-db.csv') id, description, available, type, price id1, description1, true, card, 200 id2, description2, false, rts, 400 ID EXTERNAL_ID DESCRIPTION AVAILABLE TYPE PRICE id1 description1 true card 200 id2 description2 false rts 400"],["database@@data-setup@@cleaning-tables","Database","Data Setup","Cleaning Tables","db.update(\"delete from PRICES where price > :price\", [price: 950]) db.update(\"delete from PRICES where price > :price\", 950) PRICES.clear()"],["database@@data-setup@@updating-tables","Database","Data Setup","Updating Tables","ID EXTERNAL_ID DESCRIPTION AVAILABLE TYPE PRICE id1 nice set 1000 id2 another set 2000 db.update(\"update PRICES set price=:price where id=:id\", [id: 'id2', price: 4000]) ID EXTERNAL_ID DESCRIPTION AVAILABLE TYPE PRICE id1 nice set 1000 id2 another set 4000"],["database@@data-query@@full-table","Database","Data Query","Full Table","To query all data from a table use: def PRICES = db.table(\"PRICES\") PRICES.should == [\"ID\" | \"DESCRIPTION\" | \"PRICE\"] { ___________________________________ \"id1\" | \"nice set\" | 1000 \"id2\" | \"another set\" | 2000 }"],["database@@data-query@@custom-query","Database","Data Query","Custom Query","def prices = db.query(\"select * from PRICES where id=:id\", [id: \"id1\"]) prices.should == [\"ID\" | \"DESCRIPTION\" | \"PRICE\"] { ___________________________________ \"id1\" | \"nice set\" | 1000 } def prices = db.query(\"select * from PRICES where id=:id\", [id: \"id1\"]) prices.should == [ID: \"id1\", \"DESCRIPTION\": \"nice set\", PRICE: 1000] def prices = db.query(\"select * from PRICES where id in (:ids)\", [ids: [\"id1\", \"id2\"]]) prices.should == [\"ID\" | \"DESCRIPTION\" | \"PRICE\"] { ___________________________________ \"id1\" | \"nice set\" | 1000 \"id2\" | \"another set\" | 2000 }"],["database@@data-query@@named-parameter-shortcut","Database","Data Query","Named Parameter Shortcut","If your query uses a single unique placeholder name, you can pass a regular value instead of a java.util.Map def prices = db.query(\"select * from PRICES where id=:id or external_id=:id\", \"id1\") prices.should == [ID: \"id1\", \"DESCRIPTION\": \"nice set\", PRICE: 1000]"],["database@@data-query@@lazy-declaration","Database","Data Query","Lazy Declaration","query doesn't query database at the call time. It defines a query to be used later. def prices = db.query(\"select * from PRICES\") prices.shouldNot == [] db.update(\"delete from PRICES\") prices.should == [] def PRICES = db.table(\"PRICES\") def numberOfItems = PRICES.queryCount() numberOfItems.shouldNot == 0 db.update(\"delete from PRICES\") numberOfItems.should == 0"],["database@@data-query@@single-value","Database","Data Query","Single Value","def price = db.query(\"select price from PRICES where id=:id\", [id: 'id1']) price.should == 1000 price.shouldNot == 2000"],["database@@data-query@@wait-on-result","Database","Data Query","Wait On Result","Use waitTo on query result to continuously query database until condition is met or timeout is reached. def count = db.query(\"select count(*) from PRICES\") count.should == 2 // event happen somewhere to increase the number of rows... count.waitTo == 3"],["database@@data-query@@query-result-value","Database","Data Query","Query Result Value","Value returned from query methods is an instance of DbQuery type. No actual query is performed when DbQuery instance is created. It holds information about what query is, and what its parameters and only performs query when validation is triggered.Use queryXXX to access underlying value. def price = db.query(\"select price from PRICES where id=:id\", [id: 'id1']) if (price.singleValue() > 100) { println(\"do something\") } Avoid: When you use queryXXX for assertions you may lose additional report information"],["database@@spring-boot-example@@database-setup","Database","Spring Boot Example","Database Setup","WebTau db. module can operate on JVM DataSource without providing JDBC URLs. In the following sections, we will cover https://spring.io/projects/spring-boot Spring Boot Repository Test.We need to configure WebTau db. module as well as Spring test one @DataJpaTest @ActiveProfiles(\"tc\") // test profile with Test Containers public class AccountRepositoryTest { private final AccountRepository accountRepository; private final Database mainDb; private final DatabaseTable ACCOUNT; @Autowired public AccountRepositoryTest(DataSource dataSource, AccountRepository accountRepository) { this.accountRepository = accountRepository; mainDb = db.labeled(\"main-db\").fromDataSource(dataSource); // define WebTau database instance to insert/read ACCOUNT = mainDb.table(\"ACCOUNT\"); // define ACCOUNT table instance to insert/read } Here is how we define tc profile using https://www.testcontainers.org/modules/databases/jdbc/ Test Containers JDBC support: # test containers special JDBC url spring.datasource.url=jdbc:tc:postgresql:9.6.8:///my-db spring.datasource.driverClassName=org.testcontainers.jdbc.ContainerDatabaseDriver spring.jpa.database-platform=org.hibernate.dialect.PostgreSQL95Dialect spring.jpa.hibernate.ddl-auto=create-drop # disable default in memory DB provided by @DataJpaTest spring.test.database.replace=none"],["database@@spring-boot-example@@write-directly-to-db","Database","Spring Boot Example","Write Directly To DB","Let's write data directly to database table, bypassing repository class, so we can isolate our test logic. @Test public void findById() { // define data to be inserted into DB TableData newAccounts = table( \"ID\", \"FIRST_NAME\", \"LAST_NAME\", ________________________________, \"id1\", \"FN1\" , \"LN1\", \"id2\", \"FN2\" , \"LN2\"); // insert directly to DB bypassing repository ACCOUNT.insert(newAccounts); // use accounts repository to fetch a record Account account = accountRepository.findById(\"id2\").get(); // use bean and map comparison shortcut actual(account).should(equal(map( \"id\", \"id2\", \"firstName\", \"FN2\", \"lastName\", \"LN2\"))); }"],["database@@spring-boot-example@@read-directly-from-db","Database","Spring Boot Example","Read Directly From DB","Now let's write data using repository and validate that DB table actually contains the data. We then will test a simple query by last name. @Test public void createEntriesAndFindByName() { TableData newAccounts = table( \"*id\", \"firstName\" , \"lastName\", ________________________________, \"id1\", \"FN1\" , \"LN\", \"id2\", \"FN2\" , \"LN\", \"id3\", \"FNN1\" , \"LNN\"); List<Account> accounts = createAccounts(newAccounts); // create accounts java beans from table data accountRepository.saveAll(accounts); // force data commit to DB TestTransaction.flagForCommit(); TestTransaction.end(); // query all data from DB, using * to note that we depend on ID for compare and not order ACCOUNT.query().should(equal(table(\"*ID\", \"FIRST_NAME\", \"LAST_NAME\", ________________________________, \"id1\", \"FN1\" , \"LN\", \"id2\", \"FN2\" , \"LN\", \"id3\", \"FNN1\" , \"LNN\"))); // WebTau will automatically convert actual column names from underscores to camelCase based on expected column names ACCOUNT.query().should(equal(newAccounts)); // search by last name and validate received java beans List<Account> lnAccounts = accountRepository.findByLastName(\"LN\"); actual(lnAccounts).should(equal(table(\"*id\", \"firstName\", \"lastName\", ______________________________, \"id1\", \"FN1\" , \"LN\", \"id2\", \"FN2\" , \"LN\"))); } private static List<Account> createAccounts(TableData tableData) { return tableData.rowsStream().map(row -> { Account account = new Account(); account.setId(row.get(\"id\")); account.setFirstName(row.get(\"firstName\")); account.setLastName(row.get(\"lastName\")); return account; }).collect(Collectors.toList()); }"],["database@@spring-boot-example@@re-using-data","Database","Spring Boot Example","Re-using Data","In the test above we repeated test data with only difference in column names. In setup, we used camelCase, and in expectations underscores.WebTau automatically converts data from one format to another depending on the context. I.e. if you compare table query result with FIRST_NAME as a column against a TableData with firstName column, WebTau will convert actual before comparison to match expected column names format. @Test public void findByIdReuseData() { // using camelCase for properties TableData newAccounts = table( \"*id\", \"firstName\" , \"lastName\", ________________________________, \"id1\", \"FN1\" , \"LN1\", \"id2\", \"FN2\" , \"LN2\"); // WebTau will automatically convert camelCase to underscores at insert time ACCOUNT.insert(newAccounts); // use accounts repository to fetch a record Account account = accountRepository.findById(\"id2\").get(); // reuse row from newAccounts table as expected value actual(account).should(equal(newAccounts.findByKey(\"id2\"))); } @Test public void createEntriesAndFindByNameReuseData() { TableData newAccounts = table(\"*id\", \"firstName\", \"lastName\", ______________________________, \"id1\", \"FN1\" , \"LN\", \"id2\", \"FN2\" , \"LN\", \"id3\", \"FNN1\" , \"LNN\"); List<Account> accounts = createAccounts(newAccounts); // create accounts java beans from table data accountRepository.saveAll(accounts); // force data commit to DB TestTransaction.flagForCommit(); TestTransaction.end(); // another way to compare. // WebTau will automatically convert actual column names from underscores to camelCase based on expected column names format ACCOUNT.query().should(equal(newAccounts)); // search by last name and validate received java beans List<Account> lnAccounts = accountRepository.findByLastName(\"LN\"); TableData expectedByLn = newAccounts.fromRowsByKeys(\"id1\", \"id2\"); actual(lnAccounts).should(equal(expectedByLn)); }"],["database@@spring-boot-example@@cleanup-between-tests","Database","Spring Boot Example","Cleanup Between Tests","In between tests we will explicitly delete data from DB @BeforeEach public void cleanupBeforeTest() { ACCOUNT.clear(); }"],["database@@spring-boot-example@@import-and-dependency","Database","Spring Boot Example","Import And Dependency","import static org.testingisdocumenting.webtau.db.Database.db; To include only Database module as your dependency use <dependency> <groupId>org.testingisdocumenting.webtau</groupId> <artifactId>webtau-data</artifactId> <version>2.3</version> </dependency>"],["database@@config@@jdbc","Database","Config","JDBC","WebTau is JVM based API and it uses https://en.wikipedia.org/wiki/Java_Database_Connectivity#:~:text=Java%20Database%20Connectivity%20(JDBC)%20is,used%20for%20Java%20database%20connectivity. JDBC interface behind the scenes to connect to a database.You don't need to know how to use JDBC API as WebTau expose higher level APIs, but you will need to understand how to build JDBC connection url to be able to connect to a database."],["database@@config@@primary-database","Database","Config","Primary Database","Primary DB config used when execute operations using db.update , db.query , etc, without specifying data source name. import groovy.grape.Grape Grape.grab(group:'com.h2database', module: 'h2', version: '1.4.200', // auto download DB driver dependency (in this case H2 db) classLoader: ClassLoader.getSystemClassLoader()) dbUrl = \"jdbc:h2:file:~/h2db/test-db\" // primary DB JDBC connection url dbDriverClassName = \"org.h2.Driver\" // JDBC driver class name dbUserName = \"sa\" dbPassword = \"password\""],["report@@introduction@@summary","Report","Introduction","Summary","Out of the box report provides high level information like number of failed tests and HTTP Operations coverage."],["report@@introduction@@continuous-integration","Report","Introduction","Continuous Integration","Example of continuous-integration/GitHub GitHub actions to upload reports during CI"],["report@@introduction@@test-summary","Report","Introduction","Test Summary","Selected a test to see summary information about the test run"],["report@@introduction@@failed-test-summary","Report","Introduction","Failed Test Summary","In case of a test failure, WebTau provides details on the failed step and highlights relevant code snippet:"],["report@@introduction@@permalinks","Report","Introduction","Permalinks","Report is a self-contained single page application. You can email it, upload to slack, put on a shared drive without an HTTP server. Url tracks your navigation through screens, so you can share url to a specific problem."],["report@@introduction@@data-tracking","Report","Introduction","Data Tracking","WebTau tracks all actions and assertions tests perform. Actions and assertions are printed to console as well as available in the generated HTML report.In a test details screen, there are multiple tabs.Layer specific details, e.g. HTTP, CLI, DB, Servers, etc Every action that was performed Every WebTau standard action generates WebTauStep . You can use WebTau API to wrap your repeating actions into WebTau compatible steps."],["report@@steps@@grouping-actions","Report","Steps","Grouping Actions","Check report/import-and-dependencies Import And Dependencies for prerequisites. Use step core method to wrap a set of actions into a group Groovy step(\"important actions\") { actionOne() actionTwo() } Java step(\"group of actions\", () -> { actionOne(); actionTwo(); }); > group of actions . completed group of actions (0ms)"],["report@@steps@@grouping-with-key-value","Report","Steps","Grouping With Key Value","Pass key values to step to combine step and `trace Groovy step(\"group of actions\", [url: baseUrl, port: myPort]) { actionThree(myPort, baseUrl) } Java step(\"important actions\", map(\"myPort\", myPort, \"baseUrl\", baseUrl), () -> { actionThree(myPort, baseUrl); }); > important actions myPort: 8080 baseUrl: \"http://baseurl\" [tracing] action three . completed important actions (1ms)"],["report@@tracing@@key-value","Report","Tracing","Key Value","Check report/import-and-dependencies Import And Dependencies for prerequisites. Use trace core method to render key-value pairs to a console and to generated web report. Groovy trace(\"trace label\", [k1: \"v1\", k2: \"v2\"]) trace(\"another trace label\", \"k3\", \"v3\", \"k4\", \"v4\") Java trace(\"trace label\", map(\"k1\", \"v1\", \"k2\", \"v2\")); trace(\"another trace label\", \"k3\", \"v3\", \"k4\", \"v4\"); [tracing] trace label k1: \"v1\" k2: \"v2\" [tracing] another trace label k3: \"v3\" k4: \"v4\""],["report@@tracing@@object-properties","Report","Tracing","Object Properties","Use trace and properties combo to trace object properties: def account = new Account(\"acc1\", \"my account\", 100) trace(\"my account\", properties(account)) [tracing] my account {\"id\": \"acc1\", \"money\": {\"dollars\": 100}, \"name\": \"my account\"}"],["report@@tracing@@multiple-objects-as-table","Report","Tracing","Multiple Objects As Table","Use trace and propertiesTable combo to trace object properties: def game1 = new GameConfig(\"super game\", Paths.get(\"/games/superA\")) game1.registerAchievement(\"chapter1\", \"Chapter One\", \"complete chapter one\") game1.registerAchievement(\"boss1\", \"Giant Rat\", \"defeat giant rat\") def game2 = new GameConfig(\"duper game\", Paths.get(\"/games/duperA\")) game2.registerAchievement(\"chapter2\", \"Chapter Two\", \"complete chapter two\") game2.registerAchievement(\"boss2\", \"Giant Mouse\", \"defeat giant mouse\") trace(\"games\", propertiesTable([game1, game2])) [tracing] games achievements │ gameName │ location [ │ \"super game\" │ /games/superA {\"description\": \"complete chapter one\", \"id\": \"chapter1\", \"name\": \"Chapter One\"}, │ │ {\"description\": \"defeat giant rat\", \"id\": \"boss1\", \"name\": \"Giant Rat\"} │ │ ] │ │ │ │ [ │ \"duper game\" │ /games/duperA {\"description\": \"complete chapter two\", \"id\": \"chapter2\", \"name\": \"Chapter Two\"}, │ │ {\"description\": \"defeat giant mouse\", \"id\": \"boss2\", \"name\": \"Giant Mouse\"} │ │ ] │ │"],["report@@warnings@@generate-warning","Report","Warnings","Generate Warning","Check report/import-and-dependencies Import And Dependencies for prerequisites. Use warning core method to mark something that needs to be looked at eventually. Groovy warning(\"warning message\") warning(\"warning message with map\", [k1: \"v1\", k2: \"v2\"]) warning(\"another warning message\", \"k3\", \"v3\", \"k4\", \"v4\") Java warning(\"warning message\"); warning(\"warning message with map\", map(\"k1\", \"v1\", \"k2\", \"v2\")); warning(\"another warning message\", \"k3\", \"v3\", \"k4\", \"v4\"); Let's take a look at the full test file example to see how warnings gets displayed Groovy import static org.testingisdocumenting.webtau.WebTauGroovyDsl.* scenario('warning label') { // warning-label warning(\"warning message\") // warning-label } scenario('warning key values') { // warning-map warning(\"warning message with map\", [k1: \"v1\", k2: \"v2\"]) // warning-map // warning-vararg warning(\"another warning message\", \"k3\", \"v3\", \"k4\", \"v4\") // warning-vararg } scenario warning label (warning.groovy) [warning] warning message [.] warning label (warning.groovy) scenario warning key values (warning.groovy) [warning] warning message with map k1: \"v1\" k2: \"v2\" [warning] another warning message k3: \"v3\" k4: \"v4\" Java import org.junit.jupiter.api.Test; import org.testingisdocumenting.webtau.junit5.WebTau; import static org.testingisdocumenting.webtau.WebTauDsl.*; @WebTau public class WarningJavaTest { @Test public void warningLabel() { // warning-label warning(\"warning message\"); // warning-label } @Test public void warningKeyValues() { // warning-map warning(\"warning message with map\", map(\"k1\", \"v1\", \"k2\", \"v2\")); // warning-map // warning-vararg warning(\"another warning message\", \"k3\", \"v3\", \"k4\", \"v4\"); // warning-vararg } } scenario warningLabel (WarningJavaTest) [warning] warning message [.] warningLabel (WarningJavaTest) scenario warningKeyValues (WarningJavaTest) [warning] warning message with map k1: \"v1\" k2: \"v2\" [warning] another warning message k3: \"v3\" k4: \"v4\""],["report@@warnings@@web-report","Report","Warnings","Web Report","Web Report displays warnings in Steps tab for a specific test, but also displays them at the summary page Groovy Java Summary of warnings will be displayed at the end of the run in the console and present on the generated HTML report summary view. Groovy There are 3 warning(s) in tests * warning message (warning.groovy -> warning label) * warning message with map (warning.groovy -> warning key values) k1: \"v1\" k2: \"v2\" * another warning message (warning.groovy -> warning key values) k3: \"v3\" k4: \"v4\" Total time: 2ms Total: 2, Passed: 2, Skipped: 0, Failed: 0, Errored: 0 report is generated: /home/runner/work/webtau/webtau/webtau-feature-testing/webtau-reports/scenarios/concept/warning-webtau-report.html Java There are 3 warning(s) in tests * warning message (WarningJavaTest -> warningLabel) * warning message with map (WarningJavaTest -> warningKeyValues) k1: \"v1\" k2: \"v2\" * another warning message (WarningJavaTest -> warningKeyValues) k3: \"v3\" k4: \"v4\" Total time: 2ms Total: 3, Passed: 3, Skipped: 0, Failed: 0, Errored: 0 report is generated: /home/runner/work/webtau/webtau/webtau-junit5-examples/webtau-reports/com.example.tests.junit5.WarningJavaTest.html"],["report@@configuration@@report-path","Report","Configuration","Report Path","Use to change path of a produced self-contained rich HTML report CLI webtau scenarios/*.groovy --reportPath my-report-name.html Maven <plugin> <groupId>org.testingisdocumenting.webtau</groupId> <artifactId>webtau-maven-plugin</artifactId> <version>2.3</version> <executions> <execution> <phase>test</phase> <goals> <goal>run</goal> </goals> </execution> </executions> <configuration> <workingDir>${project.basedir}/src/main/groovy</workingDir> <reportPath>my-report-name.html</reportPath> <tests> <directory>${project.basedir}/src/main/groovy</directory> <includes> <include>scenarios/*.groovy</include> </includes> </tests> </configuration> </plugin>"],["report@@configuration@@failed-report-path","Report","Configuration","Failed Report Path","Use to use different path for failed cases. CLI webtau scenarios/*.groovy --failedReportPath my-failed-report-name.html Maven <plugin> <groupId>org.testingisdocumenting.webtau</groupId> <artifactId>webtau-maven-plugin</artifactId> <version>2.3</version> <executions> <execution> <phase>test</phase> <goals> <goal>run</goal> </goals> </execution> </executions> <configuration> <workingDir>${project.basedir}/src/main/groovy</workingDir> <failedReportPath>my-failed-report-name.html</failedReportPath> <tests> <directory>${project.basedir}/src/main/groovy</directory> <includes> <include>scenarios/*.groovy</include> </includes> </tests> </configuration> </plugin> One of the use-cases is to configure CI upload only failed test reports, especially if you run multiple independent test suits yaml - name: Upload failed test reports uses: actions/upload-artifact@v2 if: failure() with: name: failed suits path: \"testing/src/test/groovy/*failed*.html\" retention-days: 2"],["report@@configuration@@report-name-and-url","Report","Configuration","Report Name And URL","Use and to change default report name.By default, when you click a report name, browser opens https://github.com/testingisdocumenting/webtau WebTau.Specify to override a page that opens when you click a report name. CLI webtau scenarios/*.groovy --reportName \"my service\" --reportNameUrl \"https://service-under-test\" Maven <plugin> <groupId>org.testingisdocumenting.webtau</groupId> <artifactId>webtau-maven-plugin</artifactId> <version>2.3</version> <executions> <execution> <phase>test</phase> <goals> <goal>run</goal> </goals> </execution> </executions> <configuration> <workingDir>${project.basedir}/src/main/groovy</workingDir> <reportName>my service</reportName> <reportNameUrl>https://service-under-test</reportNameUrl> <tests> <directory>${project.basedir}/src/main/groovy</directory> <includes> <include>scenarios/*.groovy</include> </includes> </tests> </configuration> </plugin>"],["report@@custom-reports@@registration","Report","Custom Reports","Registration","To generate custom reports or upload report data to your server, specify a reportGenerator config property. url = \"http://localhost:8080\" reportGenerator = Report.&generateReport Where Report.&generateReport is implemented as following package scenarios.rest.report import org.testingisdocumenting.webtau.console.ConsoleOutputs import org.testingisdocumenting.webtau.console.ansi.Color import org.testingisdocumenting.webtau.reporter.WebTauReport import static org.testingisdocumenting.webtau.WebTauDsl.cfg class Report { static void generateReport(WebTauReport report) { def reportPath = cfg.workingDir.resolve('report.txt') ConsoleOutputs.out('generating report: ', Color.PURPLE, reportPath) reportPath.toFile().text = report.tests.size() } }"],["report@@custom-reports@@graphql-example","Report","Custom Reports","GraphQL Example","Head over to GraphQL/report GraphQL to take a look at custom report to capture additional metrics"],["report@@import-and-dependencies@@core-only-import","Report","Import And Dependencies","Core Only Import","When you use multiple WebTau features you can single static import to have all core features available for autocomplete. It also requires a single dependency to bring all the WebTau modules. Groovy import static org.testingisdocumenting.webtau.WebTauGroovyDsl.* <dependency> <groupId>org.testingisdocumenting.webtau</groupId> <artifactId>webtau-groovy</artifactId> <version>2.3</version> </dependency> If you use groovy-standalone-runner/introduction Groovy Runner then all the dependencies are already present. Java import static org.testingisdocumenting.webtau.WebTauDsl.*; <dependency> <groupId>org.testingisdocumenting.webtau</groupId> <artifactId>webtau</artifactId> <version>2.3</version> </dependency> Alternatively, you can only import WebTauCore for methods like step , trace , warning : Groovy import static org.testingisdocumenting.webtau.WebTauCore.* <dependency> <groupId>org.testingisdocumenting.webtau</groupId> <artifactId>webtau-core-groovy</artifactId> <version>2.3</version> </dependency> Java import static org.testingisdocumenting.webtau.WebTauCore.*; <dependency> <groupId>org.testingisdocumenting.webtau</groupId> <artifactId>webtau-core</artifactId> <version>2.3</version> </dependency>"],["REPL@@experiments@@read-eval-print-loop","REPL","Experiments","Read Eval Print Loop","WebTau command line tool comes with a REPL mode that stands for 'read-eval-print-loop'. REPL is an established way to perform interactive execution of an API for the purpose of learning or experimenting. The REPL preserves the context of execution and each new command you run can rely on the established context."],["REPL@@experiments@@start-repl","REPL","Experiments","Start REPL","To run WebTau in REPL mode run webtau repl webtau:000> 2 + 2 ===> 4 webtau:000> a = 5 ===> 5 webtau:000> a + 3 ===> 8"],["REPL@@experiments@@experiment-with-api","REPL","Experiments","Experiment With API","Use the REPL to try out various apis like http. , browser. , db. , cli. , etc. webtau:000> http.get(\"https://jsonplaceholder.typicode.com/todos/1\") > executing HTTP GET https://jsonplaceholder.typicode.com/todos/1 . header.statusCode equals 200 (4ms) response (application/json; charset=utf-8): { \"userId\": 1, \"id\": 1, \"title\": \"delectus aut autem\", \"completed\": false } . executed HTTP GET https://jsonplaceholder.typicode.com/todos/1 (480ms)"],["REPL@@experiments@@setting-config-value","REPL","Experiments","Setting Config Value","Use cfg.url = \"http://url\" to set base url for experiments. webtau:000> cfg.url = \"https://jsonplaceholder.typicode.com\" > setting url source: \"manual\" url: \"https://jsonplaceholder.typicode.com\" . set url (0ms) \"https://jsonplaceholder.typicode.com\" webtau:000> http.get(\"/todos/1\") > executing HTTP GET https://jsonplaceholder.typicode.com/todos/1 . header.statusCode equals 200 (0ms) response (application/json; charset=utf-8): { \"userId\": 1, \"id\": 1, \"title\": \"delectus aut autem\", \"completed\": false } . executed HTTP GET https://jsonplaceholder.typicode.com/todos/1 (50ms)"],["REPL@@experiments@@preserving-browser-context","REPL","Experiments","Preserving Browser Context","During browser testing the REPL preserves the context of an opened browser, so you can experiment with css selectors and element actions without re-opening the browser and setting the right web app state. webtau:000> browser.open(\"file:///home/runner/work/webtau/webtau/webtau-cli-testing/src/test/groovy/data/basic.html\") > initializing webdriver for chrome . initialized webdriver for chrome (891ms) > opening file:///home/runner/work/webtau/webtau/webtau-cli-testing/src/test/groovy/data/basic.html . opened file:///home/runner/work/webtau/webtau/webtau-cli-testing/src/test/groovy/data/basic.html (44ms) Using element selectors provides additional information in REPL mode to help with exploration webtau:000> $(\"p\") found single element using by css p innerText: hello web page <p>hello web page</p>"],["REPL@@test-runs@@incremental-tests-development","REPL","Test Runs","Incremental Tests Development","You can combine experimentation in REPL with actual test development. Your feedback loop becomes even faster:Try API Add the line to test Re-run test with REPL Experiment within preserved context Enumerate test files you want to REPL with and add repl to get into incremental tests development mode webtau testscipts/* repl"],["REPL@@test-runs@@test-files-listing","REPL","Test Runs","Test Files Listing","Use ls command to list available test files. webtau:000> ls Test files: 0 testscripts/dataDownload.groovy 1 testscripts/downstreamValidation.groovy 2 testscripts/resourceCreation.groovy Note: Listing will happen automatically at the start"],["REPL@@test-runs@@test-file-selection","REPL","Test Runs","Test File Selection","webtau:000> s 0 Test scenarios of testscripts/dataDownload.groovy: 0 clean data 1 download data 2 validate data webtau:000> b Test files: 0 testscripts/dataDownload.groovy 1 testscripts/downstreamValidation.groovy 2 testscripts/resourceCreation.groovy webtau:000> s 'datadownload' Test scenarios of testscripts/dataDownload.groovy: 0 clean data 1 download data 2 validate data"],["REPL@@test-runs@@single-test-scenario-run","REPL","Test Runs","Single Test Scenario Run","Selected test file has three scenarios package testscripts import static org.testingisdocumenting.webtau.WebTauGroovyDsl.scenario scenario(\"clean data\") { println \"cleaning...\" } scenario(\"download data\") { println \"downloading...\" } scenario(\"validate data\") { println \"validating...\" } To run scenario by index webtau:000> r 0 scenario before first test (Setup) [.] before first test (Setup) running: testscripts/dataDownload.groovy clean data scenario clean data (dataDownload.groovy) cleaning... [.] clean data (dataDownload.groovy) Use negative index to select from the bottom, i.e. -1 will select the last scenario, -2 will select second from the end webtau:000> r -1 running: testscripts/dataDownload.groovy validate data scenario validate data (dataDownload.groovy) validating... [.] validate data (dataDownload.groovy) To run scenario by partial name match webtau:000> r 'clean' running: testscripts/dataDownload.groovy clean data scenario clean data (dataDownload.groovy) cleaning... [.] clean data (dataDownload.groovy)"],["REPL@@test-runs@@re-run-last-run","REPL","Test Runs","Re-run Last Run","Use r to re-run previous run webtau:000> r running: testscripts/dataDownload.groovy clean data scenario clean data (dataDownload.groovy) cleaning... [.] clean data (dataDownload.groovy)"],["REPL@@test-runs@@multiple-test-scenarios-run","REPL","Test Runs","Multiple Test Scenarios Run","Use comma separated list of indexes or partial text match to run more than one scenario webtau:000> r 0, 1 running: testscripts/dataDownload.groovy clean data scenario clean data (dataDownload.groovy) cleaning... [.] clean data (dataDownload.groovy) running: testscripts/dataDownload.groovy download data scenario download data (dataDownload.groovy) downloading... [.] download data (dataDownload.groovy) webtau:000> r 'download', 'clean' running: testscripts/dataDownload.groovy download data scenario download data (dataDownload.groovy) downloading... [.] download data (dataDownload.groovy) running: testscripts/dataDownload.groovy clean data scenario clean data (dataDownload.groovy) cleaning... [.] clean data (dataDownload.groovy) Note: Order of execution follows the order of specified indexes or textUse r from:to to run a range of scenarios. From , to can be either index or partial text match. webtau:000> r 0:'validate' running: testscripts/dataDownload.groovy clean data scenario clean data (dataDownload.groovy) cleaning... [.] clean data (dataDownload.groovy) running: testscripts/dataDownload.groovy download data scenario download data (dataDownload.groovy) downloading... [.] download data (dataDownload.groovy) running: testscripts/dataDownload.groovy validate data scenario validate data (dataDownload.groovy) validating... [.] validate data (dataDownload.groovy) webtau:000> r 'validate':0 running: testscripts/dataDownload.groovy validate data scenario validate data (dataDownload.groovy) validating... [.] validate data (dataDownload.groovy) running: testscripts/dataDownload.groovy download data scenario download data (dataDownload.groovy) downloading... [.] download data (dataDownload.groovy) running: testscripts/dataDownload.groovy clean data scenario clean data (dataDownload.groovy) cleaning... [.] clean data (dataDownload.groovy)"],["REPL@@test-runs@@select-scenarios-without-run","REPL","Test Runs","Select Scenarios Without Run","package testscripts import static org.testingisdocumenting.webtau.WebTauGroovyDsl.scenario scenario(\"clean data\") { println \"cleaning...\" } scenario(\"download data\") { println \"downloading...\" } scenario(\"validate data\") { println \"validating...\" } Lets run scenarios by ranage again webtau:000> r 'validate':0 running: testscripts/dataDownload.groovy validate data scenario validate data (dataDownload.groovy) validating... [.] validate data (dataDownload.groovy) running: testscripts/dataDownload.groovy download data scenario download data (dataDownload.groovy) downloading... [.] download data (dataDownload.groovy) running: testscripts/dataDownload.groovy clean data scenario clean data (dataDownload.groovy) cleaning... [.] clean data (dataDownload.groovy) Use s to display last ran or selected scenarios. These scenarios will be ran with r webtau:000> s Selected scenarios: validate data download data clean data webtau:000> s 0,2 Selected scenarios: clean data validate data"],["utilities@@introduction@@","Utilities","Introduction","","WebTau has several modules to help you simplify automation processes. All operations in the modules provide detailed information on steps executed and details are included in web report as well as console output. utilities/cache cache - module to cache results of test steps to be able to skip them during test development and exploration"],["utilities@@cache@@cached-value","Utilities","Cache","Cached Value","When you develop tests, you don't have to restart the whole flow from the beginning.Imagine you have a multistep test that includes running Command Line tool and then validating REST API response, and then opening a browser to assert UI values.Cache long steps results like created entities ids to speed up tests development.In the example below, you create first scenario that runs a heavy command line tool that generates an id. We then cache the value and you can write a second scenario and keep re-running it, without the need to re-run the first one. import static org.testingisdocumenting.webtau.WebTauGroovyDsl.* def createdId = cache.value(\"cli-heavy-created-id\") // declare cached value with distinct id scenario(\"heavy setup operation\") { def cliResult = cli.run(\"scripts/cli-heavy-process\") // long running process that you don't want to re-run as you write your tests createdId.set(cliResult.extractFromOutputByRegexp(\"id=(\\\\S+)\")) // caching the extracted id from CLI run } scenario(\"using previous setup id even after restart\") { def id = createdId.get() // using cached value from previous test run. value will be preserved between restarts and re-compile http.get(\"/resource/${id}\") { message.should == \"hello\" } } Note: Use groovy-standalone-runner/selective-run Selective Run or REPL/test-runs REPL mode to run one scenario at a time."],["utilities@@cache@@cached-value-with-expiration","Utilities","Cache","Cached Value With Expiration","Use get value with expiration time for scenarios like auth token def token = cache.get(authTokenKey, 60_000, () -> generateAuthToken())"],["utilities@@cache@@fs-path-type","Utilities","Cache","FS Path type","file-system/introduction File System module return values of type Path . WebTau stores them as String . To retrieve as Path use import static org.testingisdocumenting.webtau.WebTauGroovyDsl.* def deployDirCache = cache.value(\"deploy-dir\") scenario(\"caching of path value\") { def path = fs.tempDir(\"my-dir\") deployDirCache.set(path) } scenario(\"accessing path value\") { def deployDir = deployDirCache.getAsPath() fs.writeText(deployDir.resolve(\"file.txt\"), \"hello\") }"],["utilities@@cache@@presence-check","Utilities","Cache","Presence Check","Use inside utilities methods to check if a cache value was set. def prevGenerated = cache.value(\"zip-unpacked-path\") // ... if (!prevGenerated.exists()) { // recreate content } Avoid: using cache check inside test methods to keep them clean"],["matchers@@introduction@@should","Matchers","Introduction","Should","WebTau provides two ways to assert values: should and waitTo . They work for business logic testing, HTTP, Browser, and other layers. Methods accept a matcher as a second parameter: WebTau provides console output for all the matching it does, regardless of whether it fails or passes. Use should to assert a value using a matcher. One of the most common matchers is equal . In WebTau equal is a universal matcher that you will learn about matchers/universal-compare later. Groovy def errorMessage = generateErrorMessage() errorMessage.should == \"insufficient disk space\" // string and string equality comparison . [value] equals \"insufficient disk space\" (0ms) Note: Groovy has a shortcut for equal matcher. Check matchers/import-and-dependencies Import And Dependencies for prerequisites. Java String errorMessage = generateErrorMessage(); actual(errorMessage).should(equal(\"insufficient disk space\")); // string and string equality comparison . [value] equals \"insufficient disk space\" (0ms) Check matchers/import-and-dependencies Import And Dependencies for prerequisites. Use shouldBe alias to make a better flow with matchers like greaterThan : Groovy def numberAsText = \"200\" numberAsText.shouldBe > 150 // text and number relative comparison . [value] greater than 150 (2ms) Java String numberAsText = \"200\"; actual(numberAsText).shouldBe(greaterThan(150)); // text and number relative comparison . [value] greater than 150 (2ms)"],["matchers@@introduction@@waitto","Matchers","Introduction","WaitTo","Use waitTo to wait for a value to eventually match a matcher. Groovy actual(liveValue(this::consumeMessage)).waitTo == \"message we wait for\" > waiting for [value] to equal \"message we wait for\" . [value] equals \"message we wait for\" (201ms) Java actual(liveValue(this::consumeMessage)).waitTo(equal(\"message we wait for\")); > waiting for [value] to equal \"message we wait for\" . [value] equals \"message we wait for\" (201ms) Use waitToBe alias to make a better flow with matchers like greaterThan : Groovy actual(liveValue(this::countRecords)).waitToBe >= 5 > waiting for [value] to be greater than or equal to 5 . [value] greater than or equal 5 (401ms) Java actual(liveValue(this::countRecords)).waitToBe(greaterThanOrEqual(5)); > waiting for [value] to be greater than or equal to 5 . [value] greater than or equal 5 (401ms)"],["matchers@@introduction@@negative-matching","Matchers","Introduction","Negative Matching","Both should and waitTo have negative forms: Groovy def errorMessage = generateErrorMessage() errorMessage.shouldNot == \"completed\" . [value] doesn't equal \"completed\" (0ms) Java String errorMessage = generateErrorMessage(); actual(errorMessage).shouldNot(equal(\"completed\")); . [value] doesn't equal \"completed\" (0ms) Groovy actual(liveValue(this::consumeMessage)).waitToNot == \"duplicate\" > waiting for [value] to not equal \"duplicate\" . [value] doesn't equal \"duplicate\" (1ms) Java actual(liveValue(this::consumeMessage)).waitToNot(equal(\"duplicate\")); > waiting for [value] to not equal \"duplicate\" . [value] doesn't equal \"duplicate\" (1ms)"],["matchers@@introduction@@failure-output","Matchers","Introduction","Failure Output","Above you saw how WebTau outputs matched information. In case of failed assertion WebTau outputs additional information about the actual value. Groovy values.should == [ 1, \"teasing\", [key1: \"hello\", key2: \"work\"]] X failed expecting [value] to equal [1, \"teasing\", {\"key1\": \"hello\", \"key2\": \"work\"}]: [value][1]: actual: \"testing\" <java.lang.String> expected: \"teasing\" <java.lang.String> ^ [value][2].key2: actual: \"world\" <java.lang.String> expected: \"work\" <java.lang.String> ^ (1ms) [1, **\"testing\"**, {\"key1\": \"hello\", \"key2\": **\"world\"**}] Java actual(values).should(equal(Arrays.asList( 1, \"teasing\", map(\"key1\", \"hello\", \"key2\", \"work\")))); X failed expecting [value] to equal [1, \"teasing\", {\"key1\": \"hello\", \"key2\": \"work\"}]: [value][1]: actual: \"testing\" <java.lang.String> expected: \"teasing\" <java.lang.String> ^ [value][2].key2: actual: \"world\" <java.lang.String> expected: \"work\" <java.lang.String> ^ (1ms) [1, **\"testing\"**, {\"key1\": \"hello\", \"key2\": **\"world\"**}]"],["matchers@@universal-compare@@cross-types-comparison","Matchers","Universal Compare","Cross Types Comparison","In WebTau you can compare strings, dates, arrays, strings and numbers, dates and strings, arrays and sets and other numerous combinations using the same set of matchers. Groovy def errorMessage = generateErrorMessage() errorMessage.should == \"insufficient disk space\" // string and string equality comparison def numberAsText = \"200\" numberAsText.shouldBe > 150 // text and number relative comparison Check matchers/import-and-dependencies Import And Dependencies for prerequisites. Java String errorMessage = generateErrorMessage(); actual(errorMessage).should(equal(\"insufficient disk space\")); // string and string equality comparison String numberAsText = \"200\"; actual(numberAsText).shouldBe(greaterThan(150)); // text and number relative comparison Check matchers/import-and-dependencies Import And Dependencies for prerequisites."],["matchers@@universal-compare@@reporting","Matchers","Universal Compare","Reporting","Every comparison failed and successful generates console output with comparison details. . [value] equals \"insufficient disk space\" (0ms) Values have predefined names when they come from HTTP response or Web UI, etc. But regular values default to value .Pass name as a second parameter to actual to set an explicit reporting name. Groovy double price = calculatePrice() actual(price, \"price\").shouldBe > 10 // explict name to use in reporting Java double price = calculatePrice(); actual(price, \"price\").shouldBe(greaterThan(10)); // explict name to use in reporting . price greater than 10 (12ms)"],["matchers@@universal-compare@@dates","Matchers","Universal Compare","Dates","Universal compare lets you compare dates, local dates, strings, and times with timezones against each other. Groovy def dateAsText = \"2018-06-10\" dateAsText.shouldBe > LocalDate.of(2018, 6, 9) def timeAsText = \"2018-01-02T00:00:00Z\" timeAsText.shouldBe > LocalDate.of(2018, 1, 1) // date/time will be converted to local timezone def withTime = LocalDateTime.of(2022, 3, 16, 10, 4, 4) def dateOnly = LocalDate.of(2022, 3, 16) withTime.should == dateOnly // comparison ignores time portion when not provided Java String dateAsText = \"2018-06-10\"; actual(dateAsText).shouldBe(greaterThan(LocalDate.of(2018, 6, 9))); String timeAsText = \"2018-01-02T00:00:00Z\"; actual(timeAsText).shouldBe(greaterThan(LocalDate.of(2018, 1, 1))); // date/time will be converted to local timezone LocalDateTime withTime = LocalDateTime.of(2022, 3, 16, 10, 4, 4); LocalDate withDate = LocalDate.of(2022, 3, 16); actual(withTime).should(equal(withDate)); // comparison ignores time portion when not provided"],["matchers@@java-beans-and-records@@java-bean-equals-map","Matchers","Java Beans And Records","Java Bean Equals Map","WebTau provides matchers/universal-compare universal comparison handlers to streamline Java Beans and Java Records assertions.Use map and bean comparison to validate individual java bean properties. Groovy def account = new Account(\"ac1\", \"My Account\", \"test account\", new Address(\"TestingCity\", \"88888888\")) account.should == [ id: \"ac1\", name: \"My Second Account\", address: [zipCode: \"7777777\"]] // only specified properties will be compared Check matchers/import-and-dependencies Import And Dependencies for prerequisites. Java Address address = new Address(\"TestingCity\", \"88888888\"); Account account = new Account(\"ac1\", \"My Account\", \"test account\", address); actual(account).should(equal(map( // utility function from WebTauCore static import \"id\", \"ac1\", \"name\", \"My Second Account\", \"address\", map(\"zipCode\", \"7777777\")))); // only specified properties will be compared Check matchers/import-and-dependencies Import And Dependencies for prerequisites. public class Account { private final String id; private final String name; private final String description; private final Address address; public Account(String id, String name, String description, Address address) { this.id = id; this.name = name; this.description = description; this.address = address; } public String getId() { return id; } public String getName() { return name; } public String getDescription() { return description; } public Address getAddress() { return address; } } public class Address { private final String city; private final String zipCode; public Address(String city, String zipCode) { this.city = city; this.zipCode = zipCode; } public String getCity() { return city; } public String getZipCode() { return zipCode; } } X failed expecting [value] to equal {\"id\": \"ac1\", \"name\": \"My Second Account\", \"address\": {\"zipCode\": \"7777777\"}}: [value].name: actual: \"My Account\" <java.lang.String> expected: \"My Second Account\" <java.lang.String> ^ [value].address.zipCode: actual: \"88888888\" <java.lang.String> expected: \"7777777\" <java.lang.String> ^ (4ms) { \"address\": {\"city\": \"TestingCity\", \"zipCode\": **\"88888888\"**}, \"description\": \"test account\", \"id\": \"ac1\", \"name\": **\"My Account\"** }"],["matchers@@java-beans-and-records@@java-beans-contain-map","Matchers","Java Beans And Records","Java Beans Contain Map","Use contain(map) to check if a collection of beans contains a bean with specified properties: Groovy def accounts = fetchAccounts() accounts.shouldNot contain([id: \"ac2\", name: \"Work\"]) // only check specified properties Java List<Account> accounts = fetchAccounts(); actual(accounts).shouldNot(contain(map(\"id\", \"ac2\", \"name\", \"Work\"))); // only check specified properties public class Account { private final String id; private final String name; private final String description; private final Address address; public Account(String id, String name, String description, Address address) { this.id = id; this.name = name; this.description = description; this.address = address; } public String getId() { return id; } public String getName() { return name; } public String getDescription() { return description; } public Address getAddress() { return address; } } X failed expecting [value] to not contain {\"id\": \"ac2\", \"name\": \"Work\"}: [value][1].id: actual: \"ac2\" <java.lang.String> expected: not \"ac2\" <java.lang.String> [value][1].name: actual: \"Work\" <java.lang.String> expected: not \"Work\" <java.lang.String> (4ms) [ { \"address\": org.testingisdocumenting.webtau.Address@49ef32e0, \"description\": \"test account\", \"id\": \"ac1\", \"name\": \"Home\" }, { \"address\": org.testingisdocumenting.webtau.Address@271f18d3, \"description\": \"test account\", \"id\": **\"ac2\"**, \"name\": **\"Work\"** }, { \"address\": org.testingisdocumenting.webtau.Address@6bd51ed8, \"description\": \"test account\", \"id\": \"ac3\", \"name\": \"My Account\" } ]"],["matchers@@java-beans-and-records@@java-beans-equal-table-data","Matchers","Java Beans And Records","Java Beans Equal Table Data","Use equal with TableData to compare with a collection of java beans. All records must be present. Groovy List<Account> accounts = fetchAccounts() TableData expected = [\"*id\" | \"name\" | \"address\"] { // id is a key column _________________________________________ \"ac2\" | \"Works\" | [zipCode: \"zip2\"] // when key is present, comparison is order agnostic \"ac1\" | \"Home\" | [zipCode: \"zip1\"] \"ac3\" | \"My Account\" | [zipCode: \"zip8\"] } accounts.should == expected Java List<Account> accounts = fetchAccounts(); TableData expected = table(\"*id\", \"name\", \"address\", // id is a key column ________________________________________, \"ac2\", \"Works\", map(\"zipCode\", \"zip2\"), // when key is present, comparison is order agnostic \"ac1\", \"Home\", map(\"zipCode\", \"zip1\"), \"ac3\", \"My Account\", map(\"zipCode\", \"zip8\")); actual(accounts).should(equal(expected)); Note: Only specified properties will be matched X failed expecting [value] to equal *id │ name │ address \"ac2\" │ \"Works\" │ {\"zipCode\": \"zip2\"} \"ac1\" │ \"Home\" │ {\"zipCode\": \"zip1\"} \"ac3\" │ \"My Account\" │ {\"zipCode\": \"zip8\"}: [value][2].address.zipCode: actual: \"zip3\" <java.lang.String> expected: \"zip8\" <java.lang.String> ^ [value][1].name: actual: \"Work\" <java.lang.String> expected: \"Works\" <java.lang.String> ^ (2ms) address │ description │ id │ name {\"city\": \"TC1\", \"zipCode\": \"zip1\"} │ \"test account\" │ \"ac1\" │ \"Home\" {\"city\": \"TC2\", \"zipCode\": \"zip2\"} │ \"test account\" │ \"ac2\" │ **\"Work\"** {\"city\": \"TC3\", \"zipCode\": **\"zip3\"**} │ \"test account\" │ \"ac3\" │ \"My Account\""],["matchers@@java-beans-and-records@@java-beans-contain-table-data","Matchers","Java Beans And Records","Java Beans Contain Table Data","Use contain with TableData to partially compare list of java beans. Groovy List<Account> accounts = fetchAccounts() TableData expected = [\"*id\" | \"name\" | \"address\"] { ____________________________________ \"ac2\" | \"Works\" | [zipCode: \"zip2\"] \"ac1\" | \"Home\" | [zipCode: \"zip1\"] } accounts.should contain(expected) X failed expecting accounts to contain id │ name │ address \"ac2\" │ \"Works\" │ {\"zipCode\": \"zip2\"} \"ac1\" │ \"Home\" │ {\"zipCode\": \"zip1\"}: no matches found for: [{\"id\": \"ac2\", \"name\": \"Works\", \"address\": {\"zipCode\": \"zip2\"}}] accounts[1].name: actual: \"Work\" <java.lang.String> expected: \"Works\" <java.lang.String> ^ (8ms) [ { \"address\": {\"city\": \"TC1\", \"zipCode\": \"zip1\"}, \"description\": \"test account\", \"id\": \"ac1\", \"name\": \"Home\" }, { \"address\": {\"city\": \"TC2\", \"zipCode\": \"zip2\"}, \"description\": \"test account\", \"id\": \"ac2\", \"name\": **\"Work\"** }, { \"address\": {\"city\": \"TC3\", \"zipCode\": \"zip3\"}, \"description\": \"test account\", \"id\": \"ac3\", \"name\": \"My Account\" } ] Java List<Account> accounts = fetchAccounts(); TableData expected = table(\"id\", \"name\", \"address\", _______________________________________, \"ac2\", \"Works\", map(\"zipCode\", \"zip2\"), \"ac1\", \"Home\", map(\"zipCode\", \"zip1\")); actual(accounts, \"accounts\").should(contain(expected)); X failed expecting accounts to contain id │ name │ address \"ac2\" │ \"Works\" │ {\"zipCode\": \"zip2\"} \"ac1\" │ \"Home\" │ {\"zipCode\": \"zip1\"}: no matches found for: [{\"id\": \"ac2\", \"name\": \"Works\", \"address\": {\"zipCode\": \"zip2\"}}] accounts[1].name: actual: \"Work\" <java.lang.String> expected: \"Works\" <java.lang.String> ^ (8ms) [ { \"address\": {\"city\": \"TC1\", \"zipCode\": \"zip1\"}, \"description\": \"test account\", \"id\": \"ac1\", \"name\": \"Home\" }, { \"address\": {\"city\": \"TC2\", \"zipCode\": \"zip2\"}, \"description\": \"test account\", \"id\": \"ac2\", \"name\": **\"Work\"** }, { \"address\": {\"city\": \"TC3\", \"zipCode\": \"zip3\"}, \"description\": \"test account\", \"id\": \"ac3\", \"name\": \"My Account\" } ]"],["matchers@@java-beans-and-records@@java-records","Matchers","Java Beans And Records","Java Records","WebTau compares Java Records with maps and tables in the same way as Java Beans. public record WishLitItem(String id, String description, boolean favorite, List<WishLitItem> related) { } Groovy def wishListItem = new WishLitItem(\"id1\", \"tea set\", true, [new WishLitItem(\"id-nested\", \"tea\", true, [])]) wishListItem.should == [ id: \"id1\", description: \"tea sets\", favorite: true, related: [ [id: \"id-nested\", description: \"juice\"]]] // only specified properties will be compared Java var wishListItem = new WishLitItem(\"id1\", \"tea set\", true, list(new WishLitItem(\"id-nested\", \"tea\", true, list()))); actual(wishListItem).should(equal(map( \"id\", \"id1\", \"description\", \"tea sets\", \"favorite\", true, \"related\", list(map( \"id\", \"id-nested\", \"description\", \"juice\"))))); // only specified properties will be compared X failed expecting [value] to equal { \"id\": \"id1\", \"description\": \"tea sets\", \"favorite\": true, \"related\": [{\"id\": \"id-nested\", \"description\": \"juice\"}] }: [value].description: actual: \"tea set\" <java.lang.String> expected: \"tea sets\" <java.lang.String> ^ [value].related[0].description: actual: \"tea\" <java.lang.String> expected: \"juice\" <java.lang.String> ^ (1ms) { \"id\": \"id1\", \"description\": **\"tea set\"**, \"favorite\": true, \"related\": [{\"id\": \"id-nested\", \"description\": **\"tea\"**, \"favorite\": true, \"related\": []}] }"],["matchers@@strings@@mismatch-pinpoint-single-line-text","Matchers","Strings","Mismatch Pinpoint Single Line Text","When comparing strings, WebTau highlights a specific point of failure: Groovy def output = \"hallo world\" output.should == \"hello world\" X failed expecting [value] to equal \"hello world\": actual: \"hallo world\" <java.lang.String> expected: \"hello world\" <java.lang.String> ^ (0ms) Check matchers/import-and-dependencies Import And Dependencies for prerequisites. Java String output = \"hallo world\"; actual(output).should(equal(\"hello world\")); X failed expecting [value] to equal \"hello world\": actual: \"hallo world\" <java.lang.String> expected: \"hello world\" <java.lang.String> ^ (0ms) Check matchers/import-and-dependencies Import And Dependencies for prerequisites."],["matchers@@strings@@mismatch-pinpoint-multi-line-text","Matchers","Strings","Mismatch Pinpoint Multi Line Text","In case of a multiline text, WebTau highlights a first mismatched line: Groovy String output = buildOutput() output.should == \"line one\\nline 2\" X failed expecting [value] to equal ________ line one line 2 ________: different number of lines: actual: 3 expected: 2 first mismatch at line idx 1: actual: \"line two\" expected: \"line 2\" ^ (1ms) __________ line one **line two** line three __________ Java String output = buildOutput(); actual(output).should(equal(\"line one\\nline 2\")); X failed expecting [value] to equal ________ line one line 2 ________: different number of lines: actual: 3 expected: 2 first mismatch at line idx 1: actual: \"line two\" expected: \"line 2\" ^ (1ms) __________ line one **line two** line three __________"],["matchers@@strings@@line-ending-detection","Matchers","Strings","Line Ending Detection","WebTau automatically checks line ending, e.g. presence of \\r and will notify if there is a difference. X failed expecting text to equal _________________ hello world world hello again _________________: different line endings: actual: contains \\r expected: doesn't contain \\r (1ms) **_________________** hello world world hello again **_________________**"],["matchers@@strings@@different-number-of-empty-lines","Matchers","Strings","Different Number Of Empty Lines","WebTau separately checks extra empty lines to help with missing/extra \\n : Groovy String output = buildOutput() output.should == \"line one\\nline two\\nline three\\n\" X failed expecting [value] to equal __________ line one line two line three __________: different number of lines: actual: 3 expected: 4 different number of empty lines at the end actual: 0 expected: 1 (0ms) **__________** line one line two line three **__________** Java String output = buildOutput(); actual(output).should(equal(\"line one\\nline two\\nline three\\n\")); X failed expecting [value] to equal __________ line one line two line three __________: different number of lines: actual: 3 expected: 4 different number of empty lines at the end actual: 0 expected: 1 (0ms) **__________** line one line two line three **__________**"],["matchers@@strings@@contains","Matchers","Strings","Contains","Use contains matcher to check a presence of a substring: Groovy String output = buildOutput() output.should contain(\"four\") X failed expecting [value] to contain \"four\": no match found (0ms) **__________** line one line two line three **__________** Java String output = buildOutput(); actual(output).should(contain(\"four\")); X failed expecting [value] to contain \"four\": no match found (0ms) **__________** line one line two line three **__________**"],["matchers@@strings@@regexp","Matchers","Strings","Regexp","Use equal matcher to match against a regular expression: Groovy String output = 'final price: $8998' output.should == ~/final price: \\$\\d+/ . [value] equals ~/final price: \\$\\d+/ (0ms) Java String output = \"final price: $8998\"; actual(output).should(equal(Pattern.compile(\"final price: \\\\$\\\\d+\"))); . [value] equals ~/final price: \\$\\d+/ (0ms)"],["matchers@@maps@@equality-comparison","Matchers","Maps","Equality Comparison","When two maps are not equal, WebTau generates all the required info to investigate: Groovy Map<String, ?> generated = generate() generated.should == [firstName: \"G-FN\", lastName: \"G-LN\", address: [street: \"generated-street\", city: \"GenCity\", zipCode: \"12345\"]] X failed expecting [value] to equal { \"firstName\": \"G-FN\", \"lastName\": \"G-LN\", \"address\": {\"street\": \"generated-street\", \"city\": \"GenCity\", \"zipCode\": \"12345\"} }: mismatches: [value].address.city: actual: \"GenSity\" <java.lang.String> expected: \"GenCity\" <java.lang.String> ^ missing, but expected values: [value].address.zipCode: \"12345\" (1ms) { \"firstName\": \"G-FN\", \"lastName\": \"G-LN\", \"address\": {\"street\": \"generated-street\", \"city\": **\"GenSity\"**, \"zipCode\": **<missing>**} } Check matchers/import-and-dependencies Import And Dependencies for prerequisites. Java Map<String, ?> generated = generate(); actual(generated).should(equal(map(\"firstName\", \"G-FN\", \"lastName\", \"G-LN\", \"address\", map(\"street\", \"generated-street\", \"city\", \"GenCity\", \"zipCode\", \"12345\")))); X failed expecting [value] to equal { \"firstName\": \"G-FN\", \"lastName\": \"G-LN\", \"address\": {\"street\": \"generated-street\", \"city\": \"GenCity\", \"zipCode\": \"12345\"} }: mismatches: [value].address.city: actual: \"GenSity\" <java.lang.String> expected: \"GenCity\" <java.lang.String> ^ missing, but expected values: [value].address.zipCode: \"12345\" (1ms) { \"firstName\": \"G-FN\", \"lastName\": \"G-LN\", \"address\": {\"street\": \"generated-street\", \"city\": **\"GenSity\"**, \"zipCode\": **<missing>**} } Check matchers/import-and-dependencies Import And Dependencies for prerequisites."],["matchers@@maps@@contain","Matchers","Maps","Contain","Use contain matcher to check if one map is a subset of another: Groovy Map<String, ?> generated = generate() generated.should contain(firstName: \"G-FN\", lastName: \"G-LN\", middleName: \"G-MN\") X failed expecting [value] to contain {\"firstName\": \"G-FN\", \"lastName\": \"G-LN\", \"middleName\": \"G-MD\"}: missing values: [value].middleName: \"G-MD\" (1ms) { \"firstName\": \"G-FN\", \"lastName\": \"G-LN\", \"address\": {\"street\": \"generated-street\", \"city\": \"GenSity\"}, \"middleName\": **<missing>** } Java Map<String, ?> generated = generate(); actual(generated).should(contain( map(\"firstName\", \"G-FN\", \"lastName\", \"G-LN\", \"middleName\", \"G-MD\"))); X failed expecting [value] to contain {\"firstName\": \"G-FN\", \"lastName\": \"G-LN\", \"middleName\": \"G-MD\"}: missing values: [value].middleName: \"G-MD\" (1ms) { \"firstName\": \"G-FN\", \"lastName\": \"G-LN\", \"address\": {\"street\": \"generated-street\", \"city\": \"GenSity\"}, \"middleName\": **<missing>** }"],["matchers@@tables@@equality-comparison","Matchers","Tables","Equality Comparison","When two tables are not equal, WebTau generates all the required info to investigate: Groovy def summary = loadFromCsv(\"summary.csv\") def expected = [ \"ColumnA\" | \"ColumnB\" ] { ____________________________ 10 | greaterThan(15) anyOf(20, 22) | 40 } summary.should == expected X failed expecting [value] to equal ColumnA │ ColumnB 10 │ <greater than 15> <any of [20, 22]> │ 40: [value][1].ColumnA: actual: 30 <java.lang.Integer> expected: 20 <java.lang.Integer> actual: 30 <java.lang.Integer> expected: 22 <java.lang.Integer> (0ms) ColumnA │ ColumnB 10 │ 20 **30** │ 40 Check matchers/import-and-dependencies Import And Dependencies for prerequisites. Java var summary = loadFromCsv(\"summary.csv\"); TableData expected = table(\"ColumnA\", \"ColumnB\", _________________________, 10, greaterThan(15), anyOf(20, 22), 40); actual(summary).should(equal(expected)); X failed expecting [value] to equal ColumnA │ ColumnB 10 │ <greater than 15> <any of [20, 22]> │ 40: [value][1].ColumnA: actual: 30 <java.lang.Integer> expected: 20 <java.lang.Integer> actual: 30 <java.lang.Integer> expected: 22 <java.lang.Integer> (0ms) ColumnA │ ColumnB 10 │ 20 **30** │ 40 Check matchers/import-and-dependencies Import And Dependencies for prerequisites."],["matchers@@tables@@contain","Matchers","Tables","Contain","Use contain matcher to check if one map is a subset of another: Groovy def summary = loadFromCsv(\"summary.csv\") summary.should contain([\"ColumnA\": 20, \"ColumnB\": greaterThan(15)]) X failed expecting [value] to contain {\"ColumnA\": 20, \"ColumnB\": <greater than 15>}: no match found (1ms) ColumnA │ ColumnB 10 │ 20 30 │ 40 Java var summary = loadFromCsv(\"summary.csv\"); actual(summary).should(contain(map(\"ColumnA\", 20, \"ColumnB\", greaterThan(15)))); X failed expecting [value] to contain {\"ColumnA\": 20, \"ColumnB\": <greater than 15>}: no match found (1ms) ColumnA │ ColumnB 10 │ 20 30 │ 40"],["matchers@@any-of@@match-any-provided-value","Matchers","Any Of","Match Any Provided Value","Use anyOf matcher to match an expected value against any of the provided values. matchers/universal-compare Universal Compare rule is applicable. Groovy def dateAsText = \"2018-06-10\" dateAsText.should == anyOf(\"2018-06-11\", LocalDate.of(2018, 6, 10)) Check matchers/import-and-dependencies Import And Dependencies for prerequisites. Java String dateAsText = \"2018-06-10\"; actual(dateAsText).shouldBe(anyOf(\"2018-06-11\", LocalDate.of(2018, 6, 10))); Check matchers/import-and-dependencies Import And Dependencies for prerequisites."],["matchers@@any-of@@mixing-values-and-matchers","Matchers","Any Of","Mixing Values And Matchers","You can mix values and other matchers passed to anyOf Groovy def dateAsText = \"2018-06-10\" dateAsText.should == anyOf(\"2018-06-11\", greaterThan(LocalDate.of(2018, 1, 1))) def message = \"hello world\" message.shouldNot == anyOf(\"hello\", contain(\"super\")) Java String dateAsText = \"2018-06-10\"; actual(dateAsText).shouldBe(anyOf(\"2018-06-11\", greaterThan(LocalDate.of(2018, 1, 1)))); String message = \"hello world\"; actual(message).shouldNotBe(anyOf(\"hello\", contain(\"super\")));"],["matchers@@contain-exactly@@","Matchers","Contain Exactly","","Use to match two collections of elements in any order. Groovy def list = [ new Person(\"id1\", 3, 12), new Person(\"id1\", 4, 10), new Person(\"id2\", 4, 20) ] actual(list).should(containExactly( [id: \"id2\", level: 4, monthsAtCompany: 20], [id: \"id1\", level: 8, monthsAtCompany: 10], [id: \"id1\", level: 7, monthsAtCompany: 12])) Check matchers/import-and-dependencies Import And Dependencies for prerequisites. Java List<?> list = list( new Person(\"id1\", 3, 12), new Person(\"id1\", 4, 10), new Person(\"id2\", 4, 20)); actual(list).should(containExactly( map(\"id\", \"id2\", \"level\", 4, \"monthsAtCompany\", 20), map(\"id\", \"id1\", \"level\", 8, \"monthsAtCompany\", 10), map(\"id\", \"id1\", \"level\", 7, \"monthsAtCompany\", 12))); Check matchers/import-and-dependencies Import And Dependencies for prerequisites. Console output displays potential mismatches to help with investigation: X failed expecting [value] to contain exactly [ {\"id\": \"id2\", \"level\": 4, \"monthsAtCompany\": 20}, {\"id\": \"id1\", \"level\": 8, \"monthsAtCompany\": 10}, {\"id\": \"id1\", \"level\": 7, \"monthsAtCompany\": 12} ]: no matches found for: [{\"id\": \"id1\", \"level\": 8, \"monthsAtCompany\": 10}, {\"id\": \"id1\", \"level\": 7, \"monthsAtCompany\": 12}] possible mismatches: [value][1].level: actual: 4 <java.lang.Integer> expected: 8 <java.lang.Integer> [value][0].level: actual: 3 <java.lang.Integer> expected: 7 <java.lang.Integer> (3ms) [ {\"id\": \"id1\", \"level\": **3**, \"monthsAtCompany\": 12}, {\"id\": \"id1\", \"level\": **4**, \"monthsAtCompany\": 10}, {\"id\": \"id2\", \"level\": 4, \"monthsAtCompany\": 20} ] Note: If you have a clear key column(s) defined, consider using TableData as matchers/java-beans-and-records#java-beans-equal-table-data expected values"],["matchers@@any-value@@match-every-value","Matchers","Any Value","Match Every Value","Use anyValue matcher to match every expected value. Use it in places of complex data expectations where you need to provide a value but your focus is on different data. Groovy TableData summaryTable = loadFromCsv(\"summary.csv\") summaryTable.should == [\"ColumnA\" | \"ColumnB\" ] { _________________________ 10| anyValue 30| 40 } . [value] equals ColumnA │ ColumnB 10 │ <any value> 30 │ 40 (1ms) Check matchers/import-and-dependencies Import And Dependencies for prerequisites. Java TableData summaryTable = loadFromCsv(\"summary.csv\"); actual(summaryTable).should(equal(table(\"ColumnA\", \"ColumnB\", ____________________, 10, anyValue, 30, 40))); . [value] equals ColumnA │ ColumnB 10 │ <any value> 30 │ 40 (1ms) Check matchers/import-and-dependencies Import And Dependencies for prerequisites."],["matchers@@same-instance@@","Matchers","Same Instance","","Use to check if two objects are the same: Groovy value.shouldBe sameInstance(anotherValue) value.shouldNotBe sameInstance(anotherValue) Check matchers/import-and-dependencies Import And Dependencies for prerequisites. Java actual(value).shouldBe(sameInstance(anotherValue)); actual(value).shouldNotBe(sameInstance(anotherValue)); Check matchers/import-and-dependencies Import And Dependencies for prerequisites."],["matchers@@value-change@@value-matcher","Matchers","Value Change","Value Matcher","Use change matcher and takeSnapshot to assert that a value is change/not-changed or wait for the change: Groovy value.should change . [value] changed (0ms) Check matchers/import-and-dependencies Import And Dependencies for prerequisites. Java actual(value).should(change); . [value] changed (0ms) Check matchers/import-and-dependencies Import And Dependencies for prerequisites. Groovy value.waitTo change > waiting for [value] to change . [value] changed (100ms) Java actual(value).waitTo(change); > waiting for [value] to change . [value] changed (100ms) Note: Value must implement SnapshotValueAware interface to work with change matcher. Common WebTau abstractions like web page element and file content already implement them. Use code matcher below as an alternative if you can't have interface implemented."],["matchers@@value-change@@code-change-matcher","Matchers","Value Change","Code Change Matcher","Use code matchers to validate that a block of code changes a value: Groovy code { updateDbEntity(dbEntity) } should change(\"dbEntity.id\", dbEntity::getId) > expecting code to change value of dbEntity.id X failed expecting code to change value of dbEntity.id: actual: \"id1\" <java.lang.String> expected: not \"id1\" <java.lang.String> (0ms) Java code(() -> { updateDbEntity(dbEntity); }).should(change(\"dbEntity.id\", dbEntity::getId)); > expecting code to change value of dbEntity.id X failed expecting code to change value of dbEntity.id: actual: \"id1\" <java.lang.String> expected: not \"id1\" <java.lang.String> (0ms) Pass a java bean to to validate that at least one property is changed Groovy code { buggyOperation(dbEntity) } should change(\"dbEntity\", dbEntity) > expecting code to change value of dbEntity X failed expecting code to change value of dbEntity: dbEntity.description: actual: \"description1\" <java.lang.String> expected: not \"description1\" <java.lang.String> dbEntity.id: actual: \"id1\" <java.lang.String> expected: not \"id1\" <java.lang.String> dbEntity.value: actual: 100 <java.lang.Integer> expected: not 100 <java.lang.Integer> (0ms) Java code(() -> { buggyOperation(dbEntity); }).should(change(\"dbEntity\", dbEntity)); > expecting code to change value of dbEntity X failed expecting code to change value of dbEntity: dbEntity.description: actual: \"description1\" <java.lang.String> expected: not \"description1\" <java.lang.String> dbEntity.id: actual: \"id1\" <java.lang.String> expected: not \"id1\" <java.lang.String> dbEntity.value: actual: 100 <java.lang.Integer> expected: not 100 <java.lang.Integer> (0ms) Use shouldNot to enforce that a value doesn't change Groovy code { calculatePrice(dbEntity) } shouldNot change(\"dbEntity\", dbEntity) > expecting code to not change value of dbEntity X failed expecting code to not change value of dbEntity: dbEntity.description: actual: \"description-changed\" <java.lang.String> expected: \"description1\" <java.lang.String> ^ dbEntity.value: actual: 110 <java.lang.Integer> expected: 100 <java.lang.Integer> (0ms) Java code(() -> { calculatePrice(dbEntity); }).shouldNot(change(\"dbEntity\", dbEntity)); > expecting code to not change value of dbEntity X failed expecting code to not change value of dbEntity: dbEntity.description: actual: \"description-changed\" <java.lang.String> expected: \"description1\" <java.lang.String> ^ dbEntity.value: actual: 110 <java.lang.Integer> expected: 100 <java.lang.Integer> (0ms)"],["matchers@@custom-compare-to-handler@@handler-vs-matcher","Matchers","Custom Compare To Handler","Handler vs Matcher","A lot of times you need to check if two things are equal. Instead of creating multiple matchers like arraysEqual , pathsEqual , myDataEqual , you define additional equality rule.Adding a new equality and greater/less rules is done by creating and registering new ."],["matchers@@custom-compare-to-handler@@comparetohandler","Matchers","Custom Compare To Handler","CompareToHandler","To add a new handler you need toimplement register new class using Java Services Interface public interface CompareToHandler { /** * determines whether supports equality comparison * @param actual actual value * @param expected expected value * @return true if comparison can be handled */ boolean handleEquality(Object actual, Object expected); /** * value optionally can be converted to another value to be passed down comparison chain. * exposed as outside method for more precise reporting of actual values in case of a failure. * * @param actual original actual * @param expected expected value * @return optionally converted actual */ default Object convertedActual(Object actual, Object expected) { return actual; } /** * value optionally can be converted to another value to be passed down comparison chain. * exposed as outside method for more precise reporting of expected values for reporting * * @param actual original actual * @param expected original expected * @return optionally converted expected */ default Object convertedExpected(Object actual, Object expected) { return expected; } /** * determines whether supports greater/less than comparison family * @param actual actual value * @param expected expected value * @return true if comparison can be handled */ default boolean handleGreaterLessEqual(Object actual, Object expected) { return false; } /** * determines whether handler can handle nulls. usually left unimplemented * @return true if handler can match nulls */ default boolean handleNulls() { return false; } /** * implementation logic of equality only * @param comparator comparator to delegate comparison to * @param actualPath path to use for reporting * @param actual actual value * @param expected expected value */ void compareEqualOnly(CompareToComparator comparator, ValuePath actualPath, Object actual, Object expected); /** * implementation logic of greater/less than family * @param comparator comparator to delegate comparison to * @param actualPath path to use for reporting * @param actual actual value * @param expected expected value */ default void compareGreaterLessEqual(CompareToComparator comparator, ValuePath actualPath, Object actual, Object expected) { throw new UnsupportedOperationException(\"greater-less comparison is not implemented\"); } } Example Implementation Below is an existing implementation of handler to deal with Java Beans and Java Records as actual and Map as expected public class MapAndJavaBeanOrRecordCompareToHandler extends MapAsExpectedCompareToHandlerBase { @Override protected boolean handleEquality(Object actual) { return !(actual instanceof Iterable || actual instanceof Map); } @Override public Object convertedActual(Object actual, Object expected) { if (actual instanceof ObjectProperties) { return ((ObjectProperties) actual).getTopLevelProperties(); } if (JavaRecordUtils.isRecord(actual)) { return JavaRecordUtils.convertRecordToMap(actual); } return JavaBeanUtils.convertBeanToMap(actual); } } Registration WebTau uses https://docs.oracle.com/javase/8/docs/api/java/util/ServiceLoader.html Service Loaders to discover implementations of handlers. To register an additional handler you need to create a file under resources META-INF/services/org.testingisdocumenting.webtau.expectation.equality.CompareToHandler with the content file containing a line per implementing class org.testingisdocumenting.webtau.expectation.equality.handlers.MapAndJavaBeanOrRecordCompareToHandler"],["matchers@@custom-compare-to-handler@@custom-complex-domain-data","Matchers","Custom Compare To Handler","Custom Complex Domain Data","Another example to use custom handler is to provide better mismatch details. Imagine you have some CustomComplexData class that contains important data from you domain.This class also has equals defined, and you can use it to check if two values are the same. But when it comes to use it during testing, you find that failure report is hard to comprehend: default assertion only prints toString representation leaving you to eyeball the rest. CustomComplexData calculated = new CustomComplexData(\"cA\", \"cB\"); calculated.addRow(1, 2); calculated.addRow(3, 4); CustomComplexData expected = new CustomComplexData(\"cA\", \"cB\"); expected.addRow(1, 2); expected.addRow(3, 5); Assert.assertEquals(expected, calculated); expected:<CustomComplexData{columnNames=[cA, cB], values=[[1, 2], [3, 5]]}> but was:<CustomComplexData{columnNames=[cA, cB], values=[[1, 2], [3, 4]]}> To improve the situation, we will define CustomComplexData : package org.example.domain; import org.testingisdocumenting.webtau.data.ValuePath; import org.testingisdocumenting.webtau.data.table.TableData; import org.testingisdocumenting.webtau.data.table.header.TableDataHeader; import org.testingisdocumenting.webtau.expectation.equality.CompareToComparator; import org.testingisdocumenting.webtau.expectation.equality.CompareToHandler; public class CustomComplexDataCompareToHandler implements CompareToHandler { @Override public boolean handleEquality(Object actual, Object expected) { return actual instanceof CustomComplexData && ( // handler for actual as your data expected instanceof CustomComplexData || // and expected as either your data or TableData expected instanceof TableData); } @Override public Object convertedActual(Object actual, Object expected) { return createTableDataFromCustomData((CustomComplexData) actual); } @Override public Object convertedExpected(Object actual, Object expected) { if (expected instanceof TableData) { return expected; } return createTableDataFromCustomData((CustomComplexData) expected); } @Override public void compareEqualOnly(CompareToComparator comparator, ValuePath actualPath, Object actual, Object expected) { comparator.compareUsingEqualOnly(actualPath, actual, expected); // delegate back to WebTau to compare using converted types } private TableData createTableDataFromCustomData(CustomComplexData actual) { TableData tableData = new TableData(new TableDataHeader(actual.getColumnNames().stream())); actual.forEach(tableData::addRow); // create TableData from complex domain data return tableData; } } Once handler is registered, additional information will be printed during mismatch: org.example.domain.CustomComplexDataCompareToHandler CustomComplexData calculated = new CustomComplexData(\"cA\", \"cB\"); calculated.addRow(1, 2); calculated.addRow(3, 4); CustomComplexData expected = new CustomComplexData(\"cA\", \"cB\"); expected.addRow(1, 2); expected.addRow(3, 5); actual(calculated).should(equal(expected)); X failed expecting [value] to equal cA │ cB 1 │ 2 3 │ 5: [value][1].cB: actual: 4 <java.lang.Integer> expected: 5 <java.lang.Integer> (1ms) cA │ cB 1 │ 2 3 │ **4**"],["matchers@@import-and-dependencies@@matchers-specific-import","Matchers","Import And Dependencies","Matchers Specific Import","When you use multiple WebTau features you can single static import to have all core features available for autocomplete. It also requires a single dependency to bring all the WebTau modules. Groovy import static org.testingisdocumenting.webtau.WebTauGroovyDsl.* <dependency> <groupId>org.testingisdocumenting.webtau</groupId> <artifactId>webtau-groovy</artifactId> <version>2.3</version> </dependency> If you use groovy-standalone-runner/introduction Groovy Runner then all the dependencies are already present. Java import static org.testingisdocumenting.webtau.WebTauDsl.*; <dependency> <groupId>org.testingisdocumenting.webtau</groupId> <artifactId>webtau</artifactId> <version>2.3</version> </dependency> To specifically import matchers only use: Groovy import static org.testingisdocumenting.webtau.Matchers.* <dependency> <groupId>org.testingisdocumenting.webtau</groupId> <artifactId>webtau-core</artifactId> <version>2.3</version> </dependency> Java import static org.testingisdocumenting.webtau.Matchers.*; <dependency> <groupId>org.testingisdocumenting.webtau</groupId> <artifactId>webtau-core</artifactId> <version>2.3</version> </dependency>"],["matchers@@import-and-dependencies@@core-module-import","Matchers","Import And Dependencies","Core Module Import","To have one import for matchers and utilities like list , map , table use: Groovy import static org.testingisdocumenting.webtau.WebTauCore.* Java import static org.testingisdocumenting.webtau.WebTauCore.*;"],["groovy-standalone-runner@@introduction@@standalone-cli","Groovy Standalone Runner","Introduction","Standalone CLI","WebTau has a standalone runner, so you can author and run tests without needing a build system or IDEs. You can fire your editor of choice and start creating automations without worrying about imports and packages to get your first result.In Enterprise setups WebTau command line tool can be shared with everyone through mount drives or other similar mechanisms which makes local testing and CI testing to be much more streamlined."],["groovy-standalone-runner@@introduction@@setup","Groovy Standalone Runner","Introduction","Setup","If you have https://brew.sh brew installed in your system use brew install testingisdocumenting/brew/webtau If you have https://sdkman.io sdkman installed in your system use sdk install webtau Alternatively, download and unzip https://repo.maven.apache.org/maven2/org/testingisdocumenting/webtau/webtau-dist/2.3/webtau-dist-2.3-webtau.zip WebTau. Add it to your PATH .Note: WebTau installed manually requires Java 17+ to be present in PATH webtau --example Navigate into todo example cd examples/todo import static org.testingisdocumenting.webtau.WebTauGroovyDsl.* scenario('fetch todo item') { http.get('/todos/1') { title.should == 'delectus aut autem' completed.should == false } } To run test webtau todolist.groovy --url=https://jsonplaceholder.typicode.com"],["groovy-standalone-runner@@introduction@@repl","Groovy Standalone Runner","Introduction","REPL","WebTau standalone runner comes with repl mode that let you experiment with API and write tests incrementally. Repl mode preserves context of the runs which significantly speeds up tests development.Even if you don't want to use Groovy for your tests, you can still benefit from REPL mode as you experiment with APIs and system under tests. REPL/experiments Learn more about REPL"],["groovy-standalone-runner@@data-driven-scenarios@@dynamic-scenarios","Groovy Standalone Runner","Data Driven Scenarios","Dynamic Scenarios","Every time you call scenario method a new scenario is being registered. Define scenarios in a loop to have dynamic scenarios based on provided data. package scenarios.concept import static org.testingisdocumenting.webtau.WebTauGroovyDsl.* [1, 2, 3].each { number -> scenario(\"number $number\") { println number } }"],["groovy-standalone-runner@@data-driven-scenarios@@csv","Groovy Standalone Runner","Data Driven Scenarios","CSV","Use data/csv#list-of-map data.csv to conveniently build your scenarios from an external CSV data set. title, input, output hello, 10, 20 world, 30, 40 package scenarios.concept import static org.testingisdocumenting.webtau.WebTauGroovyDsl.* data.csv.table('use-cases.csv').each { row -> scenario(\"use case ${row.title}\") { println row.input println row.output } }"],["groovy-standalone-runner@@data-driven-scenarios@@table-data","Groovy Standalone Runner","Data Driven Scenarios","Table Data","Use TableData if you want to derive data and/or have a convenience of collocating data and tests package scenarios.concept import static org.testingisdocumenting.webtau.WebTauGroovyDsl.* def lever = 10 def useCases = ['title' | 'input' | 'output'] { ____________________________________ 'hello' | lever | lever + 10 'world' | lever + 30 | lever + 40 } useCases.each { row -> scenario(\"use case ${row.title}\") { println row.input println row.output } }"],["groovy-standalone-runner@@tests-hard-stops@@terminate-all","Groovy Standalone Runner","Tests Hard Stops","Terminate All","Use terminateAll if you need to stop a current scenario and all the scenarios after that. Consequent scenarios will be marked as skipped in the produced report. package scenarios.concept import static org.testingisdocumenting.webtau.WebTauGroovyDsl.* scenario(\"first test\") { terminateAll('hard stop of the rest of the tests') } scenario(\"second test\") { browser.open(\"/app\") } scenario(\"third test\") { http.get(\"/weather\") { temperature.shouldBe < 100 } } Test two and three in the example above will not be executed. Browser will not be opened and REST API will not be called."],["groovy-standalone-runner@@selective-run@@sscenario","Groovy Standalone Runner","Selective Run","sscenario","Define tests with sscenario or singleScenario to only run those tests and skip all the other tests defined in all the test files. Useful during tests creation or debugging. package scenarios.concept import static org.testingisdocumenting.webtau.WebTauGroovyDsl.* scenario('step one') { http.post('/reset') { // ... } } sscenario('step two') { // test that you want to focus on } singleScenario('step three') { // test that you want to focus on } scenario('step four') { http.put('/extra') { // ... } } Note: webtau command line will exit with non zero code if there are sscenario tests present"],["groovy-standalone-runner@@skipping-tests@@skipping-tests-on-condition","Groovy Standalone Runner","Skipping Tests","Skipping Tests on Condition","Use onlyWhen if you need to skip tests based on a condition. package scenarios.concept import static org.testingisdocumenting.webtau.WebTauGroovyDsl.* String emailHost = cfg.emailHost onlyWhen('email server is internal', { -> emailHost.contains('internal.server')}) { scenario('confirmation emails should be sent') { // ... http.get(emailHost) { subjects.should contain('my message') } } } Tests will still appear as part of your report but will be marked as skipped."],["groovy-standalone-runner@@skipping-tests@@skipping-tests-based-on-env","Groovy Standalone Runner","Skipping Tests","Skipping Tests Based on Env","Use the skipForEnv and onlyForEnv shortcuts if you need to skip or enable tests for a certain environment. package scenarios.concept import static org.testingisdocumenting.webtau.WebTauGroovyDsl.* onlyForEnv('experimental') { scenario('this scenario will only be executed in \"experimental\" env') { http.get('/new-endpoint') { price.shouldBe > 0 } } } skipForEnv('experimental') { scenario('this scenario will not be executed in \"experimental\" env') { http.get('/new-endpoint') { price.shouldBe > 0 } } }"],["groovy-standalone-runner@@skipping-tests@@custom-shortcuts","Groovy Standalone Runner","Skipping Tests","Custom Shortcuts","Consider creating your project specific shortcuts to avoid boilerplate. Here is an example of onlyForEnv shortcut definition. static void onlyForEnv(String env, Closure registrationCode) { onlyWhen(\"only for <$env> environment\", { -> cfg.getEnv() == env }, registrationCode) }"],["groovy-standalone-runner@@skipping-tests@@unconditionally-skipping-tests","Groovy Standalone Runner","Skipping Tests","Unconditionally Skipping Tests","Instead of scenario , use dscenario or disabledScenario to always skip a test. This is analogous to Junit's @Ignore or @Disabled . package scenarios.concept import static org.testingisdocumenting.webtau.WebTauGroovyDsl.* dscenario('do not execute this scenario') { http.get('/non-existing-endpoint') { price.shouldBe > 0 } } disabledScenario('do not execute this scenario either') { http.get('/non-existing-endpoint') { price.shouldBe > 0 } } Alternatively, if you name file as <fileName>.disabled.groovy WebTau will skip all the scenarios inside."],["groovy-standalone-runner@@test-metadata@@specifying-test-metadata","Groovy Standalone Runner","Test Metadata","Specifying Test Metadata","To attach custom metadata to a test use metadata from WebTauGroovyDsl package scenarios.concept import static org.testingisdocumenting.webtau.WebTauGroovyDsl.* metadata([owner: \"team A\"]) // setting owner for all the scenarios below scenario(\"one\") { } scenario(\"two\") { } scenario(\"three\") { metadata([owner: \"team B\"]) // owner is overridden for scenario \"three\" } scenario(\"four\") { } metadata can be called multiple times outside of scenario . It will be applied to all the scenarios below. package scenarios.concept import static org.testingisdocumenting.webtau.WebTauGroovyDsl.* metadata([owner: \"team A\"]) // setting owner for scenarios \"one\" and \"two\" scenario(\"one\") { } scenario(\"two\") { } metadata([owner: \"team B\"]) // setting owner for scenarios \"three\" and \"four\" scenario(\"three\") { } scenario(\"four\") { } Unlike previous example, \"team B\" will be set for scenario \"three\" and \"four\"."],["groovy-standalone-runner@@test-metadata@@metadata-encapsulation","Groovy Standalone Runner","Test Metadata","Metadata Encapsulation","You can encapsulate repeated metadata into a separate file. package scenarios.concept import static org.testingisdocumenting.webtau.WebTauGroovyDsl.* Support.teamA() scenario(\"one\") { } scenario(\"two\") { } scenario(\"three\") { Support.teamB() } scenario(\"four\") { } package scenarios.concept import static org.testingisdocumenting.webtau.WebTauGroovyDsl.* class Support { static void owner(String name) { metadata([owner: name]) } static void severity(int level) { metadata([severity: level]) } static void teamA() { owner(\"team A\") } static void teamB() { owner(\"team B\") } static void critical() { severity(100) } static void low() { severity(1) } }"],["groovy-standalone-runner@@test-metadata@@report","Groovy Standalone Runner","Test Metadata","Report","Test metadata will be available in a generated report as well as in test listeners.If metadata is present, it will be displayed at the test summary page"],["groovy-standalone-runner@@test-listeners@@test-listener-interface","Groovy Standalone Runner","Test Listeners","Test Listener Interface","To define a custom test listener you need to implement the TestListener interface /* * Copyright 2020 webtau maintainers * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an \"AS IS\" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.testingisdocumenting.webtau; import org.testingisdocumenting.webtau.reporter.WebTauTest; import java.util.List; /** * Lowest common denominator for Groovy Standalone Tests, JUnit4, JUnit5 */ public interface TestListener { /** * before any test is ran */ default void beforeFirstTest() {} /** * before test code is invoked * @param test test */ default void beforeTestRun(WebTauTest test) {} /** * after test code is invoked * @param test test */ default void afterTestRun(WebTauTest test) {} /** * after all the tests are invoked */ default void afterAllTests() {} /** * after test is ran but before its first statement. * executed code in this listener is considered to be part of a test. * @param test test */ default void beforeFirstTestStatement(WebTauTest test) {} /** * right before test considered to be complete. May not be executed if the test didn't reach the last statement. * executed code in this listener is considered to be part of a test. * @param test test */ default void afterLastTestStatement(WebTauTest test) {} /** * after all the tests are discovered * @param tests stream of discovered tests */ default void afterTestsRegistration(List<WebTauTest> tests) {} }"],["groovy-standalone-runner@@test-listeners@@config","Groovy Standalone Runner","Test Listeners","Config","Once you have an implementation, use the testListeners key in your config file to use it import listeners.MetadataValidationTestListener testListeners = [MetadataValidationTestListener] package listeners import org.testingisdocumenting.webtau.TestListener import org.testingisdocumenting.webtau.reporter.WebTauTest class MetadataValidationTestListener implements TestListener { @Override void afterLastTestStatement(WebTauTest test) { if (!test.isSynthetic() && !test.metadata.has('owner')) { throw new RuntimeException('owner for <' + test.scenario + '> is not set') } } }"],["groovy-standalone-runner@@test-execution@@serial-execution","Groovy Standalone Runner","Test Execution","Serial execution","The default mode for running tests is serially; in other words, scenario files are executed one after the other."],["groovy-standalone-runner@@test-execution@@parallel-execution","Groovy Standalone Runner","Test Execution","Parallel execution","WebTau supports executing tests in parallel. In this mode, scenario files are executed in parallel. Individual scenarios are still executed sequentially.For large test suites, it is therefore advisable to create many small focused scenario files instead of few large files.Use --parallel parameter to run each test file in a separate thread.Use numberOfThreads to specify the maximum number of threads either through the configuration file or as a CLI parameter. Value of -1 is equivalent of using --parallel and will use as many threads as there are files.Note: scenario file execution order is not guaranteed."],["groovy-standalone-runner@@test-execution@@scenario-discovery","Groovy Standalone Runner","Test Execution","Scenario discovery","WebTau via CLI or Maven plugin supports a number of methods for specifying and discovering scenarios.The simplest way is to list the scenario files explicitly: CLI webtau scenarios/rest/simpleGet.groovy scnearios/rest/simplePost.groovy Maven <plugin> <groupId>org.testingisdocumenting.webtau</groupId> <artifactId>webtau-maven-plugin</artifactId> <version>2.3</version> <executions> <execution> <phase>test</phase> <goals> <goal>run</goal> </goals> </execution> </executions> <configuration> <workingDir>${project.basedir}/src/main/groovy</workingDir> <tests> <directory>${project.basedir}/src/main/groovy</directory> <includes> <include>scenarios/simpleGet.groovy</include> <include>scenarios/simplePost.groovy</include> </includes> </tests> </configuration> </plugin> Wildcard matching is also supported. In the CLI version this is normal shell https://en.wikipedia.org/wiki/Glob_(programming) glob and in Maven it's a standard Maven file inclusion block: CLI webtau scenarios/rest/simple*.groovy Maven <plugin> <groupId>org.testingisdocumenting.webtau</groupId> <artifactId>webtau-maven-plugin</artifactId> <version>2.3</version> <executions> <execution> <phase>test</phase> <goals> <goal>run</goal> </goals> </execution> </executions> <configuration> <workingDir>${project.basedir}/src/main/groovy</workingDir> <tests> <directory>${project.basedir}/src/main/groovy</directory> <includes> <include>scenarios/simple*.groovy</include> </includes> </tests> </configuration> </plugin> It is also possible to include a set of base directories and WebTau will then find all *.groovy files within them, recursively: CLI webtau scenarios/rest Maven <plugin> <groupId>org.testingisdocumenting.webtau</groupId> <artifactId>webtau-maven-plugin</artifactId> <version>2.3</version> <executions> <execution> <phase>test</phase> <goals> <goal>run</goal> </goals> </execution> </executions> <configuration> <workingDir>${project.basedir}/src/main/groovy</workingDir> <tests> <directory>${project.basedir}/src/main/groovy</directory> </tests> </configuration> </plugin> In this mode, the HTML report that WebTau generates will show paths to the files relative to the requested directories."],["groovy-standalone-runner@@IDE-setup@@autocompletion-dependency","Groovy Standalone Runner","IDE Setup","Autocompletion Dependency","If you use standalone runner outside of Maven/Gradle, your IDE won't know about packages and classes to make auto-completion work.To mitigate that, manually register webtau-all.jar as a global library. Jar is located in the lib directory next to the webtau executable."],["groovy-standalone-runner@@IDE-setup@@intellij-idea","Groovy Standalone Runner","IDE Setup","Intellij IDEA","Follow https://www.jetbrains.com/help/idea/libraries-and-global-libraries.html documentation to register webtau-all.jar as a global library."],["configuration@@groovy-config-file@@basic-properties","Configuration","Groovy Config File","Basic Properties","Use assignment to register a config value email = 'hello' cliPath = ['p1', 'p2']"],["configuration@@groovy-config-file@@complex-properties","Configuration","Groovy Config File","Complex Properties","Multiple ways to register complex properties complex.my_var.nested = 'webtau' // direct nested assignment complex { // scope definition for multiple assignment abc = 'abc_value' EDF = 'edf_value' subNested { nested = 'nested_nested' } } anotherComplex = [nested: 'vn'] // map based assignment anotherComplex.anotherNested = 'an'"],["configuration@@groovy-config-file@@environments","Configuration","Groovy Config File","Environments","Use environments block to define environment specific values and overrides email = 'hello' server = 'my-server' environments { dev { email = 'dev-hello' } beta { email = 'beta' } prod { server = 'prod-server' } } Environment specific complex object overrides complex = [id1: 'value1', id2: 'value2'] environments { dev { complex.id1 = 'value1-dev' complex.id3 = 'value3-dev' } beta { complex.id3 = 'value3-beta' } } webtau --env=dev"],["configuration@@groovy-config-file@@personas","Configuration","Groovy Config File","Personas","Use personas block to define persona specific values and overrides email = 'hello' personas { Alice { email = 'alice-email' } Bob { email = 'bob-email' } } Persona specific complex object overrides cliEnv = [ COMMON: 'common value', ANOTHER_COMMON: 'another common value'] personas { Alice { cliEnv.CREDENTIALS = 'alice-token' cliEnv.EXTRA_ALICE = 'extra alice' } Bob { cliEnv.CREDENTIALS = 'bob-token' cliEnv.EXTRA_BOB = 'extra bob' } }"],["configuration@@groovy-config-file@@persona-inside-environment","Configuration","Groovy Config File","Persona Inside Environment","Use personas block inside specific environment within environments block to have persona override for an environment cliEnv = [ COMMON: 'common value', ANOTHER_COMMON: 'another common value'] personas { Alice { cliEnv.CREDENTIALS = 'alice-token' // default Alice's specific values cliEnv.EXTRA_ALICE = 'extra alice' } Bob { cliEnv.CREDENTIALS = 'bob-token' cliEnv.EXTRA_BOB = 'extra bob' } } environments { dev { personas { Alice { cliEnv.CREDENTIALS = 'alice-dev-token' // Alice's overrides for dev environment cliEnv.EXTRA_ALICE = 'extra dev alice' cliEnv.EXTRA_DEV_V = 'extra dev alice v' } Bob { cliEnv.CREDENTIALS = 'bob-dev-token' cliEnv.EXTRA_BOB = 'extra dev bob' } } } beta { personas { Alice { cliEnv.CREDENTIALS = 'alice-beta-token' cliEnv.EXTRA_ALICE = 'extra beta alice' cliEnv.EXTRA_BETA_V = 'extra beta alice v' } Bob { cliEnv.CREDENTIALS = 'bob-beta-token' cliEnv.EXTRA_BOB = 'extra beta bob' } } } }"],["configuration@@options@@cli-and-configuration-file-options","Configuration","Options","CLI and configuration file options","browserDisableExtensions run browser without extensionsdefault value: false browserHeadless run browser in headless modedefault value: false browserHeight browser window heightdefault value: 0 browserId browser to use: chrome, firefoxdefault value: chrome browserRemoteDriverUrl browser remote driver url browserSameDriverInThreads set to true if you want only a single browser across multiple threads. Use case is notebook like apps.Personas will still have their own driversdefault value: false browserStaleElementRetry number of times to automatically retry for browser stale element actionsdefault value: 5 browserStaleElementRetryWait wait time in between browser stale element retriesdefault value: 100 browserTestcontainersEnabled pass true to get connection to web drivers using Test Containersdefault value: false browserUrl browser base url for application under test. It is being used instead of url when provided browserUseFakeMedia use fake microphone/camera to avoid asking for permission on browser/OS leveldefault value: false browserVersion browser version for automatic driver download browserWidth browser window widthdefault value: 0 cachePath user driven cache base dirdefault value: ${workingDir}/.webtau-cache chromeBinPath path to chrome binary chromeDriverPath path to chrome driver binary cliEnv cli common environment variablesdefault value: {} cliPath path items to append to path used for cli runsdefault value: [] cliTimeout cli foreground command run timeout (ms)default value: 30000 config config file pathdefault value: webtau.cfg.groovy consoleOutputCaptureDir path to a directory where overall and per test console output will be stored consolePayloadOutputLimit max number of lines to display in console for outputs (e.g. http response)default value: 500 dbDriverClassName primary database driver class name dbPassword primary database password dbUrl primary database url dbUserName primary database user name disableConsoleOverallReport do not print failed tests, overall summary and path to the generated report at the enddefault value: false disableRedirects disable following of redirects from HTTP callsdefault value: false docPath path for captured request/responses, screenshots and other generated artifacts for documentationdefault value: ${workingDir}/doc-artifacts env environment iddefault value: local failedReportPath failed report file path firefoxBinPath path to firefox binary firefoxDriverPath path to firefox driver binary fullAssertionError Always include detailed message in assertion error (even when console output is present)default value: false fullStackTrace print full stack trace to consoledefault value: false graphQLEndpoint override the default graphQL endpointdefault value: /graphql graphQLIgnoreIntrospectionFailures ignore graphQL introspection failures, introspection is required for coverage reportingdefault value: true graphQLShowOperationAsQueryParam pass the graphQL operation as operation= query parameter if presentdefault value: true httpDataCoverageOutput path to generated data coverage JSON result for additional processing httpProxy http proxy host:port httpRoutesPath path to a file or a resource with operations in a format METHOD route httpTimeout http connect and read timeout in millisecondsdefault value: 30000 jsonSchemasDir url of directory containing JSON schemasdefault value: /home/runner/work/webtau/webtau/webtau-groovy-app maxRedirects Maximum number of redirects to follow for an HTTP calldefault value: 20 noColor disable ANSI colorsdefault value: false numberOfThreads number of threads on which to run test files (one file per thread), -1 will use as many threads as there are filesdefault value: 1 openApiIgnoreAdditionalProperties ignore additional OpenAPI propertiesdefault value: false openApiSpecUrl url of OpenAPI 2 spec against which to validate http calls parallel run tests in parallel using numberOfThreads equals to number of filesdefault value: false removeWebTauFromUserAgent By default webtau appends webtau and its version to the user-agent, this disables that partdefault value: false reportName report name to showdefault value: WebTau report reportNameUrl report name url to navigate to when clicked reportPath report file pathdefault value: ${workingDir}/webtau.report.html serverProxyMaxThreads max number of threads for proxy servers (default number of CPUs * 2)default value: 8 tableVerticalSeparator string to use as a vertical separator when print TableDatadefault value: │ termui enable terminal UI to monitor tests (experimental)default value: false url base url for application under test userAgent User agent to send on HTTP requestsdefault value: webtau/2.3 verbosityLevel output verbosity level. 0 - no output; 1 - test names; 2 - first level steps; etcdefault value: 2147483647 waitTick wait tick in millisecondsdefault value: 100 waitTimeout wait timeout in millisecondsdefault value: 5000 webSocketMaxMessages max number of received messages to keep for polling/waitingdefault value: 1000 webSocketPollTimeout poll new message timeoutdefault value: 5000 workingDir logical working dirdefault value:"],["configuration@@options@@environment-variable-options","Configuration","Options","Environment variable options","WEBTAU_BROWSER_DISABLE_EXTENSIONS run browser without extensionsdefault value: false WEBTAU_BROWSER_HEADLESS run browser in headless modedefault value: false WEBTAU_BROWSER_HEIGHT browser window heightdefault value: 0 WEBTAU_BROWSER_ID browser to use: chrome, firefoxdefault value: chrome WEBTAU_BROWSER_REMOTE_DRIVER_URL browser remote driver url WEBTAU_BROWSER_SAME_DRIVER_IN_THREADS set to true if you want only a single browser across multiple threads. Use case is notebook like apps.Personas will still have their own driversdefault value: false WEBTAU_BROWSER_STALE_ELEMENT_RETRY number of times to automatically retry for browser stale element actionsdefault value: 5 WEBTAU_BROWSER_STALE_ELEMENT_RETRY_WAIT wait time in between browser stale element retriesdefault value: 100 WEBTAU_BROWSER_TESTCONTAINERS_ENABLED pass true to get connection to web drivers using Test Containersdefault value: false WEBTAU_BROWSER_URL browser base url for application under test. It is being used instead of url when provided WEBTAU_BROWSER_USE_FAKE_MEDIA use fake microphone/camera to avoid asking for permission on browser/OS leveldefault value: false WEBTAU_BROWSER_VERSION browser version for automatic driver download WEBTAU_BROWSER_WIDTH browser window widthdefault value: 0 WEBTAU_CACHE_PATH user driven cache base dirdefault value: ${workingDir}/.webtau-cache WEBTAU_CHROME_BIN_PATH path to chrome binary WEBTAU_CHROME_DRIVER_PATH path to chrome driver binary WEBTAU_CLI_ENV cli common environment variablesdefault value: {} WEBTAU_CLI_PATH path items to append to path used for cli runsdefault value: [] WEBTAU_CLI_TIMEOUT cli foreground command run timeout (ms)default value: 30000 WEBTAU_CONFIG config file pathdefault value: webtau.cfg.groovy WEBTAU_CONSOLE_OUTPUT_CAPTURE_DIR path to a directory where overall and per test console output will be stored WEBTAU_CONSOLE_PAYLOAD_OUTPUT_LIMIT max number of lines to display in console for outputs (e.g. http response)default value: 500 WEBTAU_DB_DRIVER_CLASS_NAME primary database driver class name WEBTAU_DB_PASSWORD primary database password WEBTAU_DB_URL primary database url WEBTAU_DB_USER_NAME primary database user name WEBTAU_DISABLE_CONSOLE_OVERALL_REPORT do not print failed tests, overall summary and path to the generated report at the enddefault value: false WEBTAU_DISABLE_REDIRECTS disable following of redirects from HTTP callsdefault value: false WEBTAU_DOC_PATH path for captured request/responses, screenshots and other generated artifacts for documentationdefault value: ${workingDir}/doc-artifacts WEBTAU_ENV environment iddefault value: local WEBTAU_FAILED_REPORT_PATH failed report file path WEBTAU_FIREFOX_BIN_PATH path to firefox binary WEBTAU_FIREFOX_DRIVER_PATH path to firefox driver binary WEBTAU_FULL_ASSERTION_ERROR Always include detailed message in assertion error (even when console output is present)default value: false WEBTAU_FULL_STACK_TRACE print full stack trace to consoledefault value: false WEBTAU_GRAPH_QLENDPOINT override the default graphQL endpointdefault value: /graphql WEBTAU_GRAPH_QLIGNORE_INTROSPECTION_FAILURES ignore graphQL introspection failures, introspection is required for coverage reportingdefault value: true WEBTAU_GRAPH_QLSHOW_OPERATION_AS_QUERY_PARAM pass the graphQL operation as operation= query parameter if presentdefault value: true WEBTAU_HTTP_DATA_COVERAGE_OUTPUT path to generated data coverage JSON result for additional processing WEBTAU_HTTP_PROXY http proxy host:port WEBTAU_HTTP_ROUTES_PATH path to a file or a resource with operations in a format METHOD route WEBTAU_HTTP_TIMEOUT http connect and read timeout in millisecondsdefault value: 30000 WEBTAU_JSON_SCHEMAS_DIR url of directory containing JSON schemasdefault value: /home/runner/work/webtau/webtau/webtau-groovy-app WEBTAU_MAX_REDIRECTS Maximum number of redirects to follow for an HTTP calldefault value: 20 WEBTAU_NO_COLOR disable ANSI colorsdefault value: false WEBTAU_NUMBER_OF_THREADS number of threads on which to run test files (one file per thread), -1 will use as many threads as there are filesdefault value: 1 WEBTAU_OPEN_API_IGNORE_ADDITIONAL_PROPERTIES ignore additional OpenAPI propertiesdefault value: false WEBTAU_OPEN_API_SPEC_URL url of OpenAPI 2 spec against which to validate http calls WEBTAU_PARALLEL run tests in parallel using numberOfThreads equals to number of filesdefault value: false WEBTAU_REMOVE_WEB_TAU_FROM_USER_AGENT By default webtau appends webtau and its version to the user-agent, this disables that partdefault value: false WEBTAU_REPORT_NAME report name to showdefault value: WebTau report WEBTAU_REPORT_NAME_URL report name url to navigate to when clicked WEBTAU_REPORT_PATH report file pathdefault value: ${workingDir}/webtau.report.html WEBTAU_SERVER_PROXY_MAX_THREADS max number of threads for proxy servers (default number of CPUs * 2)default value: 8 WEBTAU_TABLE_VERTICAL_SEPARATOR string to use as a vertical separator when print TableDatadefault value: │ WEBTAU_TERMUI enable terminal UI to monitor tests (experimental)default value: false WEBTAU_URL base url for application under test WEBTAU_USER_AGENT User agent to send on HTTP requestsdefault value: webtau/2.3 WEBTAU_VERBOSITY_LEVEL output verbosity level. 0 - no output; 1 - test names; 2 - first level steps; etcdefault value: 2147483647 WEBTAU_WAIT_TICK wait tick in millisecondsdefault value: 100 WEBTAU_WAIT_TIMEOUT wait timeout in millisecondsdefault value: 5000 WEBTAU_WEB_SOCKET_MAX_MESSAGES max number of received messages to keep for polling/waitingdefault value: 1000 WEBTAU_WEB_SOCKET_POLL_TIMEOUT poll new message timeoutdefault value: 5000 WEBTAU_WORKING_DIR logical working dirdefault value:"],["junit5@@getting-started@@integration-benefits","JUnit 5","Getting Started","Integration Benefits","WebTau can be used as is, without any special integration with https://junit.org/junit5/ JUnit5.However, integration provides: junit5/reporting Rich Reporting Additional junit5/dynamic-tests Dynamic Tests Capabilities"],["junit5@@getting-started@@maven-import","JUnit 5","Getting Started","Maven Import","<dependency> <groupId>org.testingisdocumenting.webtau</groupId> <artifactId>webtau-junit5</artifactId> <version>2.3</version> </dependency>"],["junit5@@reporting@@webtau-report","JUnit 5","Reporting","WebTau Report","You can use WebTau http. , graphql. , browser. , cli. , db. modules without any additional setup, but to include a test into generated report and to get extra console output you need to use @WebTau annotation or enable global extension (see below) Groovy package com.example.tests.junit5 import org.testingisdocumenting.webtau.junit5.WebTau import org.junit.jupiter.api.* import static org.testingisdocumenting.webtau.WebTauGroovyDsl.* @WebTau // annotation to enable rich console output and html reporting @TestMethodOrder(MethodOrderer.OrderAnnotation) // forcing methods execution order @DisplayName(\"customer CRUD\") class CustomerCrudSeparatedGroovyTest { private static def customerPayload = [firstName: 'FN', lastName : 'LN'] private static def changedCustomerPayload = [*: customerPayload, lastName: 'NLN'] private static def id @BeforeAll @DisplayName(\"create customer\") // optional friendly name for reporting purposes static void createCustomer() { id = http.post(\"/customers\", customerPayload) { body.id // using body prefix is required in this case as id conflicts with class field name } id.shouldNot == 0 } @Test @Order(1) @DisplayName(\"read customer\") void read() { http.get(\"/customers/$id\") { body.should == customerPayload } } @Test @Order(2) // order dependence saves from creating customer on every test @DisplayName(\"update customer\") void update() { http.put(\"/customers/$id\", changedCustomerPayload) { body.should == changedCustomerPayload } http.get(\"/customers/$id\") { body.should == changedCustomerPayload } } @Test @Order(3) // but you can still run each method independently @DisplayName(\"delete customer\") void delete() { http.delete(\"/customers/$id\") { header.statusCode.should == 204 } http.get(\"/customers/$id\") { header.statusCode.should == 404 } id = -1 // marking as deleted to let cleanup step know that no delete is required } @AfterAll static void cleanup() { // optional (since we create new ids all the time) step to keep your environment clean if (id == -1) { return } http.delete(\"/customers/$id\") } } Java package com.example.tests.junit5; import org.testingisdocumenting.webtau.http.request.HttpRequestBody; import org.testingisdocumenting.webtau.junit5.WebTau; import org.junit.jupiter.api.*; import static org.testingisdocumenting.webtau.WebTauDsl.*; @WebTau // annotation to enable rich console output and html reporting @TestMethodOrder(MethodOrderer.OrderAnnotation.class) // forcing methods execution order @DisplayName(\"customer CRUD\") public class CustomerCrudSeparatedJavaTest { private static final HttpRequestBody customerPayload = http.json( \"firstName\", \"FN\", \"lastName\", \"LN\"); private static final HttpRequestBody changedCustomerPayload = http.json( \"firstName\", \"FN\", \"lastName\", \"NLN\"); private static int id; @BeforeAll @DisplayName(\"create customer\") // optional friendly name for reporting purposes public static void createCustomer() { id = http.post(\"/customers\", customerPayload, ((header, body) -> { return body.get(\"id\"); })); actual(id).shouldNot(equal(0)); } @Test @Order(1) @DisplayName(\"read customer\") public void read() { http.get(\"/customers/\" + id, ((header, body) -> { body.should(equal(customerPayload)); })); } @Test @Order(2) // order dependence saves from creating customer on every test @DisplayName(\"update customer\") public void update() { http.put(\"/customers/\" + id, changedCustomerPayload, ((header, body) -> { body.should(equal(changedCustomerPayload)); })); http.get(\"/customers/\" + id, ((header, body) -> { body.should(equal(changedCustomerPayload)); })); } @Test @Order(3) // but you can still run each method independently @DisplayName(\"delete customer\") public void delete() { http.delete(\"/customers/\" + id, ((header, body) -> { header.statusCode.should(equal(204)); })); http.get(\"/customers/\" + id, ((header, body) -> { header.statusCode.should(equal(404)); })); id = -1; // marking as deleted to let cleanup step know that no delete is required } @AfterAll public static void cleanup() { // optional (since we create new ids all the time) step to keep your environment clean if (id == -1) { return; } http.delete(\"/customers/\" + id); } }"],["junit5@@reporting@@extra-console-output","JUnit 5","Reporting","Extra Console Output","WebTau produces extra console output when you enable reporting either via annotation or globally (see below). scenario create customers (customer query) > executing HTTP POST http://localhost:34197/customers request (application/json): { \"firstName\": \"CQ_FN1\", \"lastName\": \"CQ_LN1\" } . header.statusCode equals 201 (0ms) response (application/json): { \"id\": 7, \"firstName\": \"CQ_FN1\", \"lastName\": \"CQ_LN1\" } . executed HTTP POST http://localhost:34197/customers (10ms) > executing HTTP POST http://localhost:34197/customers request (application/json): { \"firstName\": \"CQ_FN1\", \"lastName\": \"CQ_LN2\" } . header.statusCode equals 201 (0ms) response (application/json): { \"id\": 8, \"firstName\": \"CQ_FN1\", \"lastName\": \"CQ_LN2\" } . executed HTTP POST http://localhost:34197/customers (10ms) > executing HTTP POST http://localhost:34197/customers request (application/json): { \"firstName\": \"CQ_FN2\", \"lastName\": \"CQ_LN2\" } . header.statusCode equals 201 (0ms) response (application/json): { \"id\": 9, \"firstName\": \"CQ_FN2\", \"lastName\": \"CQ_LN2\" } . executed HTTP POST http://localhost:34197/customers (10ms) [.] create customers (customer query) scenario query by last name (customer query) > executing HTTP GET http://localhost:34197/customers/search/last-name?name=CQ_LN2 . body equals *id │ firstName │ lastName 8 │ \"CQ_FN1\" │ \"CQ_LN2\" 9 │ \"CQ_FN2\" │ \"CQ_LN2\" (1ms) . header.statusCode equals 200 (0ms) response (application/json): [ {\"id\": __8__, \"firstName\": __\"CQ_FN1\"__, \"lastName\": __\"CQ_LN2\"__}, {\"id\": __9__, \"firstName\": __\"CQ_FN2\"__, \"lastName\": __\"CQ_LN2\"__} ] . executed HTTP GET http://localhost:34197/customers/search/last-name?name=CQ_LN2 (10ms) [.] query by last name (customer query) scenario query by first name (customer query) > executing HTTP GET http://localhost:34197/customers/search/first-name?name=CQ_FN1 . body equals *id │ firstName │ lastName 7 │ \"CQ_FN1\" │ \"CQ_LN1\" 8 │ \"CQ_FN1\" │ \"CQ_LN2\" (1ms) . header.statusCode equals 200 (0ms) response (application/json): [ {\"id\": __7__, \"firstName\": __\"CQ_FN1\"__, \"lastName\": __\"CQ_LN1\"__}, {\"id\": __8__, \"firstName\": __\"CQ_FN1\"__, \"lastName\": __\"CQ_LN2\"__} ] . executed HTTP GET http://localhost:34197/customers/search/first-name?name=CQ_FN1 (9ms) [.] query by first name (customer query) scenario clean up (customer query) > executing HTTP DELETE http://localhost:34197/customers/7 . header.statusCode equals 204 (0ms) [no content] . executed HTTP DELETE http://localhost:34197/customers/7 (7ms) > executing HTTP DELETE http://localhost:34197/customers/8 . header.statusCode equals 204 (0ms) [no content] . executed HTTP DELETE http://localhost:34197/customers/8 (8ms) > executing HTTP DELETE http://localhost:34197/customers/9 . header.statusCode equals 204 (0ms) [no content] . executed HTTP DELETE http://localhost:34197/customers/9 (7ms) [.] clean up (customer query) scenario after all tests (Teardown) [.] after all tests (Teardown) Total time: 80ms Total: 5, Passed: 5, Skipped: 0, Failed: 0, Errored: 0 report is generated: /home/runner/work/webtau/webtau/webtau-junit5-examples/webtau-reports/com.example.tests.junit5.CustomerQueryJavaTest.html"],["junit5@@reporting@@automatic-extension","JUnit 5","Reporting","Automatic Extension","To enable report for all the tests without annotating each of them, use JUnit5 https://junit.org/junit5/docs/current/user-guide/#extensions-registration-automatic automatic extension registration org.testingisdocumenting.webtau.junit5.WebTauJunitExtension junit.jupiter.extensions.autodetection.enabled=true"],["junit5@@reporting@@beforeall-afterall-reporting","JUnit 5","Reporting","BeforeAll/AfterAll Reporting","@BeforeAll and @AfterAll are separate entries in the generated report Groovy package com.example.tests.junit5 import org.testingisdocumenting.webtau.junit5.WebTau import org.junit.jupiter.api.AfterAll import org.junit.jupiter.api.BeforeAll import org.junit.jupiter.api.DisplayName import org.junit.jupiter.api.Test import static org.testingisdocumenting.webtau.WebTauGroovyDsl.* @WebTau @DisplayName(\"customer query\") class CustomerQueryGroovyTest { private static def id1 // keep track of created ids to assert and cleanup later private static def id2 private static def id3 @BeforeAll @DisplayName(\"create customers\") static void createCustomers() { id1 = createCustomer(\"CQ_FN1\", \"CQ_LN1\") id2 = createCustomer(\"CQ_FN1\", \"CQ_LN2\") id3 = createCustomer(\"CQ_FN2\", \"CQ_LN2\") } @Test @DisplayName(\"query by first name\") void queryByFirstName() { http.get(\"/customers/search/first-name\", [name: \"CQ_FN1\"]) { body.should == [\"*id\" | \"firstName\" | \"lastName\"] { // star(*) marks key column so assertion is order agnostic __________________________________ id1 | \"CQ_FN1\" | \"CQ_LN1\" id2 | \"CQ_FN1\" | \"CQ_LN2\" } } } @Test @DisplayName(\"query by last name\") void queryByLastName() { http.get(\"/customers/search/last-name\", [name: \"CQ_LN2\"]) { body.should == [\"*id\" | \"firstName\" | \"lastName\"] { __________________________________ id2 | \"CQ_FN1\" | \"CQ_LN2\" id3 | \"CQ_FN2\" | \"CQ_LN2\" } } } @AfterAll @DisplayName(\"clean up\") static void cleanup() { [id1, id2, id3].each { http.delete(\"/customers/$it\") } } private static def createCustomer(String firstName, String lastName) { return http.post(\"/customers\", [firstName: firstName, lastName: lastName]) { id } } } Java package com.example.tests.junit5; import org.junit.jupiter.api.AfterAll; import org.junit.jupiter.api.BeforeAll; import org.junit.jupiter.api.DisplayName; import org.junit.jupiter.api.Test; import org.testingisdocumenting.webtau.junit5.WebTau; import java.util.Map; import java.util.stream.Stream; import static org.testingisdocumenting.webtau.WebTauDsl.*; @WebTau @DisplayName(\"customer query\") class CustomerQueryJavaTest { private static Integer id1; // keep track of created ids to assert and cleanup later private static Integer id2; private static Integer id3; @BeforeAll @DisplayName(\"create customers\") static void createCustomers() { id1 = createCustomer(\"CQ_FN1\", \"CQ_LN1\"); id2 = createCustomer(\"CQ_FN1\", \"CQ_LN2\"); id3 = createCustomer(\"CQ_FN2\", \"CQ_LN2\"); } @Test @DisplayName(\"query by first name\") void queryByFirstName() { http.get(\"/customers/search/first-name\", http.query(\"name\", \"CQ_FN1\"), (header, body) -> { body.should(equal(table(\"*id\", \"firstName\", \"lastName\", // star(*) marks key column so assertion is order agnostic ________________________________, id1, \"CQ_FN1\" , \"CQ_LN1\", id2, \"CQ_FN1\" , \"CQ_LN2\"))); }); } @Test @DisplayName(\"query by last name\") void queryByLastName() { http.get(\"/customers/search/last-name\", http.query(\"name\", \"CQ_LN2\"), (header, body) -> { body.should(equal(table(\"*id\", \"firstName\", \"lastName\", ________________________________, id2, \"CQ_FN1\" , \"CQ_LN2\", id3, \"CQ_FN2\" , \"CQ_LN2\"))); }); } @AfterAll @DisplayName(\"clean up\") static void cleanup() { Stream.of(id1, id2, id3).forEach(id -> http.delete(\"/customers/\" + id)); } private static int createCustomer(String firstName, String lastName) { Map<String, Object> payload = map( \"firstName\", firstName, \"lastName\", lastName); return http.post(\"/customers\", payload, ((header, body) -> { return body.get(\"id\"); })); } }"],["junit5@@dynamic-tests@@testfactory","JUnit 5","Dynamic Tests","TestFactory","With the additional annotation @TestFactory you can use TableData as an easy-to-read source of similar but independent tests where each row is treated as its own test, optionally with a descriptive label.Here are some examples of parameterized tests with and without labels: Groovy @TestFactory def \"individual tests use generated display labels\"() { [\"price\" | \"quantity\" | \"outcome\"] { _________________________________ 10.0 | 30 | 300.0 -10.0 | 30 | -300.0 }.test { PriceCalculator.calculate(price, quantity).should == outcome } } @TestFactory def \"individual tests label to clarify the use case\"() { [\"label\" | \"price\" | \"quantity\" | \"outcome\"] { _____________________________________________________ \"positive price\" | 10.0 | 30 | 300.0 \"negative price\" | -10.0 | 30 | -300.0 }.test { PriceCalculator.calculate(price, quantity).should == outcome } } Java @TestFactory public Stream<DynamicTest> individualTestsUseGeneratedDisplayLabels() { TableData useCases = table(\"price\", \"quantity\", \"outcome\", ______________________________, 10.0 , 30, 300.0, -10.0 , 30, -300.0); return DynamicTests.fromTable(useCases, r -> { double price = r.get(\"price\"); int quantity = r.get(\"quantity\"); double outcome = r.get(\"outcome\"); actual(PriceCalculator.calculate(price, quantity)).should(equal(outcome)); }); } @TestFactory public Stream<DynamicTest> individualTestsLabelToClarifyUseCase() { TableData useCases = table(\"label\" , \"price\", \"quantity\", \"outcome\", _________________________________________________, \"positive price\", 10.0 , 30, 300.0, \"negative price\", -10.0 , 30, -300.0); return DynamicTests.fromTable(useCases, r -> { double price = r.get(\"price\"); int quantity = r.get(\"quantity\"); double outcome = r.get(\"outcome\"); actual(PriceCalculator.calculate(price, quantity)).should(equal(outcome)); }); }"],["junit5@@JUnit-4@@webtau-runner","JUnit 5","JUnit 4","WebTau Runner","Note: Limited features development for JUnit4 runner. Please consider migration to junit5/getting-started JUnit5You can use WebTau http. , graphql. , browser. , cli. , db. methods as in a junit 4 tests, but to enable reporting you need to use @RunWith(WebTauRunner.class) Groovy package com.example.tests.junit4 import org.testingisdocumenting.webtau.junit4.WebTauRunner import org.junit.Test import org.junit.runner.RunWith import static org.testingisdocumenting.webtau.WebTauGroovyDsl.* // convenient single import for DSL methods and props like http @RunWith(WebTauRunner) // runner is required to have this test to be a part of generated html report class CustomerCrudSingleGroovyTest { private def customerPayload = [firstName: 'FN', lastName: 'LN'] private def changedCustomerPayload = [*:customerPayload, lastName: 'NLN'] @Test void crud() { def id = http.post(\"/customers\", customerPayload) { return id } http.get(\"/customers/$id\") { body.should == customerPayload } http.put(\"/customers/$id\", changedCustomerPayload) { body.should == changedCustomerPayload } http.get(\"/customers/$id\") { body.should == changedCustomerPayload } http.delete(\"/customers/$id\") { statusCode.should == 204 } http.get(\"/customers/$id\") { statusCode.should == 404 } } } Java package com.example.tests.junit4; import org.testingisdocumenting.webtau.http.request.HttpRequestBody; import org.testingisdocumenting.webtau.junit4.WebTauRunner; import org.junit.Test; import org.junit.runner.RunWith; import static org.testingisdocumenting.webtau.WebTauDsl.*; // convenient single import for DSL methods and props like http and equal, mapOf, etc @RunWith(WebTauRunner.class) // runner is required to have this test to be a part of generated html report public class CustomerCrudSingleJavaTest { private final HttpRequestBody customerPayload = http.json( \"firstName\", \"FN\", \"lastName\", \"LN\"); private final HttpRequestBody changedCustomerPayload = http.json( \"firstName\", \"FN\", \"lastName\", \"NLN\"); @Test public void crud() { int id = http.post(\"/customers\", customerPayload, ((header, body) -> { return body.get(\"id\"); })); http.get(\"/customers/\" + id, ((header, body) -> { body.should(equal(customerPayload)); })); http.put(\"/customers/\" + id, changedCustomerPayload, ((header, body) -> { body.should(equal(changedCustomerPayload)); })); http.get(\"/customers/\" + id, ((header, body) -> { body.should(equal(changedCustomerPayload)); })); http.delete(\"/customers/\" + id, ((header, body) -> { header.statusCode.should(equal(204)); })); http.get(\"/customers/\" + id, ((header, body) -> { header.statusCode.should(equal(404)); })); } }"],["junit5@@JUnit-4@@before-after","JUnit 5","JUnit 4","Before/After","Use @Before , @After standard JUnit 4 annotations to implement init and cleanup logic for each test. Groovy package com.example.tests.junit4 import org.testingisdocumenting.webtau.junit4.WebTauRunner import org.junit.After import org.junit.Before import org.junit.Test import org.junit.runner.RunWith import static org.testingisdocumenting.webtau.WebTauGroovyDsl.* @RunWith(WebTauRunner.class) class CustomerCrudBeforeAfterGroovyTest { private def customerPayload = [firstName: 'FN', lastName: 'LN'] private def changedCustomerPayload = [*:customerPayload, lastName: 'NLN'] private int customerId @Before void \"create customer\"() { customerId = http.post(\"/customers\", customerPayload) { return id // We deliberately named field as \"customerId\" to avoid conflict with response field. Alternatively you can use body.id to avoid the conflict } } @Test void \"query customer\"() { http.get(\"/customers/$customerId\") { body.should == customerPayload } } @Test void \"update customer\"() { http.put(\"/customers/$customerId\", changedCustomerPayload) { body.should == changedCustomerPayload } http.get(\"/customers/$customerId\") { body.should == changedCustomerPayload } } @After void \"delete customer\"() { http.delete(\"/customers/$customerId\") { statusCode.should == 204 } http.get(\"/customers/$customerId\") { statusCode.should == 404 } } } Java package com.example.tests.junit4; import org.junit.After; import org.junit.Before; import org.junit.Test; import org.junit.runner.RunWith; import org.testingisdocumenting.webtau.http.request.HttpRequestBody; import org.testingisdocumenting.webtau.junit4.WebTauRunner; import static org.testingisdocumenting.webtau.WebTauDsl.*; @RunWith(WebTauRunner.class) public class CustomerCrudBeforeAfterJavaTest { private final HttpRequestBody customerPayload = http.json( \"firstName\", \"FN\", \"lastName\", \"LN\"); private final HttpRequestBody changedCustomerPayload = http.json( \"firstName\", \"FN\", \"lastName\", \"NLN\"); private int customerId; @Before public void createCustomer() { customerId = http.post(\"/customers\", customerPayload, ((header, body) -> { return body.get(\"id\"); })); } @Test public void queryCustomer() { http.get(\"/customers/\" + customerId, ((header, body) -> { body.should(equal(customerPayload)); })); } @Test public void updateCustomer() { http.put(\"/customers/\" + customerId, changedCustomerPayload, ((header, body) -> { body.should(equal(changedCustomerPayload)); })); http.get(\"/customers/\" + customerId, ((header, body) -> { body.should(equal(changedCustomerPayload)); })); } @After public void deleteCustomer() { http.delete(\"/customers/\" + customerId, (header, body) -> { header.statusCode.should(equal(204)); }); http.get(\"/customers/\" + customerId, ((header, body) -> { header.statusCode.should(equal(404)); })); } }"],["junit5@@JUnit-4@@beforeclass-afterclass","JUnit 5","JUnit 4","BeforeClass/AfterClass","Use @BeforeClass and @AfterClass to prepare and cleanup resources required for multiple test methods. Groovy package com.example.tests.junit4 import org.testingisdocumenting.webtau.junit4.WebTauRunner import org.junit.AfterClass import org.junit.BeforeClass import org.junit.Test import org.junit.runner.RunWith import static org.testingisdocumenting.webtau.WebTauGroovyDsl.* @RunWith(WebTauRunner.class) class CustomerQueryGroovyTest { private static def id1 // keep track of created ids to assert and cleanup later private static def id2 private static def id3 @BeforeClass static void createCustomers() { id1 = createCustomer(\"CQ_FN1\", \"CQ_LN1\") id2 = createCustomer(\"CQ_FN1\", \"CQ_LN2\") id3 = createCustomer(\"CQ_FN2\", \"CQ_LN2\") } @Test void queryByFirstName() { http.get(\"/customers/search/first-name\", [name: \"CQ_FN1\"]) { body.should == [\"*id\" | \"firstName\" | \"lastName\"] { // star(*) marks key column so assertion is order agnostic __________________________________ id1 | \"CQ_FN1\" | \"CQ_LN1\" id2 | \"CQ_FN1\" | \"CQ_LN2\" } } } @Test void queryByLastName() { http.get(\"/customers/search/last-name\", [name: \"CQ_LN2\"]) { body.should == [\"*id\" | \"firstName\" | \"lastName\"] { __________________________________ id2 | \"CQ_FN1\" | \"CQ_LN2\" id3 | \"CQ_FN2\" | \"CQ_LN2\" } } } @AfterClass static void cleanup() { [id1, id2, id3].each { http.delete(\"/customers/$it\") } } private static def createCustomer(String firstName, String lastName) { return http.post(\"/customers\", [firstName: firstName, lastName: lastName]) { id } } } Java package com.example.tests.junit4; import org.testingisdocumenting.webtau.junit4.WebTauRunner; import org.junit.AfterClass; import org.junit.BeforeClass; import org.junit.Test; import org.junit.runner.RunWith; import java.util.Map; import java.util.stream.Stream; import static org.testingisdocumenting.webtau.WebTauDsl.*; @RunWith(WebTauRunner.class) public class CustomerQueryJavaTest { private static Integer id1; // keep track of created ids to assert and cleanup later private static Integer id2; private static Integer id3; @BeforeClass public static void createCustomers() { id1 = createCustomer(\"CQ_FN1\", \"CQ_LN1\"); id2 = createCustomer(\"CQ_FN1\", \"CQ_LN2\"); id3 = createCustomer(\"CQ_FN2\", \"CQ_LN2\"); } @Test public void queryByFirstName() { http.get(\"/customers/search/first-name\", http.query(\"name\", \"CQ_FN1\"), (header, body) -> { body.should(equal(table(\"*id\", \"firstName\", \"lastName\", // star(*) marks key column so assertion is order agnostic ________________________________, id1, \"CQ_FN1\" , \"CQ_LN1\", id2, \"CQ_FN1\" , \"CQ_LN2\"))); }); } @Test public void queryByLastName() { http.get(\"/customers/search/last-name\", http.query(\"name\", \"CQ_LN2\"), (header, body) -> { body.should(equal(table(\"*id\", \"firstName\", \"lastName\", ________________________________, id2, \"CQ_FN1\" , \"CQ_LN2\", id3, \"CQ_FN2\" , \"CQ_LN2\"))); }); } @AfterClass public static void cleanup() { Stream.of(id1, id2, id3).forEach(id -> http.delete(\"/customers/\" + id)); } private static int createCustomer(String firstName, String lastName) { Map<String, Object> payload = map( \"firstName\", firstName, \"lastName\", lastName); return http.post(\"/customers\", payload, ((header, body) -> { return body.get(\"id\"); })); } }"],["junit5@@JUnit-4@@maven-import","JUnit 5","JUnit 4","Maven Import","<dependency> <groupId>org.testingisdocumenting.webtau</groupId> <artifactId>webtau-junit4</artifactId> <version>2.3</version> </dependency>"],["JVM-business-logic@@data-driven@@data-focused-tests","JVM Business Logic","Data Driven","Data Focused Tests","WebTau simplifies writing REST/GraphQL/Browser/DB/CLI tests. On top of that if the logic behind those layers is written in JVM based language, WebTau also simplifies testing logic behind those layers directly.WebTau makes tests to be focused on input and output by reducing boilerplate."],["JVM-business-logic@@data-driven@@simplified-input-preparation","JVM Business Logic","Data Driven","Simplified Input Preparation","Groovy @Test void \"diversified teams should have various levels and time at company\"() { def employeeData = [ \"id\" | \"level\" | \"monthsAtCompany\"] { _______________________________________ \"bob\" | 2 | 12 \"smith\" | 4 | 34 \"john\" | 3 | 20 } def diversified = peopleManagement.diversityLevel(employees(employeeData)) diversified.should == true } Java @Test public void diversifiedTeamsShouldHaveVariousLevelsAndTimeAtCompany() { TableData employeeData = table( \"id\", \"level\", \"monthsAtCompany\").values( \"bob\", 2, 12, \"smith\", 4, 34, \"john\", 3, 20); boolean diversified = peopleManagement.diversityLevel(employees(employeeData)); actual(diversified).should(equal(true)); }"],["JVM-business-logic@@data-driven@@simplified-output-validation","JVM Business Logic","Data Driven","Simplified Output Validation","Complex data and assertions are first class citizens. Groovy @Test void \"provides access to new joiners\"() { TableData allEmployees = [\"id\" | \"level\" | \"monthsAtCompany\"] { ______________________________________ \"alice\" | 5 | 1 \"bob\" | 3 | 0 \"smith\" | 4 | 1 \"cat\" | 4 | 0 } addEmployees(allEmployees) dao.thisWeekJoiners().should == [\"id\" | \"level\" | \"monthsAtCompany\"] { ______________________________________ \"bob\" | 3 | 0 \"cat\" | 4 | 0 } } Java @Test public void providesAccessToNewJoiners() { TableData allEmployees = table( \"id\", \"level\", \"monthsAtCompany\", ____________________________________, \"alice\", 5, 1, \"bob\", 3, 0, \"smith\", 4, 1, \"cat\", 4, 0); addEmployees(allEmployees); actual(dao.thisWeekJoiners()).should(equal(table( \"*id\", \"level\", \"monthsAtCompany\", ____________________________________, \"bob\", 3, 0, \"cat\", 4, 0))); } Note: The examples above assumes import static org.testingisdocumenting.webtau.WebTauCore.* or import static org.testingisdocumenting.webtau.WebTauDsl.* . For more TableData features, check reference/table-data reference page"],["JVM-business-logic@@documentation-artifacts@@living-document","JVM Business Logic","Documentation Artifacts","Living Document","In your test you can capture input and output and save it to a file. By using documentation systems you can use the captured artifacts to render business friendly documentation.As system evolves, so do your tests and so does your documentation. Essentially you will have a living document describing aspects of your system."],["JVM-business-logic@@documentation-artifacts@@capture-input","JVM Business Logic","Documentation Artifacts","Capture Input","Use doc.capture to save a test captured value to a file. Example below assumes core static import. import static org.testingisdocumenting.webtau.WebTauCore.*; TableData allEmployees = table( \"id\", \"level\", \"monthsAtCompany\", ____________________________________, \"alice\", 5, 1, \"bob\", 3, 0, \"smith\", 4, 1, \"cat\", 4, 0); addEmployees(allEmployees); doc.capture(\"all-employees\", allEmployees); // capture all employees for documentation purposes"],["JVM-business-logic@@documentation-artifacts@@capture-expected-output","JVM Business Logic","Documentation Artifacts","Capture Expected Output","Use doc.expected.capture to save most recent expected value. actual(dao.thisWeekJoiners()).should(equal(table( \"*id\", \"level\", \"monthsAtCompany\", ____________________________________, \"bob\", 3, 0, \"cat\", 4, 0))); doc.expected.capture(\"new-joiners\"); // capture expected new joiners for documentation purposes WebTau documentation is created using https://github.org/testingisdocumenting/znai Znai. It has include-table plugin to render a table giving a json or CSV file. text :include-table: doc-artifacts/all-employees.json :include-table: doc-artifacts/new-joiners.json Below is the example of the business logic rendered as documentation.Our HR system consider all employees that has been in the company less than a month as new joiners. For example, giving employees: id level monthsAtCompany alice 5 1 bob 3 0 smith 4 1 cat 4 0 System will list following employees as new joiners: id level monthsAtCompany bob 3 0 cat 4 0"],["JVM-business-logic@@documentation-artifacts@@capture-console-output","JVM Business Logic","Documentation Artifacts","Capture Console Output","Use doc.console.capture to capture console output of a provided code block doc.console.capture(\"http-get-console-output\", () -> { http.get(\"/end-point\", ((header, body) -> { DataNode price = body.get(\"price\"); price.should(equal(100)); })); }); https://github.org/testingisdocumenting/znai Znai has cli-output plugin to render ANSI output :include-cli-output: doc-artifacts/http-get-console-output.txt"],["continuous-integration@@GitHub@@uploading-reports","Continuous Integration","GitHub","Uploading Reports","WebTau generates report/introduction HTML Reports. To make reports accessible after your build run, use this step: - name: Upload all reports uses: actions/upload-artifact@v2 if: failure() with: name: all-webtau-reports path: \"*/**/webtau.report.html\" retention-days: 1 To only upload failed reports, configure report/configuration#failed-report-path failed report name and update the step: - name: Upload failed test reports uses: actions/upload-artifact@v2 if: failure() with: name: failed-webtau-reports path: \"*/**/*-failed*.html\" retention-days: 2"],["reference@@table-data@@create","Reference","Table Data","Create","Use language specific DSL to create TableData instance: Groovy [\"Col A\" | \"Col B\" | \"Col C\"] { ________________________________ \"v1a\" | \"v1b\" | \"v1c\" \"v2a\" | \"v2b\" | \"v2c\" } Java table(\"Col A\", \"Col B\", \"Col C\", ________________________________, \"v1a\", \"v1b\", \"v1c\", \"v2a\", \"v2b\", \"v2c\") Note: The example above assumes import static org.testingisdocumenting.webtau.WebTauCore.* or import static org.testingisdocumenting.webtau.WebTauDsl.* . Additionally WebTauCore has header-separating lines defined using underscores ___ of various lengths, which you can optionally use for aesthetics. Using ____ underscore is optional and is there for aesthetics only Groovy [\"Col A\" | \"Col B\" | \"Col C\"] { \"v1a\" | \"v1b\" | \"v1c\" \"v2a\" | \"v2b\" | \"v2c\" } Java table(\"Col A\", \"Col B\", \"Col C\").values( \"v1a\", \"v1b\", \"v1c\", \"v2a\", \"v2b\", \"v2c\")"],["reference@@table-data@@key-columns","Reference","Table Data","Key Columns","Use * in front of a column to specify it as a key column Groovy [\"*id\" | \"Name\" | \"Type\"] { ___________________________ \"id1\" | \"N\" | \"T\" \"id2\" | \"N2\" | \"T2\" \"id3\" | \"N\" | \"T\" } Java table(\"*id\" , \"Name\" , \"Type\", _______________________, \"id1\" , \"N\" , \"T\", \"id2\" , \"N2\" , \"T2\", \"id3\" , \"N\" , \"T\") To access a value by key column Groovy def found = tableData.findByKey(\"id2\") found.Name.should == \"N2\" Java Record found = tableData.findByKey(\"id2\"); String name = found.get(\"Name\"); actual(name).should(equal(\"N2\")); To change key columns of an existing table Groovy tableData.withNewKeyColumns(\"Name\", \"Type\") Java tableData.withNewKeyColumns(\"Name\", \"Type\") Note: withNewKeyColumns creates new table and validates new key column uniqueness"],["reference@@table-data@@create-from-list","Reference","Table Data","Create From List","Use to create TableData from a list of maps. Groovy def list = [ [k1: \"v1\", k2: \"v2\"], [k1: \"v3\", k3: \"v4\"]] TableData tableData = TableData.fromListOfMaps(list) TableData expected = [\"k1\" | \"k2\" | \"k3\"] { ____________________ \"v1\" | \"v2\" | null \"v3\" | null | \"v4\" } tableData.should == expected Java List<Map<String, ?>> list = new ArrayList<>(); list.add(CollectionUtils.map(\"k1\", \"v1\", \"k2\", \"v2\")); list.add(CollectionUtils.map(\"k1\", \"v3\", \"k3\", \"v4\")); TableData tableData = TableData.fromListOfMaps(list); TableData expected = table(\"k1\", \"k2\", \"k3\", _________________, \"v1\", \"v2\", null, \"v3\", null, \"v4\"); actual(tableData).should(equal(expected)); Note: WebTau merges keys from all list elements to create the table header"],["reference@@table-data@@create-from-existing-rows","Reference","Table Data","Create From Existing Rows","Use to create TableData from existing rows. Groovy def table = [\"*id\" | \"description\"] { __________________________ \"id1\" | \"description one\" \"id2\" | \"description two\" \"id3\" | \"description three\" } def newTable = table.fromRowsByKeys(\"id1\", \"id3\") newTable.should == [\"*id\" | \"description\"] { __________________________ \"id1\" | \"description one\" \"id3\" | \"description three\" } def table = [\"*id1\" | \"*id2\" | \"description\"] { _____________________________________ \"id11\" | \"id21\" | \"description one\" \"id21\" | \"id22\" | \"description two\" \"id31\" | \"id32\" | \"description three\" } def newTable = table.fromRowsByKeys(key(\"id11\", \"id21\"), key(\"id31\", \"id32\")) newTable.should == [\"*id1\" | \"*id2\" | \"description\"] { _____________________________________ \"id11\" | \"id21\" | \"description one\" \"id31\" | \"id32\" | \"description three\" } Java TableData table = table(\"*id\", \"description\", __________________________, \"id1\", \"description one\", \"id2\", \"description two\", \"id3\", \"description three\"); TableData newTable = table.fromRowsByKeys(\"id1\", \"id3\"); actual(newTable).should(equal(table(\"*id\", \"description\", __________________________, \"id1\", \"description one\", \"id3\", \"description three\"))); TableData table = table(\"*id1\", \"*id2\", \"description\", ____________________________________, \"id11\", \"id12\", \"description one\", \"id21\", \"id22\", \"description two\", \"id31\", \"id32\", \"description three\"); TableData newTable = table.fromRowsByKeys(key(\"id11\", \"id12\"), key(\"id31\", \"id32\")); actual(newTable).should(equal(table(\"*id1\", \"*id2\", \"description\", ____________________________________, \"id11\", \"id12\", \"description one\", \"id31\", \"id32\", \"description three\")));"],["reference@@table-data@@serialization","Reference","Table Data","Serialization","Use to serialize as JSON System.out.println(tableData.toJson()); [ { \"A\" : 1.3, \"B\" : 2 }, { \"A\" : \"Hello\", \"B\" : \"World\" } ] Use to serialize as CSV System.out.println(tableData.toCsv()); A,B 1.3,2 Hello,World"],["reference@@table-data@@serialization-to-file","Reference","Table Data","Serialization To File","Use data/json#write-table-data data.json.write to serialize Table Data to a file"],["reference@@table-data@@permutations","Reference","Table Data","Permutations","Use permute(v1, v2) to automatically generate multiple rows. Groovy [\"Col A\" | \"Col B\" | \"Col C\"] { ___________________________________________________________ permute(true, false) | \"v1b\" | permute('a', 'b') \"v2a\" | permute(10, 20) | \"v2c\" } Java table(\"Col A\" , \"Col B\" , \"Col C\", ________________________________________________________________, permute(true, false), \"v1b\" , permute('a', 'b'), \"v2a\" , permute(10, 20) , \"v2c\") Col A Col B Col C true v1b a false v1b a true v1b b false v1b b v2a 10 v2c v2a 20 v2c"],["reference@@table-data@@guid","Reference","Table Data","GUID","Use cell.guid to automatically generate unique ids. Groovy [\"ID\" | \"Col A\" | \"Col B\" | \"Col C\"] { ________________________________________________________________________ cell.guid | permute(true, false) | \"v1b\" | permute('a', 'b') cell.guid | \"v2a\" | permute(10, 20) | \"v2c\" } Java table(\"ID\" , \"Col A\" , \"Col B\" , \"Col C\", ______________________________________________________________________, cell.guid, permute(true, false), \"v1b\" , permute('a', 'b'), cell.guid, \"v2a\" , permute(10, 20) , \"v2c\") ID Col A Col B Col C f09d2bbe-7a92-4b13-949e-6fbbce03c175 true v1b a ae217e64-bf38-42b3-ade9-8b85f83b705b false v1b a 64b41702-6a54-446f-a30e-71eac6d8d2ab true v1b b a2682e5b-cd0e-4100-a3f5-77bdb5a85f7d false v1b b db0287c6-6ea7-4875-b497-41fa32fe23a0 v2a 10 v2c d0e87c04-f539-4968-9f2a-54692125091a v2a 20 v2c"],["reference@@table-data@@replace","Reference","Table Data","Replace","Use table.replace(before, after) to replace values in a table. Groovy [\"Col A\" | \"Col B\" | \"Col C\"] { ________________________________ \"v1a\" | \"v1b\" | \"v1c\" \"v2a\" | \"v2b\" | \"v2c\" } tableData.replace(\"v1b\", \"v1b_\") Java table(\"Col A\", \"Col B\", \"Col C\", ________________________________, \"v1a\", \"v1b\", \"v1c\", \"v2a\", \"v2b\", \"v2c\") tableData.replace(\"v1b\", \"v1b_\") Col A Col B Col C v1a v1b_ v1c v2a v2b v2c"],["reference@@table-data@@cell-above-value-reference","Reference","Table Data","Cell Above Value Reference","Use cell.above to refer to the previous row value Groovy [\"Name\" | \"Start Date\" | \"Games To Play\" ] { ______________________________________________________ \"John\" | LocalDate.of(2016, 6, 20) | 10 \"Bob\" | cell.above | 8 \"Mike\" | cell.above | 14 \"Drew\" | LocalDate.of(2016, 6, 22) | 10 \"Pete\" | cell.above | 11 \"Max\" | cell.above | 3 } Java table(\"Name\", \"Start Date\" , \"Games To Play\", __________________________________________________, \"John\", LocalDate.of(2016, 6, 20), 10, \"Bob\" , cell.above , 8, \"Mike\", cell.above , 14, \"Drew\", LocalDate.of(2016, 6, 22), 10, \"Pete\", cell.above , 11, \"Max\" , cell.above , 3) Name Start Date Games To Play John 2016-06-20 10 Bob 2016-06-20 8 Mike 2016-06-20 14 Drew 2016-06-22 10 Pete 2016-06-22 11 Max 2016-06-22 3"],["reference@@table-data@@cell-above-math","Reference","Table Data","Cell Above Math","Use cell.above.plus|minus to generate a derived value based on the previous row value Groovy [\"Name\" | \"Start Date\" | \"Games To Play\" ] { ______________________________________________________ \"John\" | LocalDate.of(2016, 6, 20) | 10 \"Bob\" | cell.above | cell.above + 1 \"Mike\" | cell.above | cell.above + 1 } Java table(\"Name\", \"Start Date\" , \"Games To Play\", ________________________________________________________________, \"John\", LocalDate.of(2016, 6, 20), 10, \"Bob\" , cell.above , cell.above.plus(1), \"Mike\", cell.above , cell.above.plus(1)) Name Start Date Games To Play John 2016-06-20 10 Bob 2016-06-20 11 Mike 2016-06-20 12 Extract cell.above.operation to make your intentions clearer Groovy def increment = cell.above + 1 [\"Name\" | \"Start Date\" | \"Games To Play\" ] { ______________________________________________________ \"John\" | LocalDate.of(2016, 6, 20) | 10 \"Bob\" | cell.above | increment \"Mike\" | cell.above | increment } Java TableDataCellValueGenerator<?> increment = cell.above.plus(1) table(\"Name\", \"Start Date\" , \"Games To Play\", ________________________________________________________________, \"John\", LocalDate.of(2016, 6, 20), 10, \"Bob\" , cell.above , increment, \"Mike\", cell.above , increment)"],["release-notes@@2024@@2-4","Release Notes","2024 Releases","2.4","Fix: matchers/contain-exactly containExactly in HTTP/introduction HTTP correctly marks passed and failed nodes in the output Doc: matchers/introduction#failure-output Matchers Introduction failure example output fix Doc: http HTTP/matchers#contain-exactly containExactly matcher example Doc: file-system/introduction File System is a separate chapter now Doc: matchers/introduction Matchers examples better way to display console output Add: browser/introduction browser .sendKeys to send keys to the window instead of a specific element Add: More details when matchers/contain-exactly containExactly mismatching a single element Add: additional details on failed messages for throwException matcher Add: fullAssertionError to force AssertionError to include the full step information. Convenient when using CI and depend on its reporting. Add: report/steps WebTau steps include exception name to help with cases when no exception message is present Add: Browser support using new headless mode Add: Browser support upgrade Selenium to 4.18 Add: speedup matchers/contain-exactly containExactly by pre-caching compare to handler Add: Reduce unnecessary CompareToComparator results lists creation Add: Optimize matchers/introduction matchers message generation to improve large set of data comparison Add: File Content file-system/file-content#wait-for-content wait to change Add: Browser page element browser/asynchronous-page#wait-to-change wait to change Add: Extra message in case of two empty maps and shouldNot equal Add: matchers/value-change#value-matcher change value matcher"],["release-notes@@2023@@2-3","Release Notes","2023 Releases","2.3","Doc: Update matchers/introduction Matchers Introduction. Add shouldNot and waitToNot example Doc: matchers/introduction Matchers import info links next to examples Doc: browser/basic-configuration Browser Basic Config Java examples Add: matchers/value-change/ code should[Not] change matcher Add: auto generated servers/introduction Server id when none provided Add: matchers/same-instance sameInstance matcher Add: matchers/contain-exactly containExactly matcher Add: throwException code matcher accepts ValueMatchers in addition to String and Pattern Add: browser/finders-and-filters#filter-by-distance Nearby browser filter"],["release-notes@@2023@@2-2","Release Notes","2023 Releases","2.2","Doc: servers/import-and-dependencies servers import Add: Limit matchers/introduction Matchers number of mismatch details printed by default via config matchersReportEntriesLimit Add: matchers/maps Equal Matcher adds asterisks around missing values in the actual output Add: matchers/java-beans-and-records#java-beans-contain-table-data Contain Matcher for iterable highlight the closest matches Add: matchers/java-beans-and-records#java-beans-contain-table-data Contain Matcher now prints potential mismatch details to look for Add: Map contains Map explicitly prints missing keys Add: list comparison prints missing and extra elements in a more compact way"],["release-notes@@2023@@2-1","Release Notes","2023 Releases","2.1","Add: browser browser/finders-and-filters#parent-finder-by-css element.parent(css) Fix: actual value path is now printed with default terminal color and not with the previous token color Fix: servers/introduction Servers fullUrl now includes queryString Doc: matchers/strings#contains string contain Doc: matchers/strings#regexp string regexp Doc: matchers/tables TableData Matcher Add: matchers/any-value any value matcher Add: matchers/maps#contain Map Contain displays missing keys inlined Add: matchers/maps#equality-comparison Map Equal displays missing keys inlined Add: browser/tables#extracting-table-data Browser tableEl.extratTableData to get table data from a page Add: reference/table-data TableData .addRowsExistingColumnsOnly(otherTable) to merge other tables into Add: reference/table-data TableData .getColumnNames() shortcut Add: browser/tables browser.table to validate and scrap page data in tabular format Add: browser/tables#supported-tables-flavor browser.table AG Grid flavor Add: browser/introduction Browser visible matcher is now part of core matchers and not browser specific Add: anyOf and containAll matchers toString is pretty printable Add: servers/introduction Servers shortcut to access servers/server-router#request-properties queryParam Add: servers/introduction Servers request object now exposes query and pathWithQuery"],["release-notes@@2023@@2-0","Release Notes","2023 Releases","2.0","Warning: Java 17+ JRE is required for version 2.0Warning: All deprecated methods from 1.x are now removed Fix: pretty printing tokenized messages properly resets bold font on tokens that should not use bold Add: Leverage junit5/getting-started JUnit5 listeners to generate report at the end of plan execution instead of shutdown hook Fix: Browser browser/page-element-and-value Page Element pretty print method falls back to a regular printing when can't parse HTML properly Doc: Simplified browser/page-element-and-value Browser Page Element Declaration Doc: use Java var in examples where it makes sense Doc: use browser.keys in browser/forms#custom-form-elements custom form element Breaking: remove DataRenderers in favor of PrettyPrinter Breaking: remove all deprecated methods Breaking: minimum Java requirement is 17 to build and to run Add: Do not print actual string values in case of failure when they have already been printed as part of mismatch details Add: Nested matchers/introduction Matchers are pretty printable Breaking: Browser browser/page-element-and-value Page Element is now a concrete class Breaking: Browser browser/page-element-and-value Page Element .getCount() and company replaced with .count Add: browser/alerts Browser Alert shortcuts Add: matchers/java-beans-and-records#java-records Java Records And Map/Table comparison Add: Browser browser/finders-and-filters#parent-finder el.parent Add: Report for browser/forms Browser Page Element setValue uses <enter> , <f1> etc for special symbols Add: Expose Browser browser/element-values-reference#attribute-value attribute value for streamlined assertion/waiting Add: web-socket/introduction WebSocket module is now using java.net.http module as implementation and not embedded tomcat Add: web-socket/header WebSocket Header Add: HTTP/introduction HTTP module is now using java.net.http module as implementation and not HttpURLConnection Add: reference/table-data TableData toString() uses pretty printed version without colors"],["release-notes@@2023@@1-53","Release Notes","2023 Releases","1.53","Fix: groovy-standalone-runner/introduction Standalone Runner headless mode by default is back: no more java app popup Fix: WebTau won't attempt to reopen browser at the end of tests if there is a failed test with browser/page-element-and-value PageElement related assertions Doc: getting-started/what-is-this#scripting-and-junit mention scripting in the docs intro page Add: configuration/options#browserUseFakeMedia browserUseFakeMedia to bypass permission asking for microphone/camera Add: browser/page-element-and-value PageElement pretty print for REPL/notebooks now includes HTML representation and prints first ten elements Add: Expose browser/page-element-and-value PageElement extract html nodes Add: Browser browser/page-element-and-value Page Element highlight when run in https://github.com/Kotlin/kotlin-jupyter Kotlin Notebook Add: Print complete expected value in case of matcher failure, and not just first 5 lines Add: Expose cfg instead of getCfg through WebTauDsl for Kotlin Notebooks Add: shortcut to set base url from Kotlin Notebook Add: PrettyPrintableToHtmlConverter to use in https://github.com/Kotlin/kotlin-jupyter Kotlin Notebook Add: automatically recreate browser/introduction browser driver when user manually close it during REPL or Notebook experience Add: configuration/options#browserSameDriverInThreads browserSameDriverInThreads option to force the same browser instance when running code from Notebook cells"],["release-notes@@2023@@1-52-1","Release Notes","2023 Releases","1.52.1","Add: tableVerticalSeparator option to override what vertical separator to use when printing TableData Add: disableConsoleOverallReport option to disable printing of overall test summary and report link"],["release-notes@@2023@@1-52","Release Notes","2023 Releases","1.52","Fix: notEqual matchers/introduction Matcher now properly delegates to nested matcher such as anyOf Fix: containsAll matchers/introduction Matcher now properly renders java bean details when compared against multiple maps Fix: anyOf matchers/introduction Matcher now properly renders java bean details when compared against multiple maps Fix: matchers/introduction Matchers contain messages to use not in details report in case of shouldNot Fix: HTTP/introduction HTTP java module now automatically handles config file, without requiring larger WebTau dependency Fix: matchers Web Report mis-alignment fix Fix: chrome driver init workaround for origin to work with new chrome Doc: groovy-standalone-runner/IDE-setup IDE Setup for auto-completion Doc: redo getting-started/what-is-this WebTau intro and include HTTP Resource and Web Socket section Doc: HTTP/import-and-dependencies HTTP imports, and sprinkle links to the page from various HTTP pages Doc: Combined HTTP CRUD and CRUD separated pages into HTTP/CRUD-example CRUD Example Doc: continuous-integration/GitHub GitHub CI reports upload Doc: matchers/strings string matcher Add: matchers/custom-compare-to-handler#custom-complex-domain-data CompareToHandler convertedExpected . It now participates in matching step output and uses converted values for failed and matched messaging. Add: report/steps Steps reporter prints error details on a next line as long as there is additional pretty printed details present (even if one liner) Add: reference/table-data TableData Record is pretty printable Add: List Of Beans And Map matchers/java-beans-and-records#java-beans-contain-map contain Add: List Of Beans And Table matchers/java-beans-and-records#java-beans-contain-table-data contain Add: HTTP/introduction HTTP body HTTP/matchers#contain-table contain TableData Add: configuration/options#waitTick waitTick globally configurable value Add: HTTP/HTTP-resource HTTP Resource to define lazy values to be waited or asserted on later Add: DataNode is now part of core instead of http module Add: web-socket/introduction WebSocket support Add: browser handle set select form value browser/forms#select by text Add: add browser.element as alias to $ Add: string matcher matchers/strings#different-number-of-empty-lines extra new lines check Add: always render HTTP/introduction HTTP JSON request/response as multiline even when the content is small enough to fit a single line Add: Path pretty printable with different colors for file and extension Add: pretty print reference/table-data TableData inside maps as a block to maintain indentation Add: code matchers (e.g. should throw exception) is now a step and use tokenized colored messages"],["release-notes@@2023@@1-51","Release Notes","2023 Releases","1.51","Fix: JUnit5 correctly registers failed matcher step Fix: HTML report long test names replaced with ellipsis Fix: Console output of failed steps and their output order at the end of tests run Fix: GraphQL/introduction GraphQL won't make schema calls for report when no GraphQL calls were performed during test Fix: matchers/introduction#waitto waitTo label fix preposition messaging Fix: remove extra spacing before delimiters when render report/steps Web Report Steps Doc: move report/tracing trace and report/warnings warning to their own documentation pages and document import prerequisites Doc: data/json#write-table-data data.json.write TableData add missing report output Doc: move junit5/getting-started JUnit5 to its own section Doc: JUnit5 junit5/dynamic-tests Dynamic Tests Java examples Add: Java config is handled when only webtau-core dependency is present. No need for junit specific dependency. Add: trace report/tracing#object-properties complex objects like list of java beans with nested beans Add: pretty print string in a special way when newline symbol is present Add: highlight elements inside lists that match criteria when shouldn't (when using shouldNot contain ) Add: initial pretty printer of class instances Add: use colored messages for matchers/introduction#failure-output failed assertion details Add: Display actual value with markers on Web Report in case of a failure Add: Pretty Print for Regexp Pattern instance with displaying flags Add: report/tracing tracing pretty prints complex values like maps and reference/table-data TableData Add: database/data-setup#cleaning-tables databaseTable.clear shortcut to delete from tables Add: reference/table-data#create-from-existing-rows TableData.fromRowsByKeys Add: Empty reference/table-data TableData pretty print explicitly states \"empty\" for empty tables Add: report/steps Steps input info additional indentation when printed to console Add: matchers/introduction Matchers only print minimal details in case of match, extra details in case of failure Add: matchers/introduction Matchers only print first 5 lines of expected for in progress message to reduce data duplication Add: Failed Test report/introduction#failed-test-summary Summary auto expands failed step and removed duplicated error message from parent step during rendering Add: matchers/introduction Matchers won't print failed matching details twice. Now it only prints during step rendering, and actual assertion message asks to check info above Add: reference/table-data TableData findByKey validation for keys presence and composite key size match Merge: database/introduction Database DatabaseFacade and Database to have consistent import of DB module only Add: database/introduction Database comparison and inserts automatically convert from camelCase to UNDER_SCORE Doc: database/introduction Database Spring Boot database/spring-boot-example Example Add: database/introduction Database pretty print query results in case of failure Add: database/introduction Database instance creation from explicit jdbc url Add: browser/introduction browser implicit browser/test-containers Test Containers support Add: browser/basic-configuration#access-to-base-url browser.getBaseUrlPort Add: matchers/java-beans-and-records#java-beans-equal-table-data Beans And Table comparison pretty prints beans as table Add: matchers/java-beans-and-records#java-bean-equals-map Bean And Map comparison pretty prints actual bean data in case of mismatch Add: reference/table-data TableData new comparison report with colors and better failure highlight Fix: properly render Arrays as actual instead of reference hash Add: list companion to map Add: data/json#parse-map data.json.mapFromString, data/json#parse-list data.json.listFromString, data/json#parse-tabledata data.json.tableFromString, data/json#parse-object data.json.objectFromString Add: renamed aMapOf to map and deprecated former Add: matchers/introduction waitTo on LiveValue support for greaterThan, lessThan kind of comparisons Add: pretty print output of actual value with failure markers in case of a matchers/introduction#failure-output Failed Matcher Add: matchers/introduction waitTo support for supplier Add: limit number of failed/errored tests printed at the end of run Add: configuration/options#consoleOutputCaptureDir consoleOutputCaptureDir for groovy-standalone-runner/introduction Groovy Standalone Runner Add: HTTP/body#form-url-encoded-data http.formDataUrlEncoded Add: data/base64 data.base64 to encode and decode strings Add: report/introduction Report shows first failed step in test summary instead of an exception message Add: Report shows warning icon next to tests with warnings Add: report/steps Steps, Trace, Warnings Java examples"],["release-notes@@2022@@1-50","Release Notes","2022 Releases","1.50","Fix: report properly prints browser sendKeys special keys like escape and pageUp Fix: DatabaseTable class is public now to be used in Java tests Doc: add examples and re-arrange getting-started/why Why page Doc: junit5/reporting#automatic-extension JUnit5 Automatic Extension Doc: data/import-and-dependencies data dependencies and import Doc: Add server responses to getting-started/what-is-this What Is This page and to README.md Doc: data/csv data Java examples Doc: data/introduction data more console output examples Doc: persona/HTTP-persona HTTP Persona Java Doc: servers/fake-server Fake Server Java examples Doc: servers/static-server Static Server Java examples Add: HTTP/data-coverage HTTP Data Coverage output as HTTP/data-coverage#json-output JSON Add: report/warnings warnings when HTTP/data-coverage#text-routes HTTP Text Route is missing for a call Add: HTTP/openAPI-spec Open API validation reports uses report/warnings Warnings to report undefined URLs Add: report/warnings warnings concept Add: Java getting-started/configuration#config-file config location override option Remove: HTTP Overall performance report Tab Add: data/csv#table-data-conversion Table Data Conversion function Add: HTTP text based HTTP/data-coverage#text-routes routes definition to support performance and data coverage without Open API spec Add: JUnit5 and JUnit4 runners print failed tests and their failed steps at the end of test runs Add: HTTP data coverage Web Report summary card Add: Generated Report Path is printed last so it is easier to find when there are failing tests Add: groovy-standalone-runner/introduction Groovy Runner prints failed steps info in addition to the test exception at the end Add: data/json data.json.write methods to write list/map/ reference/table-data TableData Add: data/json data.json Java examples Add: data/json#read-tabledata data.json.table Add: create reference/table-data TableData from reference/table-data#create-from-list list of maps Add: return value variant of JVM-business-logic/documentation-artifacts#capture-console-output doc.console.capture Add: data/csv#write-table-data data.csv.write with reference/table-data TableData Add: reference/table-data TableData addRow validates row size against header Add: reference/table-data TableData reference/table-data#serialization toCsv Fix: reference/table-data TableData addRow accepts List<?> instead of List<Object> Fix: properly report missing columns in case of list of maps and reference/table-data TableData comparison Add: HTTP data coverage HTTP/data-coverage#detect-fields-that-were-skipped console warning Add: initial HTTP/data-coverage HTTP data coverage Add: render report/tracing trace console output in a special manner Add: setValue to Web Page browser/element-actions-reference#modifications-no-log without logging secret values Add: Better support for groovy-standalone-runner/introduction Groovy Runner without explicit scenario Add: persona/introduction Persona vararg signature for Java Add: remove indentation from JVM-business-logic/documentation-artifacts#capture-console-output Doc Capture Console Output Add: way to provide actual value matchers/universal-compare#reporting name Add: server.removeOverride(WebTauServerOverride override) Add: cache get utilities/cache#cached-value-with-expiration with expiration method"],["release-notes@@2022@@1-49","Release Notes","2022 Releases","1.49","Remove highlight and cover from browser/documentation-artifacts browser.doc.capture Fix: Maven Plugin race condition between shutdown hook and apache FileUtils class unload Fix: global cleanup race condition, make sure it is called only once Fix: Web report tab names overflow ellipsis Fix: Report properly use report/configuration#report-name-and-url reportNameUrl parameter Fix: Web report always put Setup group first even if there are failed tests Fix: Make web report tab title stable (was changing name after javascript load) Fix: Web report entries and icons center alignment Doc: update HTTP/documentation-artifacts HTTP Documentation Artifacts with https://github.com/testingisdocumenting/znai Znai and Java examples Doc: Add data/pdf data.pdf Doc: Move data/introduction Data to its own chapter Doc: Consolidated HTTP report page with report/introduction Reports chapter Doc: Add Persona Examples to getting-started/what-is-this Intro Page Doc: HTTP/configuration HTTP Configuration Doc: Add HTTP/HTTP-calls#ping ping reference documentation Doc: Add https://github.com/testingisdocumenting/webtau/discussions GitHub discussions to footer and support link Doc: Merged HTTP Form Data into HTTP/body#form-file-data HTTP/body page Doc: Added getting-started/configuration#disable-ansi-colors Disable Anti Colors Doc: report/configuration Report Configuration Doc: HTTP/body#json-request-from-file HTTP JSON Body example from external file Doc: HTTP extract complex value from HTTP/data-node#extracting-values Data Node Doc: consolidate and introduce HTTP/body HTTP Body page Doc: Added HTTP/HTTP-calls HTTP Calls and example snippets now have links to referenced method Doc: HTTP/query-parameters HTTP Query Parameters Java examples Doc: Add Java examples to HTTP/data-node HTTP DataNode Doc: Add Java examples to HTTP/header#response-header HTTP Response Header Doc: Add Java examples to HTTP/header#content-type-shortcut HTTP Content Type shorcuts Deprecate pdf method in favor of HTTP/body#pdf-response data.pdf.read Deprecate browser/matchers#state Browser Element beVisble() variants of matchers in favor of visible Add matchers/custom-compare-to-handler compare to rule to compare HTTP/data-node DataNode and HTTP/body#json-request JsonRequestBody Add browser/documentation-artifacts#annotation-types browser.doc.arrow that connects two elements Add JVM-business-logic/documentation-artifacts#capture-console-output doc.console.capture to capture console output of a provided JVM code block Add browser/documentation-artifacts#badge-shortcut Badge Shortcut to browser/documentation-artifacts browser.doc Add sorting to report Config and Environment Variables tables Add extra getting-started/installation#groovy-runner Maven Plugin parameters: confg , reportPath , failedReportPath , reportName , reportNameUrl , noColor Reduce messaging in case of matchers/universal-compare matchers match event by removing \"Matches:\" prefix Add HTTP/introduction HTTP invalid JSON request/response handling Add HTTP/body#json-request HTTP body json shortcut Add HTTP/body#raw-response HTTP body raw response access Equal Matcher delegates to expected matcher bypassing one level of nested message Add matchers/any-of anyOf matcher Improve message for expected exception message when no exception is thrown Add HTTP/data-node#find-all DataNode.findAll Java implementation Add HTTP/data-node#find DataNode.find Java implementation Better error message in case of wrong webtau CLI argument name Add --version param to webtau CLI Add Java common header values as exposed properties: statusCode , contentType , location , contentLocation , contentLength , contentEncoding Deprecate HttpHeader.merge in favor of HttpHeader.with"],["release-notes@@2022@@1-48","Release Notes","2022 Releases","1.48","Fix: trim web report generated by section in case of long version name (e.g. snapshot) Fix: Java access modifier to browser/cookies Cookies and browser/local-storage Local Storage Doc: add java examples for HTTP/header#implicit-header implicit header creation and example .with usage Doc: add java examples for HTTP/header#explicit-header explicit header creation and example .with usage Doc: add links to individual configuration/options#browserHeight Options and Environment Variables and update default values Doc: document matchers/custom-compare-to-handler custom compare to handler Doc: document matchers/universal-compare#dates dates universal comparison Update documentation and implementation details classes to have consistent WebTau naming Add additional actual/expected label for first line mismatch message during strings comparison Add HttpHeader.with vararg support to conveniently provide multiple header values in Java Add documentation screenshot with annotations browser/documentation-artifacts#screenshot-of-a-specific-element capture for specific element Disable scenarios by groovy-standalone-runner/skipping-tests#unconditionally-skipping-tests file name convention Selenium 4 upgrade Speedup data/csv#list-of-map CSV numbers auto conversion Contain handler for Map and Map"],["release-notes@@2022@@1-47","Release Notes","2022 Releases","1.47","Fix: browser fetch int value fails on newer browsers Fix: proper handling of element.count stale element Selenium exception Fix report code highlight lines when multiline comment is present (e.g. /* */ ) Add matchers/universal-compare Matchers initial doc and placeholder Add LocalDateTime and LocalDate(expected) comparison Add scenario level elapsed time to Web Report in addition to suite level elapsed time Add scenario level elapsed time to Web Report in addition to suite level elapsed time Add browser browser/element-actions-reference#drag-and-drop drag and drop by Skip all the tests if groovy-standalone-runner/test-listeners before fist test setup has failed Brighter test status color in web report light theme Add human-readable tests performance elapsed time to web report Add fs.tempFile"],["release-notes@@2022@@1-46","Release Notes","2022 Releases","1.46","Add servers/proxy-server#preserve-original-call proxy server original call example and tweaks Add servers/proxy-server proxy server serverProxyMaxThreads config Fix: report failed code snippet font in light theme Fix: examples generation via webtau cli Fix: report HTTP warning call color in light theme Fix: report scrollbar color in light theme"],["release-notes@@2021@@1-45-1","Release Notes","2021 Releases","1.45.1","Fix: report light theme HTTP response match color"],["release-notes@@2021@@1-45","Release Notes","2021 Releases","1.45","Doc: document servers/introduction Servers Wrap deletion of all file-system/introduction temp files in a parent step Doc: document report report/steps step and trace core methods Move report tests status filter to the top and put theme switching to the bottom in its place Add trace core method to report values to console and web report Report color theme toggle and auto OS dark/light detection Improved code snippet rendering in web report Check element presence before browser/element-actions-reference#scrolling scroll to provide better error message Add utilities/cache#presence-check cache exists method Fix: cli/foreground-command CLI run working dir matches config working dir if none specified for the process Fix: remove internal info of cli/foreground-command CLI run from web report Fix: servers/static-server static content server capture of browser page request Fix: remove call to open api schema end-point at the end of tests if no http calls were performed during tests Fix: missing files message to use only path but not container id Fix: report step with 0ms now shows elapsed time Fix: file-system/file-content waiting for non-existing file content is not throwing error anymore Fix: jansi Mac M1 exception Fix: report key-value color contrast Fix: report extra scroll bar on overall summary screen"],["release-notes@@2021@@1-44-1","Release Notes","2021 Releases","1.44.1","Fix: report extra scroll bar on test summary screen"],["release-notes@@2021@@1-44","Release Notes","2021 Releases","1.44","Fix: HTTP JSON fullscreen payload alignment and colors Fix: proxy server captures request and response now Fix: string compare to handler show proper caret position of a change in case of not equal Fix: Report summary vertical scroll preserves tab selection at the top Doc: document cli background command cli/background-command#wait-timeout wait timeout report steps render step output information Add utilities/cache cache stored values validation and conversion to Path static server serves from symlink by resolving it first Add fs.zip command to zip files Add cli.runInBackground overload with config only parameter Add Servers section to a test data to display requests/responses that internal servers handled Add \"generated by\" section to test report summary page Ability to specify report name and optional associated URL Improvements on http call details page: proper vertical scroll and layout changes Web report card lists style change to make grouping more distinct and combined with title Changed web report to use dark theme"],["release-notes@@2021@@1-43-1","Release Notes","2021 Releases","1.43.1","Fix: configuration/groovy-config-file groovy config parsing of empty lists and simple variables reference within config"],["release-notes@@2021@@1-43","Release Notes","2021 Releases","1.43","Doc: Fix persona/introduction Persona Intro example snippets Doc: Add configuration/groovy-config-file Groovy Config complex objects, persona and overrides examples Doc: Add persona/HTTP-persona Persona HTTP authorization example Doc: Add persona/introduction Persona documentation Doc: combined \"files upload\" and \"PDF\" section under HTTP/files . Edited text. Parse Groovy config files using new internal DSL instead of GroovyConfig to better support Persona Add persona specific cliEnv config value to set persona/CLI-persona persona's common CLI environment variables Add java.time.Instant and String compareTo handler rule Add cliEnv config value to set common environment variables for cli/foreground-command#common-environment-variables cli.run and cli/background-command#common-environment-variables cli.runInBackground Server journal capture request body and response body Server support for other than application/json content type responses Implemented markBroken on static, proxy and fake servers Added overrides and slow down to static server Ignore groovy-standalone-runner/selective-run#sscenario single scenario and groovy-standalone-runner/skipping-tests#unconditionally-skipping-tests disabled scenario in REPL/test-runs REPL mode Add server router fluent syntax Add server router definition support for :param syntax Add server journal to track or wait on handled calls Handle router overrides in proxy server Server router - collection of overrides that can be set up and re-used for multiple servers Server implements autocloseable for try-with-resources Server route parameters based fake setup Initial fake server support Add config info to web report for cli/foreground-command#working-dir cli.run and cli/background-command#working-dir cli.rinInBackground Add config info to step output for cli/foreground-command#working-dir cli.run and cli/background-command#working-dir cli.rinInBackground Fix: cli/foreground-command#run-result cli.run results are properly returned when validation block is present Fix: browser screenshot on failure is displayed again in the generated report Fix: cli/foreground-command#run cli.run now captures output in case of timeout"],["release-notes@@2021@@1-42","Release Notes","2021 Releases","1.42","httpProxy via config stop all servers is a separate logged step REPL beforeAll , afterAll commands to trigger setup and teardown on demand cli.run local cli/foreground-command#timeout timeout override step accepts map as params for additional reporting file-system/file-content replace text content by regexp capture open api warnings in web report db data source creation is a reported step web report support for step key-value input add PageElement.all() to disambiguate element.should contain for browser assertions web report section with env vars Add browser browser/element-actions-reference#scrolling scroll actions Fix: cli/introduction cli.run quoted params handling"],["release-notes@@2021@@1-41","Release Notes","2021 Releases","1.41","No notes"],["release-notes@@2021@@1-40","Release Notes","2021 Releases","1.40","No notes"],["release-notes@@2021@@1-39","Release Notes","2021 Releases","1.39","No notes"]]
/*
 * Copyright 2019 TWO SIGMA OPEN SOURCE, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

znaiSearchIdx = lunr(function () {
    this.ref('id')
    this.field('section')
    this.field('pageTitle')
    this.field('pageSection')
    this.field('text')

    this.metadataWhitelist = ['position']

    znaiSearchData.forEach(function (e) {
        this.add({
            id: e[0],
            section: e[1],
            pageTitle: e[2],
            pageSection: e[3],
            text: e[4],
        })
    }, this)
})
